// Copyright 2016 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// WARNING: DO NOT EDIT. This file was generated by a program.
// See $MOJO_SDK/tools/bindings/mojom_bindings_generator.py.

library ledger_mojom;
import 'dart:async';
import 'package:mojo/bindings.dart' as bindings;
import 'package:mojo/core.dart' as core;
import 'package:mojo/mojo/bindings/types/service_describer.mojom.dart' as service_describer;

class Cardinality extends bindings.MojoEnum {
  static const Cardinality singular = const Cardinality._(0);
  static const Cardinality optional = const Cardinality._(1);
  static const Cardinality repeated = const Cardinality._(2);
  static const Cardinality optionalRepeated = const Cardinality._(3);

  const Cardinality._(int v) : super(v);

  static const Map<String, Cardinality> valuesMap = const {
    "singular": singular,
    "optional": optional,
    "repeated": repeated,
    "optionalRepeated": optionalRepeated,
  };
  static const List<Cardinality> values = const [
    singular,
    optional,
    repeated,
    optionalRepeated,
  ];

  static Cardinality valueOf(String name) => valuesMap[name];

  factory Cardinality(int v) {
    switch (v) {
      case 0:
        return Cardinality.singular;
      case 1:
        return Cardinality.optional;
      case 2:
        return Cardinality.repeated;
      case 3:
        return Cardinality.optionalRepeated;
      default:
        return null;
    }
  }

  static Cardinality decode(bindings.Decoder decoder0, int offset) {
    int v = decoder0.decodeUint32(offset);
    Cardinality result = new Cardinality(v);
    if (result == null) {
      throw new bindings.MojoCodecError(
          'Bad value $v for enum Cardinality.');
    }
    return result;
  }

  String toString() {
    switch(this) {
      case singular:
        return 'Cardinality.singular';
      case optional:
        return 'Cardinality.optional';
      case repeated:
        return 'Cardinality.repeated';
      case optionalRepeated:
        return 'Cardinality.optionalRepeated';
      default:
        return null;
    }
  }

  int toJson() => mojoEnumValue;
}



class LedgerOptions extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  bool createIfMissing = false;

  LedgerOptions() : super(kVersions.last.size);

  LedgerOptions.init(
    bool this.createIfMissing
  ) : super(kVersions.last.size);

  static LedgerOptions deserialize(bindings.Message message) {
    var decoder = new bindings.Decoder(message);
    var result = decode(decoder);
    if (decoder.excessHandles != null) {
      decoder.excessHandles.forEach((h) => h.close());
    }
    return result;
  }

  static LedgerOptions decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    LedgerOptions result = new LedgerOptions();

    var mainDataHeader = decoder0.decodeStructDataHeader();
    if (mainDataHeader.version <= kVersions.last.version) {
      // Scan in reverse order to optimize for more recent versions.
      for (int i = kVersions.length - 1; i >= 0; --i) {
        if (mainDataHeader.version >= kVersions[i].version) {
          if (mainDataHeader.size == kVersions[i].size) {
            // Found a match.
            break;
          }
          throw new bindings.MojoCodecError(
              'Header size doesn\'t correspond to known version size.');
        }
      }
    } else if (mainDataHeader.size < kVersions.last.size) {
      throw new bindings.MojoCodecError(
        'Message newer than the last known version cannot be shorter than '
        'required by the last known version.');
    }
    if (mainDataHeader.version >= 0) {
      
      result.createIfMissing = decoder0.decodeBool(8, 0);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    try {
      encoder0.encodeBool(createIfMissing, 8, 0);
    } on bindings.MojoCodecError catch(e) {
      e.message = "Error encountered while encoding field "
          "createIfMissing of struct LedgerOptions: $e";
      rethrow;
    }
  }

  String toString() {
    return "LedgerOptions("
           "createIfMissing: $createIfMissing" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["createIfMissing"] = createIfMissing;
    return map;
  }
}


class SessionGraph extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(24, 0)
  ];
  List<NodeRecord> nodes = null;
  List<EdgeRecord> edges = null;

  SessionGraph() : super(kVersions.last.size);

  SessionGraph.init(
    List<NodeRecord> this.nodes, 
    List<EdgeRecord> this.edges
  ) : super(kVersions.last.size);

  static SessionGraph deserialize(bindings.Message message) {
    var decoder = new bindings.Decoder(message);
    var result = decode(decoder);
    if (decoder.excessHandles != null) {
      decoder.excessHandles.forEach((h) => h.close());
    }
    return result;
  }

  static SessionGraph decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    SessionGraph result = new SessionGraph();

    var mainDataHeader = decoder0.decodeStructDataHeader();
    if (mainDataHeader.version <= kVersions.last.version) {
      // Scan in reverse order to optimize for more recent versions.
      for (int i = kVersions.length - 1; i >= 0; --i) {
        if (mainDataHeader.version >= kVersions[i].version) {
          if (mainDataHeader.size == kVersions[i].size) {
            // Found a match.
            break;
          }
          throw new bindings.MojoCodecError(
              'Header size doesn\'t correspond to known version size.');
        }
      }
    } else if (mainDataHeader.size < kVersions.last.size) {
      throw new bindings.MojoCodecError(
        'Message newer than the last known version cannot be shorter than '
        'required by the last known version.');
    }
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(8, false);
      {
        var si1 = decoder1.decodeDataHeaderForPointerArray(bindings.kUnspecifiedArrayLength);
        result.nodes = new List<NodeRecord>(si1.numElements);
        for (int i1 = 0; i1 < si1.numElements; ++i1) {
          
          var decoder2 = decoder1.decodePointer(bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize * i1, false);
          result.nodes[i1] = NodeRecord.decode(decoder2);
        }
      }
    }
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(16, false);
      {
        var si1 = decoder1.decodeDataHeaderForPointerArray(bindings.kUnspecifiedArrayLength);
        result.edges = new List<EdgeRecord>(si1.numElements);
        for (int i1 = 0; i1 < si1.numElements; ++i1) {
          
          var decoder2 = decoder1.decodePointer(bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize * i1, false);
          result.edges[i1] = EdgeRecord.decode(decoder2);
        }
      }
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    try {
      if (nodes == null) {
        encoder0.encodeNullPointer(8, false);
      } else {
        var encoder1 = encoder0.encodePointerArray(nodes.length, 8, bindings.kUnspecifiedArrayLength);
        for (int i0 = 0; i0 < nodes.length; ++i0) {
          encoder1.encodeStruct(nodes[i0], bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize * i0, false);
        }
      }
    } on bindings.MojoCodecError catch(e) {
      e.message = "Error encountered while encoding field "
          "nodes of struct SessionGraph: $e";
      rethrow;
    }
    try {
      if (edges == null) {
        encoder0.encodeNullPointer(16, false);
      } else {
        var encoder1 = encoder0.encodePointerArray(edges.length, 16, bindings.kUnspecifiedArrayLength);
        for (int i0 = 0; i0 < edges.length; ++i0) {
          encoder1.encodeStruct(edges[i0], bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize * i0, false);
        }
      }
    } on bindings.MojoCodecError catch(e) {
      e.message = "Error encountered while encoding field "
          "edges of struct SessionGraph: $e";
      rethrow;
    }
  }

  String toString() {
    return "SessionGraph("
           "nodes: $nodes" ", "
           "edges: $edges" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["nodes"] = nodes;
    map["edges"] = edges;
    return map;
  }
}


class NodeRecord extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(48, 0)
  ];
  NodeId nodeId = null;
  DeviceId creationDevice = null;
  UserId creationUser = null;
  List<Representation> representationValues = null;
  bool deleted = false;

  NodeRecord() : super(kVersions.last.size);

  NodeRecord.init(
    NodeId this.nodeId, 
    DeviceId this.creationDevice, 
    UserId this.creationUser, 
    List<Representation> this.representationValues, 
    bool this.deleted
  ) : super(kVersions.last.size);

  static NodeRecord deserialize(bindings.Message message) {
    var decoder = new bindings.Decoder(message);
    var result = decode(decoder);
    if (decoder.excessHandles != null) {
      decoder.excessHandles.forEach((h) => h.close());
    }
    return result;
  }

  static NodeRecord decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    NodeRecord result = new NodeRecord();

    var mainDataHeader = decoder0.decodeStructDataHeader();
    if (mainDataHeader.version <= kVersions.last.version) {
      // Scan in reverse order to optimize for more recent versions.
      for (int i = kVersions.length - 1; i >= 0; --i) {
        if (mainDataHeader.version >= kVersions[i].version) {
          if (mainDataHeader.size == kVersions[i].size) {
            // Found a match.
            break;
          }
          throw new bindings.MojoCodecError(
              'Header size doesn\'t correspond to known version size.');
        }
      }
    } else if (mainDataHeader.size < kVersions.last.size) {
      throw new bindings.MojoCodecError(
        'Message newer than the last known version cannot be shorter than '
        'required by the last known version.');
    }
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(8, false);
      result.nodeId = NodeId.decode(decoder1);
    }
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(16, true);
      result.creationDevice = DeviceId.decode(decoder1);
    }
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(24, true);
      result.creationUser = UserId.decode(decoder1);
    }
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(32, true);
      if (decoder1 == null) {
        result.representationValues = null;
      } else {
        var si1 = decoder1.decodeDataHeaderForPointerArray(bindings.kUnspecifiedArrayLength);
        result.representationValues = new List<Representation>(si1.numElements);
        for (int i1 = 0; i1 < si1.numElements; ++i1) {
          
          var decoder2 = decoder1.decodePointer(bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize * i1, false);
          result.representationValues[i1] = Representation.decode(decoder2);
        }
      }
    }
    if (mainDataHeader.version >= 0) {
      
      result.deleted = decoder0.decodeBool(40, 0);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    try {
      encoder0.encodeStruct(nodeId, 8, false);
    } on bindings.MojoCodecError catch(e) {
      e.message = "Error encountered while encoding field "
          "nodeId of struct NodeRecord: $e";
      rethrow;
    }
    try {
      encoder0.encodeStruct(creationDevice, 16, true);
    } on bindings.MojoCodecError catch(e) {
      e.message = "Error encountered while encoding field "
          "creationDevice of struct NodeRecord: $e";
      rethrow;
    }
    try {
      encoder0.encodeStruct(creationUser, 24, true);
    } on bindings.MojoCodecError catch(e) {
      e.message = "Error encountered while encoding field "
          "creationUser of struct NodeRecord: $e";
      rethrow;
    }
    try {
      if (representationValues == null) {
        encoder0.encodeNullPointer(32, true);
      } else {
        var encoder1 = encoder0.encodePointerArray(representationValues.length, 32, bindings.kUnspecifiedArrayLength);
        for (int i0 = 0; i0 < representationValues.length; ++i0) {
          encoder1.encodeStruct(representationValues[i0], bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize * i0, false);
        }
      }
    } on bindings.MojoCodecError catch(e) {
      e.message = "Error encountered while encoding field "
          "representationValues of struct NodeRecord: $e";
      rethrow;
    }
    try {
      encoder0.encodeBool(deleted, 40, 0);
    } on bindings.MojoCodecError catch(e) {
      e.message = "Error encountered while encoding field "
          "deleted of struct NodeRecord: $e";
      rethrow;
    }
  }

  String toString() {
    return "NodeRecord("
           "nodeId: $nodeId" ", "
           "creationDevice: $creationDevice" ", "
           "creationUser: $creationUser" ", "
           "representationValues: $representationValues" ", "
           "deleted: $deleted" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["nodeId"] = nodeId;
    map["creationDevice"] = creationDevice;
    map["creationUser"] = creationUser;
    map["representationValues"] = representationValues;
    map["deleted"] = deleted;
    return map;
  }
}


class EdgeRecord extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(64, 0)
  ];
  EdgeId edgeId = null;
  NodeId start = null;
  NodeId end = null;
  List<LabelUri> labels = null;
  DeviceId creationDevice = null;
  UserId creationUser = null;
  bool deleted = false;

  EdgeRecord() : super(kVersions.last.size);

  EdgeRecord.init(
    EdgeId this.edgeId, 
    NodeId this.start, 
    NodeId this.end, 
    List<LabelUri> this.labels, 
    DeviceId this.creationDevice, 
    UserId this.creationUser, 
    bool this.deleted
  ) : super(kVersions.last.size);

  static EdgeRecord deserialize(bindings.Message message) {
    var decoder = new bindings.Decoder(message);
    var result = decode(decoder);
    if (decoder.excessHandles != null) {
      decoder.excessHandles.forEach((h) => h.close());
    }
    return result;
  }

  static EdgeRecord decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    EdgeRecord result = new EdgeRecord();

    var mainDataHeader = decoder0.decodeStructDataHeader();
    if (mainDataHeader.version <= kVersions.last.version) {
      // Scan in reverse order to optimize for more recent versions.
      for (int i = kVersions.length - 1; i >= 0; --i) {
        if (mainDataHeader.version >= kVersions[i].version) {
          if (mainDataHeader.size == kVersions[i].size) {
            // Found a match.
            break;
          }
          throw new bindings.MojoCodecError(
              'Header size doesn\'t correspond to known version size.');
        }
      }
    } else if (mainDataHeader.size < kVersions.last.size) {
      throw new bindings.MojoCodecError(
        'Message newer than the last known version cannot be shorter than '
        'required by the last known version.');
    }
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(8, false);
      result.edgeId = EdgeId.decode(decoder1);
    }
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(16, false);
      result.start = NodeId.decode(decoder1);
    }
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(24, false);
      result.end = NodeId.decode(decoder1);
    }
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(32, false);
      {
        var si1 = decoder1.decodeDataHeaderForPointerArray(bindings.kUnspecifiedArrayLength);
        result.labels = new List<LabelUri>(si1.numElements);
        for (int i1 = 0; i1 < si1.numElements; ++i1) {
          
          var decoder2 = decoder1.decodePointer(bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize * i1, false);
          result.labels[i1] = LabelUri.decode(decoder2);
        }
      }
    }
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(40, true);
      result.creationDevice = DeviceId.decode(decoder1);
    }
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(48, true);
      result.creationUser = UserId.decode(decoder1);
    }
    if (mainDataHeader.version >= 0) {
      
      result.deleted = decoder0.decodeBool(56, 0);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    try {
      encoder0.encodeStruct(edgeId, 8, false);
    } on bindings.MojoCodecError catch(e) {
      e.message = "Error encountered while encoding field "
          "edgeId of struct EdgeRecord: $e";
      rethrow;
    }
    try {
      encoder0.encodeStruct(start, 16, false);
    } on bindings.MojoCodecError catch(e) {
      e.message = "Error encountered while encoding field "
          "start of struct EdgeRecord: $e";
      rethrow;
    }
    try {
      encoder0.encodeStruct(end, 24, false);
    } on bindings.MojoCodecError catch(e) {
      e.message = "Error encountered while encoding field "
          "end of struct EdgeRecord: $e";
      rethrow;
    }
    try {
      if (labels == null) {
        encoder0.encodeNullPointer(32, false);
      } else {
        var encoder1 = encoder0.encodePointerArray(labels.length, 32, bindings.kUnspecifiedArrayLength);
        for (int i0 = 0; i0 < labels.length; ++i0) {
          encoder1.encodeStruct(labels[i0], bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize * i0, false);
        }
      }
    } on bindings.MojoCodecError catch(e) {
      e.message = "Error encountered while encoding field "
          "labels of struct EdgeRecord: $e";
      rethrow;
    }
    try {
      encoder0.encodeStruct(creationDevice, 40, true);
    } on bindings.MojoCodecError catch(e) {
      e.message = "Error encountered while encoding field "
          "creationDevice of struct EdgeRecord: $e";
      rethrow;
    }
    try {
      encoder0.encodeStruct(creationUser, 48, true);
    } on bindings.MojoCodecError catch(e) {
      e.message = "Error encountered while encoding field "
          "creationUser of struct EdgeRecord: $e";
      rethrow;
    }
    try {
      encoder0.encodeBool(deleted, 56, 0);
    } on bindings.MojoCodecError catch(e) {
      e.message = "Error encountered while encoding field "
          "deleted of struct EdgeRecord: $e";
      rethrow;
    }
  }

  String toString() {
    return "EdgeRecord("
           "edgeId: $edgeId" ", "
           "start: $start" ", "
           "end: $end" ", "
           "labels: $labels" ", "
           "creationDevice: $creationDevice" ", "
           "creationUser: $creationUser" ", "
           "deleted: $deleted" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["edgeId"] = edgeId;
    map["start"] = start;
    map["end"] = end;
    map["labels"] = labels;
    map["creationDevice"] = creationDevice;
    map["creationUser"] = creationUser;
    map["deleted"] = deleted;
    return map;
  }
}


class Representation extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(40, 0)
  ];
  NodeId nodeId = null;
  LabelUri label = null;
  int timestamp = 0;
  List<int> value = null;

  Representation() : super(kVersions.last.size);

  Representation.init(
    NodeId this.nodeId, 
    LabelUri this.label, 
    int this.timestamp, 
    List<int> this.value
  ) : super(kVersions.last.size);

  static Representation deserialize(bindings.Message message) {
    var decoder = new bindings.Decoder(message);
    var result = decode(decoder);
    if (decoder.excessHandles != null) {
      decoder.excessHandles.forEach((h) => h.close());
    }
    return result;
  }

  static Representation decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    Representation result = new Representation();

    var mainDataHeader = decoder0.decodeStructDataHeader();
    if (mainDataHeader.version <= kVersions.last.version) {
      // Scan in reverse order to optimize for more recent versions.
      for (int i = kVersions.length - 1; i >= 0; --i) {
        if (mainDataHeader.version >= kVersions[i].version) {
          if (mainDataHeader.size == kVersions[i].size) {
            // Found a match.
            break;
          }
          throw new bindings.MojoCodecError(
              'Header size doesn\'t correspond to known version size.');
        }
      }
    } else if (mainDataHeader.size < kVersions.last.size) {
      throw new bindings.MojoCodecError(
        'Message newer than the last known version cannot be shorter than '
        'required by the last known version.');
    }
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(8, false);
      result.nodeId = NodeId.decode(decoder1);
    }
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(16, false);
      result.label = LabelUri.decode(decoder1);
    }
    if (mainDataHeader.version >= 0) {
      
      result.timestamp = decoder0.decodeUint64(24);
    }
    if (mainDataHeader.version >= 0) {
      
      result.value = decoder0.decodeUint8Array(32, bindings.kArrayNullable, bindings.kUnspecifiedArrayLength);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    try {
      encoder0.encodeStruct(nodeId, 8, false);
    } on bindings.MojoCodecError catch(e) {
      e.message = "Error encountered while encoding field "
          "nodeId of struct Representation: $e";
      rethrow;
    }
    try {
      encoder0.encodeStruct(label, 16, false);
    } on bindings.MojoCodecError catch(e) {
      e.message = "Error encountered while encoding field "
          "label of struct Representation: $e";
      rethrow;
    }
    try {
      encoder0.encodeUint64(timestamp, 24);
    } on bindings.MojoCodecError catch(e) {
      e.message = "Error encountered while encoding field "
          "timestamp of struct Representation: $e";
      rethrow;
    }
    try {
      encoder0.encodeUint8Array(value, 32, bindings.kArrayNullable, bindings.kUnspecifiedArrayLength);
    } on bindings.MojoCodecError catch(e) {
      e.message = "Error encountered while encoding field "
          "value of struct Representation: $e";
      rethrow;
    }
  }

  String toString() {
    return "Representation("
           "nodeId: $nodeId" ", "
           "label: $label" ", "
           "timestamp: $timestamp" ", "
           "value: $value" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["nodeId"] = nodeId;
    map["label"] = label;
    map["timestamp"] = timestamp;
    map["value"] = value;
    return map;
  }
}


class EdgeId extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  String id = null;

  EdgeId() : super(kVersions.last.size);

  EdgeId.init(
    String this.id
  ) : super(kVersions.last.size);

  static EdgeId deserialize(bindings.Message message) {
    var decoder = new bindings.Decoder(message);
    var result = decode(decoder);
    if (decoder.excessHandles != null) {
      decoder.excessHandles.forEach((h) => h.close());
    }
    return result;
  }

  static EdgeId decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    EdgeId result = new EdgeId();

    var mainDataHeader = decoder0.decodeStructDataHeader();
    if (mainDataHeader.version <= kVersions.last.version) {
      // Scan in reverse order to optimize for more recent versions.
      for (int i = kVersions.length - 1; i >= 0; --i) {
        if (mainDataHeader.version >= kVersions[i].version) {
          if (mainDataHeader.size == kVersions[i].size) {
            // Found a match.
            break;
          }
          throw new bindings.MojoCodecError(
              'Header size doesn\'t correspond to known version size.');
        }
      }
    } else if (mainDataHeader.size < kVersions.last.size) {
      throw new bindings.MojoCodecError(
        'Message newer than the last known version cannot be shorter than '
        'required by the last known version.');
    }
    if (mainDataHeader.version >= 0) {
      
      result.id = decoder0.decodeString(8, false);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    try {
      encoder0.encodeString(id, 8, false);
    } on bindings.MojoCodecError catch(e) {
      e.message = "Error encountered while encoding field "
          "id of struct EdgeId: $e";
      rethrow;
    }
  }

  String toString() {
    return "EdgeId("
           "id: $id" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["id"] = id;
    return map;
  }
}


class NodeId extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  String id = null;

  NodeId() : super(kVersions.last.size);

  NodeId.init(
    String this.id
  ) : super(kVersions.last.size);

  static NodeId deserialize(bindings.Message message) {
    var decoder = new bindings.Decoder(message);
    var result = decode(decoder);
    if (decoder.excessHandles != null) {
      decoder.excessHandles.forEach((h) => h.close());
    }
    return result;
  }

  static NodeId decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    NodeId result = new NodeId();

    var mainDataHeader = decoder0.decodeStructDataHeader();
    if (mainDataHeader.version <= kVersions.last.version) {
      // Scan in reverse order to optimize for more recent versions.
      for (int i = kVersions.length - 1; i >= 0; --i) {
        if (mainDataHeader.version >= kVersions[i].version) {
          if (mainDataHeader.size == kVersions[i].size) {
            // Found a match.
            break;
          }
          throw new bindings.MojoCodecError(
              'Header size doesn\'t correspond to known version size.');
        }
      }
    } else if (mainDataHeader.size < kVersions.last.size) {
      throw new bindings.MojoCodecError(
        'Message newer than the last known version cannot be shorter than '
        'required by the last known version.');
    }
    if (mainDataHeader.version >= 0) {
      
      result.id = decoder0.decodeString(8, false);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    try {
      encoder0.encodeString(id, 8, false);
    } on bindings.MojoCodecError catch(e) {
      e.message = "Error encountered while encoding field "
          "id of struct NodeId: $e";
      rethrow;
    }
  }

  String toString() {
    return "NodeId("
           "id: $id" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["id"] = id;
    return map;
  }
}


class DeviceId extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  String id = null;

  DeviceId() : super(kVersions.last.size);

  DeviceId.init(
    String this.id
  ) : super(kVersions.last.size);

  static DeviceId deserialize(bindings.Message message) {
    var decoder = new bindings.Decoder(message);
    var result = decode(decoder);
    if (decoder.excessHandles != null) {
      decoder.excessHandles.forEach((h) => h.close());
    }
    return result;
  }

  static DeviceId decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    DeviceId result = new DeviceId();

    var mainDataHeader = decoder0.decodeStructDataHeader();
    if (mainDataHeader.version <= kVersions.last.version) {
      // Scan in reverse order to optimize for more recent versions.
      for (int i = kVersions.length - 1; i >= 0; --i) {
        if (mainDataHeader.version >= kVersions[i].version) {
          if (mainDataHeader.size == kVersions[i].size) {
            // Found a match.
            break;
          }
          throw new bindings.MojoCodecError(
              'Header size doesn\'t correspond to known version size.');
        }
      }
    } else if (mainDataHeader.size < kVersions.last.size) {
      throw new bindings.MojoCodecError(
        'Message newer than the last known version cannot be shorter than '
        'required by the last known version.');
    }
    if (mainDataHeader.version >= 0) {
      
      result.id = decoder0.decodeString(8, false);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    try {
      encoder0.encodeString(id, 8, false);
    } on bindings.MojoCodecError catch(e) {
      e.message = "Error encountered while encoding field "
          "id of struct DeviceId: $e";
      rethrow;
    }
  }

  String toString() {
    return "DeviceId("
           "id: $id" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["id"] = id;
    return map;
  }
}


class UserId extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  String id = null;

  UserId() : super(kVersions.last.size);

  UserId.init(
    String this.id
  ) : super(kVersions.last.size);

  static UserId deserialize(bindings.Message message) {
    var decoder = new bindings.Decoder(message);
    var result = decode(decoder);
    if (decoder.excessHandles != null) {
      decoder.excessHandles.forEach((h) => h.close());
    }
    return result;
  }

  static UserId decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    UserId result = new UserId();

    var mainDataHeader = decoder0.decodeStructDataHeader();
    if (mainDataHeader.version <= kVersions.last.version) {
      // Scan in reverse order to optimize for more recent versions.
      for (int i = kVersions.length - 1; i >= 0; --i) {
        if (mainDataHeader.version >= kVersions[i].version) {
          if (mainDataHeader.size == kVersions[i].size) {
            // Found a match.
            break;
          }
          throw new bindings.MojoCodecError(
              'Header size doesn\'t correspond to known version size.');
        }
      }
    } else if (mainDataHeader.size < kVersions.last.size) {
      throw new bindings.MojoCodecError(
        'Message newer than the last known version cannot be shorter than '
        'required by the last known version.');
    }
    if (mainDataHeader.version >= 0) {
      
      result.id = decoder0.decodeString(8, false);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    try {
      encoder0.encodeString(id, 8, false);
    } on bindings.MojoCodecError catch(e) {
      e.message = "Error encountered while encoding field "
          "id of struct UserId: $e";
      rethrow;
    }
  }

  String toString() {
    return "UserId("
           "id: $id" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["id"] = id;
    return map;
  }
}


class StepId extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  String id = null;

  StepId() : super(kVersions.last.size);

  StepId.init(
    String this.id
  ) : super(kVersions.last.size);

  static StepId deserialize(bindings.Message message) {
    var decoder = new bindings.Decoder(message);
    var result = decode(decoder);
    if (decoder.excessHandles != null) {
      decoder.excessHandles.forEach((h) => h.close());
    }
    return result;
  }

  static StepId decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    StepId result = new StepId();

    var mainDataHeader = decoder0.decodeStructDataHeader();
    if (mainDataHeader.version <= kVersions.last.version) {
      // Scan in reverse order to optimize for more recent versions.
      for (int i = kVersions.length - 1; i >= 0; --i) {
        if (mainDataHeader.version >= kVersions[i].version) {
          if (mainDataHeader.size == kVersions[i].size) {
            // Found a match.
            break;
          }
          throw new bindings.MojoCodecError(
              'Header size doesn\'t correspond to known version size.');
        }
      }
    } else if (mainDataHeader.size < kVersions.last.size) {
      throw new bindings.MojoCodecError(
        'Message newer than the last known version cannot be shorter than '
        'required by the last known version.');
    }
    if (mainDataHeader.version >= 0) {
      
      result.id = decoder0.decodeString(8, false);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    try {
      encoder0.encodeString(id, 8, false);
    } on bindings.MojoCodecError catch(e) {
      e.message = "Error encountered while encoding field "
          "id of struct StepId: $e";
      rethrow;
    }
  }

  String toString() {
    return "StepId("
           "id: $id" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["id"] = id;
    return map;
  }
}


class SessionId extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  String id = null;

  SessionId() : super(kVersions.last.size);

  SessionId.init(
    String this.id
  ) : super(kVersions.last.size);

  static SessionId deserialize(bindings.Message message) {
    var decoder = new bindings.Decoder(message);
    var result = decode(decoder);
    if (decoder.excessHandles != null) {
      decoder.excessHandles.forEach((h) => h.close());
    }
    return result;
  }

  static SessionId decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    SessionId result = new SessionId();

    var mainDataHeader = decoder0.decodeStructDataHeader();
    if (mainDataHeader.version <= kVersions.last.version) {
      // Scan in reverse order to optimize for more recent versions.
      for (int i = kVersions.length - 1; i >= 0; --i) {
        if (mainDataHeader.version >= kVersions[i].version) {
          if (mainDataHeader.size == kVersions[i].size) {
            // Found a match.
            break;
          }
          throw new bindings.MojoCodecError(
              'Header size doesn\'t correspond to known version size.');
        }
      }
    } else if (mainDataHeader.size < kVersions.last.size) {
      throw new bindings.MojoCodecError(
        'Message newer than the last known version cannot be shorter than '
        'required by the last known version.');
    }
    if (mainDataHeader.version >= 0) {
      
      result.id = decoder0.decodeString(8, false);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    try {
      encoder0.encodeString(id, 8, false);
    } on bindings.MojoCodecError catch(e) {
      e.message = "Error encountered while encoding field "
          "id of struct SessionId: $e";
      rethrow;
    }
  }

  String toString() {
    return "SessionId("
           "id: $id" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["id"] = id;
    return map;
  }
}


class LabelUri extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  String uri = null;

  LabelUri() : super(kVersions.last.size);

  LabelUri.init(
    String this.uri
  ) : super(kVersions.last.size);

  static LabelUri deserialize(bindings.Message message) {
    var decoder = new bindings.Decoder(message);
    var result = decode(decoder);
    if (decoder.excessHandles != null) {
      decoder.excessHandles.forEach((h) => h.close());
    }
    return result;
  }

  static LabelUri decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    LabelUri result = new LabelUri();

    var mainDataHeader = decoder0.decodeStructDataHeader();
    if (mainDataHeader.version <= kVersions.last.version) {
      // Scan in reverse order to optimize for more recent versions.
      for (int i = kVersions.length - 1; i >= 0; --i) {
        if (mainDataHeader.version >= kVersions[i].version) {
          if (mainDataHeader.size == kVersions[i].size) {
            // Found a match.
            break;
          }
          throw new bindings.MojoCodecError(
              'Header size doesn\'t correspond to known version size.');
        }
      }
    } else if (mainDataHeader.size < kVersions.last.size) {
      throw new bindings.MojoCodecError(
        'Message newer than the last known version cannot be shorter than '
        'required by the last known version.');
    }
    if (mainDataHeader.version >= 0) {
      
      result.uri = decoder0.decodeString(8, false);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    try {
      encoder0.encodeString(uri, 8, false);
    } on bindings.MojoCodecError catch(e) {
      e.message = "Error encountered while encoding field "
          "uri of struct LabelUri: $e";
      rethrow;
    }
  }

  String toString() {
    return "LabelUri("
           "uri: $uri" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["uri"] = uri;
    return map;
  }
}


class PathExpression extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  List<LabelExpression> expressions = null;

  PathExpression() : super(kVersions.last.size);

  PathExpression.init(
    List<LabelExpression> this.expressions
  ) : super(kVersions.last.size);

  static PathExpression deserialize(bindings.Message message) {
    var decoder = new bindings.Decoder(message);
    var result = decode(decoder);
    if (decoder.excessHandles != null) {
      decoder.excessHandles.forEach((h) => h.close());
    }
    return result;
  }

  static PathExpression decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    PathExpression result = new PathExpression();

    var mainDataHeader = decoder0.decodeStructDataHeader();
    if (mainDataHeader.version <= kVersions.last.version) {
      // Scan in reverse order to optimize for more recent versions.
      for (int i = kVersions.length - 1; i >= 0; --i) {
        if (mainDataHeader.version >= kVersions[i].version) {
          if (mainDataHeader.size == kVersions[i].size) {
            // Found a match.
            break;
          }
          throw new bindings.MojoCodecError(
              'Header size doesn\'t correspond to known version size.');
        }
      }
    } else if (mainDataHeader.size < kVersions.last.size) {
      throw new bindings.MojoCodecError(
        'Message newer than the last known version cannot be shorter than '
        'required by the last known version.');
    }
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(8, false);
      {
        var si1 = decoder1.decodeDataHeaderForUnionArray(bindings.kUnspecifiedArrayLength);
        result.expressions = new List<LabelExpression>(si1.numElements);
        for (int i1 = 0; i1 < si1.numElements; ++i1) {
          
            result.expressions[i1] = LabelExpression.decode(decoder1, bindings.ArrayDataHeader.kHeaderSize + bindings.kUnionSize * i1);
            if (result.expressions[i1] == null) {
              throw new bindings.MojoCodecError(
                'Trying to decode null union for non-nullable LabelExpression.');
            }
        }
      }
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    try {
      if (expressions == null) {
        encoder0.encodeNullPointer(8, false);
      } else {
        var encoder1 = encoder0.encodeUnionArray(expressions.length, 8, bindings.kUnspecifiedArrayLength);
        for (int i0 = 0; i0 < expressions.length; ++i0) {
          encoder1.encodeUnion(expressions[i0], bindings.ArrayDataHeader.kHeaderSize + bindings.kUnionSize * i0, false);
        }
      }
    } on bindings.MojoCodecError catch(e) {
      e.message = "Error encountered while encoding field "
          "expressions of struct PathExpression: $e";
      rethrow;
    }
  }

  String toString() {
    return "PathExpression("
           "expressions: $expressions" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["expressions"] = expressions;
    return map;
  }
}


class SemanticExpression extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(32, 0)
  ];
  List<LabelUri> labels = null;
  Cardinality cardinality = null;
  PathExpression next = null;

  SemanticExpression() : super(kVersions.last.size);

  SemanticExpression.init(
    List<LabelUri> this.labels, 
    Cardinality this.cardinality, 
    PathExpression this.next
  ) : super(kVersions.last.size);

  static SemanticExpression deserialize(bindings.Message message) {
    var decoder = new bindings.Decoder(message);
    var result = decode(decoder);
    if (decoder.excessHandles != null) {
      decoder.excessHandles.forEach((h) => h.close());
    }
    return result;
  }

  static SemanticExpression decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    SemanticExpression result = new SemanticExpression();

    var mainDataHeader = decoder0.decodeStructDataHeader();
    if (mainDataHeader.version <= kVersions.last.version) {
      // Scan in reverse order to optimize for more recent versions.
      for (int i = kVersions.length - 1; i >= 0; --i) {
        if (mainDataHeader.version >= kVersions[i].version) {
          if (mainDataHeader.size == kVersions[i].size) {
            // Found a match.
            break;
          }
          throw new bindings.MojoCodecError(
              'Header size doesn\'t correspond to known version size.');
        }
      }
    } else if (mainDataHeader.size < kVersions.last.size) {
      throw new bindings.MojoCodecError(
        'Message newer than the last known version cannot be shorter than '
        'required by the last known version.');
    }
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(8, false);
      {
        var si1 = decoder1.decodeDataHeaderForPointerArray(bindings.kUnspecifiedArrayLength);
        result.labels = new List<LabelUri>(si1.numElements);
        for (int i1 = 0; i1 < si1.numElements; ++i1) {
          
          var decoder2 = decoder1.decodePointer(bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize * i1, false);
          result.labels[i1] = LabelUri.decode(decoder2);
        }
      }
    }
    if (mainDataHeader.version >= 0) {
      
        result.cardinality = Cardinality.decode(decoder0, 16);
        if (result.cardinality == null) {
          throw new bindings.MojoCodecError(
            'Trying to decode null union for non-nullable Cardinality.');
        }
    }
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(24, true);
      result.next = PathExpression.decode(decoder1);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    try {
      if (labels == null) {
        encoder0.encodeNullPointer(8, false);
      } else {
        var encoder1 = encoder0.encodePointerArray(labels.length, 8, bindings.kUnspecifiedArrayLength);
        for (int i0 = 0; i0 < labels.length; ++i0) {
          encoder1.encodeStruct(labels[i0], bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize * i0, false);
        }
      }
    } on bindings.MojoCodecError catch(e) {
      e.message = "Error encountered while encoding field "
          "labels of struct SemanticExpression: $e";
      rethrow;
    }
    try {
      encoder0.encodeEnum(cardinality, 16);
    } on bindings.MojoCodecError catch(e) {
      e.message = "Error encountered while encoding field "
          "cardinality of struct SemanticExpression: $e";
      rethrow;
    }
    try {
      encoder0.encodeStruct(next, 24, true);
    } on bindings.MojoCodecError catch(e) {
      e.message = "Error encountered while encoding field "
          "next of struct SemanticExpression: $e";
      rethrow;
    }
  }

  String toString() {
    return "SemanticExpression("
           "labels: $labels" ", "
           "cardinality: $cardinality" ", "
           "next: $next" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["labels"] = labels;
    map["cardinality"] = cardinality;
    map["next"] = next;
    return map;
  }
}


class RepresentationExpression extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  List<LabelUri> labels = null;

  RepresentationExpression() : super(kVersions.last.size);

  RepresentationExpression.init(
    List<LabelUri> this.labels
  ) : super(kVersions.last.size);

  static RepresentationExpression deserialize(bindings.Message message) {
    var decoder = new bindings.Decoder(message);
    var result = decode(decoder);
    if (decoder.excessHandles != null) {
      decoder.excessHandles.forEach((h) => h.close());
    }
    return result;
  }

  static RepresentationExpression decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    RepresentationExpression result = new RepresentationExpression();

    var mainDataHeader = decoder0.decodeStructDataHeader();
    if (mainDataHeader.version <= kVersions.last.version) {
      // Scan in reverse order to optimize for more recent versions.
      for (int i = kVersions.length - 1; i >= 0; --i) {
        if (mainDataHeader.version >= kVersions[i].version) {
          if (mainDataHeader.size == kVersions[i].size) {
            // Found a match.
            break;
          }
          throw new bindings.MojoCodecError(
              'Header size doesn\'t correspond to known version size.');
        }
      }
    } else if (mainDataHeader.size < kVersions.last.size) {
      throw new bindings.MojoCodecError(
        'Message newer than the last known version cannot be shorter than '
        'required by the last known version.');
    }
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(8, false);
      {
        var si1 = decoder1.decodeDataHeaderForPointerArray(bindings.kUnspecifiedArrayLength);
        result.labels = new List<LabelUri>(si1.numElements);
        for (int i1 = 0; i1 < si1.numElements; ++i1) {
          
          var decoder2 = decoder1.decodePointer(bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize * i1, false);
          result.labels[i1] = LabelUri.decode(decoder2);
        }
      }
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    try {
      if (labels == null) {
        encoder0.encodeNullPointer(8, false);
      } else {
        var encoder1 = encoder0.encodePointerArray(labels.length, 8, bindings.kUnspecifiedArrayLength);
        for (int i0 = 0; i0 < labels.length; ++i0) {
          encoder1.encodeStruct(labels[i0], bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize * i0, false);
        }
      }
    } on bindings.MojoCodecError catch(e) {
      e.message = "Error encountered while encoding field "
          "labels of struct RepresentationExpression: $e";
      rethrow;
    }
  }

  String toString() {
    return "RepresentationExpression("
           "labels: $labels" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["labels"] = labels;
    return map;
  }
}


class _LedgerAuthenticateParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  String username = null;

  _LedgerAuthenticateParams() : super(kVersions.last.size);

  _LedgerAuthenticateParams.init(
    String this.username
  ) : super(kVersions.last.size);

  static _LedgerAuthenticateParams deserialize(bindings.Message message) {
    var decoder = new bindings.Decoder(message);
    var result = decode(decoder);
    if (decoder.excessHandles != null) {
      decoder.excessHandles.forEach((h) => h.close());
    }
    return result;
  }

  static _LedgerAuthenticateParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _LedgerAuthenticateParams result = new _LedgerAuthenticateParams();

    var mainDataHeader = decoder0.decodeStructDataHeader();
    if (mainDataHeader.version <= kVersions.last.version) {
      // Scan in reverse order to optimize for more recent versions.
      for (int i = kVersions.length - 1; i >= 0; --i) {
        if (mainDataHeader.version >= kVersions[i].version) {
          if (mainDataHeader.size == kVersions[i].size) {
            // Found a match.
            break;
          }
          throw new bindings.MojoCodecError(
              'Header size doesn\'t correspond to known version size.');
        }
      }
    } else if (mainDataHeader.size < kVersions.last.size) {
      throw new bindings.MojoCodecError(
        'Message newer than the last known version cannot be shorter than '
        'required by the last known version.');
    }
    if (mainDataHeader.version >= 0) {
      
      result.username = decoder0.decodeString(8, false);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    try {
      encoder0.encodeString(username, 8, false);
    } on bindings.MojoCodecError catch(e) {
      e.message = "Error encountered while encoding field "
          "username of struct _LedgerAuthenticateParams: $e";
      rethrow;
    }
  }

  String toString() {
    return "_LedgerAuthenticateParams("
           "username: $username" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["username"] = username;
    return map;
  }
}


class LedgerAuthenticateResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(24, 0)
  ];
  UserId userId = null;
  LedgerStatus status = null;

  LedgerAuthenticateResponseParams() : super(kVersions.last.size);

  LedgerAuthenticateResponseParams.init(
    UserId this.userId, 
    LedgerStatus this.status
  ) : super(kVersions.last.size);

  static LedgerAuthenticateResponseParams deserialize(bindings.Message message) {
    var decoder = new bindings.Decoder(message);
    var result = decode(decoder);
    if (decoder.excessHandles != null) {
      decoder.excessHandles.forEach((h) => h.close());
    }
    return result;
  }

  static LedgerAuthenticateResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    LedgerAuthenticateResponseParams result = new LedgerAuthenticateResponseParams();

    var mainDataHeader = decoder0.decodeStructDataHeader();
    if (mainDataHeader.version <= kVersions.last.version) {
      // Scan in reverse order to optimize for more recent versions.
      for (int i = kVersions.length - 1; i >= 0; --i) {
        if (mainDataHeader.version >= kVersions[i].version) {
          if (mainDataHeader.size == kVersions[i].size) {
            // Found a match.
            break;
          }
          throw new bindings.MojoCodecError(
              'Header size doesn\'t correspond to known version size.');
        }
      }
    } else if (mainDataHeader.size < kVersions.last.size) {
      throw new bindings.MojoCodecError(
        'Message newer than the last known version cannot be shorter than '
        'required by the last known version.');
    }
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(8, true);
      result.userId = UserId.decode(decoder1);
    }
    if (mainDataHeader.version >= 0) {
      
        result.status = LedgerStatus.decode(decoder0, 16);
        if (result.status == null) {
          throw new bindings.MojoCodecError(
            'Trying to decode null union for non-nullable LedgerStatus.');
        }
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    try {
      encoder0.encodeStruct(userId, 8, true);
    } on bindings.MojoCodecError catch(e) {
      e.message = "Error encountered while encoding field "
          "userId of struct LedgerAuthenticateResponseParams: $e";
      rethrow;
    }
    try {
      encoder0.encodeEnum(status, 16);
    } on bindings.MojoCodecError catch(e) {
      e.message = "Error encountered while encoding field "
          "status of struct LedgerAuthenticateResponseParams: $e";
      rethrow;
    }
  }

  String toString() {
    return "LedgerAuthenticateResponseParams("
           "userId: $userId" ", "
           "status: $status" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["userId"] = userId;
    map["status"] = status;
    return map;
  }
}


class _LedgerCreateSessionParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(8, 0)
  ];

  _LedgerCreateSessionParams() : super(kVersions.last.size);

  _LedgerCreateSessionParams.init(
  ) : super(kVersions.last.size);

  static _LedgerCreateSessionParams deserialize(bindings.Message message) {
    var decoder = new bindings.Decoder(message);
    var result = decode(decoder);
    if (decoder.excessHandles != null) {
      decoder.excessHandles.forEach((h) => h.close());
    }
    return result;
  }

  static _LedgerCreateSessionParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _LedgerCreateSessionParams result = new _LedgerCreateSessionParams();

    var mainDataHeader = decoder0.decodeStructDataHeader();
    if (mainDataHeader.version <= kVersions.last.version) {
      // Scan in reverse order to optimize for more recent versions.
      for (int i = kVersions.length - 1; i >= 0; --i) {
        if (mainDataHeader.version >= kVersions[i].version) {
          if (mainDataHeader.size == kVersions[i].size) {
            // Found a match.
            break;
          }
          throw new bindings.MojoCodecError(
              'Header size doesn\'t correspond to known version size.');
        }
      }
    } else if (mainDataHeader.size < kVersions.last.size) {
      throw new bindings.MojoCodecError(
        'Message newer than the last known version cannot be shorter than '
        'required by the last known version.');
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    encoder.getStructEncoderAtOffset(kVersions.last);
  }

  String toString() {
    return "_LedgerCreateSessionParams("")";
  }

  Map toJson() {
    Map map = new Map();
    return map;
  }
}


class LedgerCreateSessionResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(24, 0)
  ];
  SessionId sessionId = null;
  LedgerStatus status = null;

  LedgerCreateSessionResponseParams() : super(kVersions.last.size);

  LedgerCreateSessionResponseParams.init(
    SessionId this.sessionId, 
    LedgerStatus this.status
  ) : super(kVersions.last.size);

  static LedgerCreateSessionResponseParams deserialize(bindings.Message message) {
    var decoder = new bindings.Decoder(message);
    var result = decode(decoder);
    if (decoder.excessHandles != null) {
      decoder.excessHandles.forEach((h) => h.close());
    }
    return result;
  }

  static LedgerCreateSessionResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    LedgerCreateSessionResponseParams result = new LedgerCreateSessionResponseParams();

    var mainDataHeader = decoder0.decodeStructDataHeader();
    if (mainDataHeader.version <= kVersions.last.version) {
      // Scan in reverse order to optimize for more recent versions.
      for (int i = kVersions.length - 1; i >= 0; --i) {
        if (mainDataHeader.version >= kVersions[i].version) {
          if (mainDataHeader.size == kVersions[i].size) {
            // Found a match.
            break;
          }
          throw new bindings.MojoCodecError(
              'Header size doesn\'t correspond to known version size.');
        }
      }
    } else if (mainDataHeader.size < kVersions.last.size) {
      throw new bindings.MojoCodecError(
        'Message newer than the last known version cannot be shorter than '
        'required by the last known version.');
    }
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(8, true);
      result.sessionId = SessionId.decode(decoder1);
    }
    if (mainDataHeader.version >= 0) {
      
        result.status = LedgerStatus.decode(decoder0, 16);
        if (result.status == null) {
          throw new bindings.MojoCodecError(
            'Trying to decode null union for non-nullable LedgerStatus.');
        }
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    try {
      encoder0.encodeStruct(sessionId, 8, true);
    } on bindings.MojoCodecError catch(e) {
      e.message = "Error encountered while encoding field "
          "sessionId of struct LedgerCreateSessionResponseParams: $e";
      rethrow;
    }
    try {
      encoder0.encodeEnum(status, 16);
    } on bindings.MojoCodecError catch(e) {
      e.message = "Error encountered while encoding field "
          "status of struct LedgerCreateSessionResponseParams: $e";
      rethrow;
    }
  }

  String toString() {
    return "LedgerCreateSessionResponseParams("
           "sessionId: $sessionId" ", "
           "status: $status" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["sessionId"] = sessionId;
    map["status"] = status;
    return map;
  }
}


class _LedgerGetSessionGraphParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(24, 0)
  ];
  SessionId sessionId = null;
  LedgerOptions options = null;

  _LedgerGetSessionGraphParams() : super(kVersions.last.size);

  _LedgerGetSessionGraphParams.init(
    SessionId this.sessionId, 
    LedgerOptions this.options
  ) : super(kVersions.last.size);

  static _LedgerGetSessionGraphParams deserialize(bindings.Message message) {
    var decoder = new bindings.Decoder(message);
    var result = decode(decoder);
    if (decoder.excessHandles != null) {
      decoder.excessHandles.forEach((h) => h.close());
    }
    return result;
  }

  static _LedgerGetSessionGraphParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _LedgerGetSessionGraphParams result = new _LedgerGetSessionGraphParams();

    var mainDataHeader = decoder0.decodeStructDataHeader();
    if (mainDataHeader.version <= kVersions.last.version) {
      // Scan in reverse order to optimize for more recent versions.
      for (int i = kVersions.length - 1; i >= 0; --i) {
        if (mainDataHeader.version >= kVersions[i].version) {
          if (mainDataHeader.size == kVersions[i].size) {
            // Found a match.
            break;
          }
          throw new bindings.MojoCodecError(
              'Header size doesn\'t correspond to known version size.');
        }
      }
    } else if (mainDataHeader.size < kVersions.last.size) {
      throw new bindings.MojoCodecError(
        'Message newer than the last known version cannot be shorter than '
        'required by the last known version.');
    }
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(8, false);
      result.sessionId = SessionId.decode(decoder1);
    }
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(16, false);
      result.options = LedgerOptions.decode(decoder1);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    try {
      encoder0.encodeStruct(sessionId, 8, false);
    } on bindings.MojoCodecError catch(e) {
      e.message = "Error encountered while encoding field "
          "sessionId of struct _LedgerGetSessionGraphParams: $e";
      rethrow;
    }
    try {
      encoder0.encodeStruct(options, 16, false);
    } on bindings.MojoCodecError catch(e) {
      e.message = "Error encountered while encoding field "
          "options of struct _LedgerGetSessionGraphParams: $e";
      rethrow;
    }
  }

  String toString() {
    return "_LedgerGetSessionGraphParams("
           "sessionId: $sessionId" ", "
           "options: $options" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["sessionId"] = sessionId;
    map["options"] = options;
    return map;
  }
}


class LedgerGetSessionGraphResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(24, 0)
  ];
  SessionGraph sessionGraph = null;
  LedgerStatus status = null;

  LedgerGetSessionGraphResponseParams() : super(kVersions.last.size);

  LedgerGetSessionGraphResponseParams.init(
    SessionGraph this.sessionGraph, 
    LedgerStatus this.status
  ) : super(kVersions.last.size);

  static LedgerGetSessionGraphResponseParams deserialize(bindings.Message message) {
    var decoder = new bindings.Decoder(message);
    var result = decode(decoder);
    if (decoder.excessHandles != null) {
      decoder.excessHandles.forEach((h) => h.close());
    }
    return result;
  }

  static LedgerGetSessionGraphResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    LedgerGetSessionGraphResponseParams result = new LedgerGetSessionGraphResponseParams();

    var mainDataHeader = decoder0.decodeStructDataHeader();
    if (mainDataHeader.version <= kVersions.last.version) {
      // Scan in reverse order to optimize for more recent versions.
      for (int i = kVersions.length - 1; i >= 0; --i) {
        if (mainDataHeader.version >= kVersions[i].version) {
          if (mainDataHeader.size == kVersions[i].size) {
            // Found a match.
            break;
          }
          throw new bindings.MojoCodecError(
              'Header size doesn\'t correspond to known version size.');
        }
      }
    } else if (mainDataHeader.size < kVersions.last.size) {
      throw new bindings.MojoCodecError(
        'Message newer than the last known version cannot be shorter than '
        'required by the last known version.');
    }
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(8, true);
      result.sessionGraph = SessionGraph.decode(decoder1);
    }
    if (mainDataHeader.version >= 0) {
      
        result.status = LedgerStatus.decode(decoder0, 16);
        if (result.status == null) {
          throw new bindings.MojoCodecError(
            'Trying to decode null union for non-nullable LedgerStatus.');
        }
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    try {
      encoder0.encodeStruct(sessionGraph, 8, true);
    } on bindings.MojoCodecError catch(e) {
      e.message = "Error encountered while encoding field "
          "sessionGraph of struct LedgerGetSessionGraphResponseParams: $e";
      rethrow;
    }
    try {
      encoder0.encodeEnum(status, 16);
    } on bindings.MojoCodecError catch(e) {
      e.message = "Error encountered while encoding field "
          "status of struct LedgerGetSessionGraphResponseParams: $e";
      rethrow;
    }
  }

  String toString() {
    return "LedgerGetSessionGraphResponseParams("
           "sessionGraph: $sessionGraph" ", "
           "status: $status" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["sessionGraph"] = sessionGraph;
    map["status"] = status;
    return map;
  }
}


class _LedgerAddObserverParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(32, 0)
  ];
  SessionId sessionId = null;
  PathExpression query = null;
  LedgerObserverInterface observer = null;

  _LedgerAddObserverParams() : super(kVersions.last.size);

  _LedgerAddObserverParams.init(
    SessionId this.sessionId, 
    PathExpression this.query, 
    LedgerObserverInterface this.observer
  ) : super(kVersions.last.size);

  static _LedgerAddObserverParams deserialize(bindings.Message message) {
    var decoder = new bindings.Decoder(message);
    var result = decode(decoder);
    if (decoder.excessHandles != null) {
      decoder.excessHandles.forEach((h) => h.close());
    }
    return result;
  }

  static _LedgerAddObserverParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _LedgerAddObserverParams result = new _LedgerAddObserverParams();

    var mainDataHeader = decoder0.decodeStructDataHeader();
    if (mainDataHeader.version <= kVersions.last.version) {
      // Scan in reverse order to optimize for more recent versions.
      for (int i = kVersions.length - 1; i >= 0; --i) {
        if (mainDataHeader.version >= kVersions[i].version) {
          if (mainDataHeader.size == kVersions[i].size) {
            // Found a match.
            break;
          }
          throw new bindings.MojoCodecError(
              'Header size doesn\'t correspond to known version size.');
        }
      }
    } else if (mainDataHeader.size < kVersions.last.size) {
      throw new bindings.MojoCodecError(
        'Message newer than the last known version cannot be shorter than '
        'required by the last known version.');
    }
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(8, false);
      result.sessionId = SessionId.decode(decoder1);
    }
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(16, true);
      result.query = PathExpression.decode(decoder1);
    }
    if (mainDataHeader.version >= 0) {
      
      result.observer = decoder0.decodeServiceInterface(24, false, LedgerObserverProxy.newFromEndpoint);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    try {
      encoder0.encodeStruct(sessionId, 8, false);
    } on bindings.MojoCodecError catch(e) {
      e.message = "Error encountered while encoding field "
          "sessionId of struct _LedgerAddObserverParams: $e";
      rethrow;
    }
    try {
      encoder0.encodeStruct(query, 16, true);
    } on bindings.MojoCodecError catch(e) {
      e.message = "Error encountered while encoding field "
          "query of struct _LedgerAddObserverParams: $e";
      rethrow;
    }
    try {
      encoder0.encodeInterface(observer, 24, false);
    } on bindings.MojoCodecError catch(e) {
      e.message = "Error encountered while encoding field "
          "observer of struct _LedgerAddObserverParams: $e";
      rethrow;
    }
  }

  String toString() {
    return "_LedgerAddObserverParams("
           "sessionId: $sessionId" ", "
           "query: $query" ", "
           "observer: $observer" ")";
  }

  Map toJson() {
    throw new bindings.MojoCodecError(
        'Object containing handles cannot be encoded to JSON.');
  }
}


class LedgerAddObserverResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  LedgerStatus status = null;

  LedgerAddObserverResponseParams() : super(kVersions.last.size);

  LedgerAddObserverResponseParams.init(
    LedgerStatus this.status
  ) : super(kVersions.last.size);

  static LedgerAddObserverResponseParams deserialize(bindings.Message message) {
    var decoder = new bindings.Decoder(message);
    var result = decode(decoder);
    if (decoder.excessHandles != null) {
      decoder.excessHandles.forEach((h) => h.close());
    }
    return result;
  }

  static LedgerAddObserverResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    LedgerAddObserverResponseParams result = new LedgerAddObserverResponseParams();

    var mainDataHeader = decoder0.decodeStructDataHeader();
    if (mainDataHeader.version <= kVersions.last.version) {
      // Scan in reverse order to optimize for more recent versions.
      for (int i = kVersions.length - 1; i >= 0; --i) {
        if (mainDataHeader.version >= kVersions[i].version) {
          if (mainDataHeader.size == kVersions[i].size) {
            // Found a match.
            break;
          }
          throw new bindings.MojoCodecError(
              'Header size doesn\'t correspond to known version size.');
        }
      }
    } else if (mainDataHeader.size < kVersions.last.size) {
      throw new bindings.MojoCodecError(
        'Message newer than the last known version cannot be shorter than '
        'required by the last known version.');
    }
    if (mainDataHeader.version >= 0) {
      
        result.status = LedgerStatus.decode(decoder0, 8);
        if (result.status == null) {
          throw new bindings.MojoCodecError(
            'Trying to decode null union for non-nullable LedgerStatus.');
        }
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    try {
      encoder0.encodeEnum(status, 8);
    } on bindings.MojoCodecError catch(e) {
      e.message = "Error encountered while encoding field "
          "status of struct LedgerAddObserverResponseParams: $e";
      rethrow;
    }
  }

  String toString() {
    return "LedgerAddObserverResponseParams("
           "status: $status" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["status"] = status;
    return map;
  }
}


class _LedgerUpdateSessionGraphParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(56, 0)
  ];
  SessionId sessionId = null;
  List<NodeRecord> nodesToAdd = null;
  List<EdgeRecord> edgesToAdd = null;
  List<Representation> valuesToUpdate = null;
  List<NodeId> nodesToRemove = null;
  List<EdgeId> edgesToRemove = null;

  _LedgerUpdateSessionGraphParams() : super(kVersions.last.size);

  _LedgerUpdateSessionGraphParams.init(
    SessionId this.sessionId, 
    List<NodeRecord> this.nodesToAdd, 
    List<EdgeRecord> this.edgesToAdd, 
    List<Representation> this.valuesToUpdate, 
    List<NodeId> this.nodesToRemove, 
    List<EdgeId> this.edgesToRemove
  ) : super(kVersions.last.size);

  static _LedgerUpdateSessionGraphParams deserialize(bindings.Message message) {
    var decoder = new bindings.Decoder(message);
    var result = decode(decoder);
    if (decoder.excessHandles != null) {
      decoder.excessHandles.forEach((h) => h.close());
    }
    return result;
  }

  static _LedgerUpdateSessionGraphParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _LedgerUpdateSessionGraphParams result = new _LedgerUpdateSessionGraphParams();

    var mainDataHeader = decoder0.decodeStructDataHeader();
    if (mainDataHeader.version <= kVersions.last.version) {
      // Scan in reverse order to optimize for more recent versions.
      for (int i = kVersions.length - 1; i >= 0; --i) {
        if (mainDataHeader.version >= kVersions[i].version) {
          if (mainDataHeader.size == kVersions[i].size) {
            // Found a match.
            break;
          }
          throw new bindings.MojoCodecError(
              'Header size doesn\'t correspond to known version size.');
        }
      }
    } else if (mainDataHeader.size < kVersions.last.size) {
      throw new bindings.MojoCodecError(
        'Message newer than the last known version cannot be shorter than '
        'required by the last known version.');
    }
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(8, false);
      result.sessionId = SessionId.decode(decoder1);
    }
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(16, true);
      if (decoder1 == null) {
        result.nodesToAdd = null;
      } else {
        var si1 = decoder1.decodeDataHeaderForPointerArray(bindings.kUnspecifiedArrayLength);
        result.nodesToAdd = new List<NodeRecord>(si1.numElements);
        for (int i1 = 0; i1 < si1.numElements; ++i1) {
          
          var decoder2 = decoder1.decodePointer(bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize * i1, false);
          result.nodesToAdd[i1] = NodeRecord.decode(decoder2);
        }
      }
    }
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(24, true);
      if (decoder1 == null) {
        result.edgesToAdd = null;
      } else {
        var si1 = decoder1.decodeDataHeaderForPointerArray(bindings.kUnspecifiedArrayLength);
        result.edgesToAdd = new List<EdgeRecord>(si1.numElements);
        for (int i1 = 0; i1 < si1.numElements; ++i1) {
          
          var decoder2 = decoder1.decodePointer(bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize * i1, false);
          result.edgesToAdd[i1] = EdgeRecord.decode(decoder2);
        }
      }
    }
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(32, true);
      if (decoder1 == null) {
        result.valuesToUpdate = null;
      } else {
        var si1 = decoder1.decodeDataHeaderForPointerArray(bindings.kUnspecifiedArrayLength);
        result.valuesToUpdate = new List<Representation>(si1.numElements);
        for (int i1 = 0; i1 < si1.numElements; ++i1) {
          
          var decoder2 = decoder1.decodePointer(bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize * i1, false);
          result.valuesToUpdate[i1] = Representation.decode(decoder2);
        }
      }
    }
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(40, true);
      if (decoder1 == null) {
        result.nodesToRemove = null;
      } else {
        var si1 = decoder1.decodeDataHeaderForPointerArray(bindings.kUnspecifiedArrayLength);
        result.nodesToRemove = new List<NodeId>(si1.numElements);
        for (int i1 = 0; i1 < si1.numElements; ++i1) {
          
          var decoder2 = decoder1.decodePointer(bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize * i1, false);
          result.nodesToRemove[i1] = NodeId.decode(decoder2);
        }
      }
    }
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(48, true);
      if (decoder1 == null) {
        result.edgesToRemove = null;
      } else {
        var si1 = decoder1.decodeDataHeaderForPointerArray(bindings.kUnspecifiedArrayLength);
        result.edgesToRemove = new List<EdgeId>(si1.numElements);
        for (int i1 = 0; i1 < si1.numElements; ++i1) {
          
          var decoder2 = decoder1.decodePointer(bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize * i1, false);
          result.edgesToRemove[i1] = EdgeId.decode(decoder2);
        }
      }
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    try {
      encoder0.encodeStruct(sessionId, 8, false);
    } on bindings.MojoCodecError catch(e) {
      e.message = "Error encountered while encoding field "
          "sessionId of struct _LedgerUpdateSessionGraphParams: $e";
      rethrow;
    }
    try {
      if (nodesToAdd == null) {
        encoder0.encodeNullPointer(16, true);
      } else {
        var encoder1 = encoder0.encodePointerArray(nodesToAdd.length, 16, bindings.kUnspecifiedArrayLength);
        for (int i0 = 0; i0 < nodesToAdd.length; ++i0) {
          encoder1.encodeStruct(nodesToAdd[i0], bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize * i0, false);
        }
      }
    } on bindings.MojoCodecError catch(e) {
      e.message = "Error encountered while encoding field "
          "nodesToAdd of struct _LedgerUpdateSessionGraphParams: $e";
      rethrow;
    }
    try {
      if (edgesToAdd == null) {
        encoder0.encodeNullPointer(24, true);
      } else {
        var encoder1 = encoder0.encodePointerArray(edgesToAdd.length, 24, bindings.kUnspecifiedArrayLength);
        for (int i0 = 0; i0 < edgesToAdd.length; ++i0) {
          encoder1.encodeStruct(edgesToAdd[i0], bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize * i0, false);
        }
      }
    } on bindings.MojoCodecError catch(e) {
      e.message = "Error encountered while encoding field "
          "edgesToAdd of struct _LedgerUpdateSessionGraphParams: $e";
      rethrow;
    }
    try {
      if (valuesToUpdate == null) {
        encoder0.encodeNullPointer(32, true);
      } else {
        var encoder1 = encoder0.encodePointerArray(valuesToUpdate.length, 32, bindings.kUnspecifiedArrayLength);
        for (int i0 = 0; i0 < valuesToUpdate.length; ++i0) {
          encoder1.encodeStruct(valuesToUpdate[i0], bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize * i0, false);
        }
      }
    } on bindings.MojoCodecError catch(e) {
      e.message = "Error encountered while encoding field "
          "valuesToUpdate of struct _LedgerUpdateSessionGraphParams: $e";
      rethrow;
    }
    try {
      if (nodesToRemove == null) {
        encoder0.encodeNullPointer(40, true);
      } else {
        var encoder1 = encoder0.encodePointerArray(nodesToRemove.length, 40, bindings.kUnspecifiedArrayLength);
        for (int i0 = 0; i0 < nodesToRemove.length; ++i0) {
          encoder1.encodeStruct(nodesToRemove[i0], bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize * i0, false);
        }
      }
    } on bindings.MojoCodecError catch(e) {
      e.message = "Error encountered while encoding field "
          "nodesToRemove of struct _LedgerUpdateSessionGraphParams: $e";
      rethrow;
    }
    try {
      if (edgesToRemove == null) {
        encoder0.encodeNullPointer(48, true);
      } else {
        var encoder1 = encoder0.encodePointerArray(edgesToRemove.length, 48, bindings.kUnspecifiedArrayLength);
        for (int i0 = 0; i0 < edgesToRemove.length; ++i0) {
          encoder1.encodeStruct(edgesToRemove[i0], bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize * i0, false);
        }
      }
    } on bindings.MojoCodecError catch(e) {
      e.message = "Error encountered while encoding field "
          "edgesToRemove of struct _LedgerUpdateSessionGraphParams: $e";
      rethrow;
    }
  }

  String toString() {
    return "_LedgerUpdateSessionGraphParams("
           "sessionId: $sessionId" ", "
           "nodesToAdd: $nodesToAdd" ", "
           "edgesToAdd: $edgesToAdd" ", "
           "valuesToUpdate: $valuesToUpdate" ", "
           "nodesToRemove: $nodesToRemove" ", "
           "edgesToRemove: $edgesToRemove" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["sessionId"] = sessionId;
    map["nodesToAdd"] = nodesToAdd;
    map["edgesToAdd"] = edgesToAdd;
    map["valuesToUpdate"] = valuesToUpdate;
    map["nodesToRemove"] = nodesToRemove;
    map["edgesToRemove"] = edgesToRemove;
    return map;
  }
}


class LedgerUpdateSessionGraphResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  LedgerStatus status = null;

  LedgerUpdateSessionGraphResponseParams() : super(kVersions.last.size);

  LedgerUpdateSessionGraphResponseParams.init(
    LedgerStatus this.status
  ) : super(kVersions.last.size);

  static LedgerUpdateSessionGraphResponseParams deserialize(bindings.Message message) {
    var decoder = new bindings.Decoder(message);
    var result = decode(decoder);
    if (decoder.excessHandles != null) {
      decoder.excessHandles.forEach((h) => h.close());
    }
    return result;
  }

  static LedgerUpdateSessionGraphResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    LedgerUpdateSessionGraphResponseParams result = new LedgerUpdateSessionGraphResponseParams();

    var mainDataHeader = decoder0.decodeStructDataHeader();
    if (mainDataHeader.version <= kVersions.last.version) {
      // Scan in reverse order to optimize for more recent versions.
      for (int i = kVersions.length - 1; i >= 0; --i) {
        if (mainDataHeader.version >= kVersions[i].version) {
          if (mainDataHeader.size == kVersions[i].size) {
            // Found a match.
            break;
          }
          throw new bindings.MojoCodecError(
              'Header size doesn\'t correspond to known version size.');
        }
      }
    } else if (mainDataHeader.size < kVersions.last.size) {
      throw new bindings.MojoCodecError(
        'Message newer than the last known version cannot be shorter than '
        'required by the last known version.');
    }
    if (mainDataHeader.version >= 0) {
      
        result.status = LedgerStatus.decode(decoder0, 8);
        if (result.status == null) {
          throw new bindings.MojoCodecError(
            'Trying to decode null union for non-nullable LedgerStatus.');
        }
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    try {
      encoder0.encodeEnum(status, 8);
    } on bindings.MojoCodecError catch(e) {
      e.message = "Error encountered while encoding field "
          "status of struct LedgerUpdateSessionGraphResponseParams: $e";
      rethrow;
    }
  }

  String toString() {
    return "LedgerUpdateSessionGraphResponseParams("
           "status: $status" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["status"] = status;
    return map;
  }
}


class _LedgerObserverOnChangeParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  List<GraphUpdate> changes = null;

  _LedgerObserverOnChangeParams() : super(kVersions.last.size);

  _LedgerObserverOnChangeParams.init(
    List<GraphUpdate> this.changes
  ) : super(kVersions.last.size);

  static _LedgerObserverOnChangeParams deserialize(bindings.Message message) {
    var decoder = new bindings.Decoder(message);
    var result = decode(decoder);
    if (decoder.excessHandles != null) {
      decoder.excessHandles.forEach((h) => h.close());
    }
    return result;
  }

  static _LedgerObserverOnChangeParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _LedgerObserverOnChangeParams result = new _LedgerObserverOnChangeParams();

    var mainDataHeader = decoder0.decodeStructDataHeader();
    if (mainDataHeader.version <= kVersions.last.version) {
      // Scan in reverse order to optimize for more recent versions.
      for (int i = kVersions.length - 1; i >= 0; --i) {
        if (mainDataHeader.version >= kVersions[i].version) {
          if (mainDataHeader.size == kVersions[i].size) {
            // Found a match.
            break;
          }
          throw new bindings.MojoCodecError(
              'Header size doesn\'t correspond to known version size.');
        }
      }
    } else if (mainDataHeader.size < kVersions.last.size) {
      throw new bindings.MojoCodecError(
        'Message newer than the last known version cannot be shorter than '
        'required by the last known version.');
    }
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(8, false);
      {
        var si1 = decoder1.decodeDataHeaderForUnionArray(bindings.kUnspecifiedArrayLength);
        result.changes = new List<GraphUpdate>(si1.numElements);
        for (int i1 = 0; i1 < si1.numElements; ++i1) {
          
            result.changes[i1] = GraphUpdate.decode(decoder1, bindings.ArrayDataHeader.kHeaderSize + bindings.kUnionSize * i1);
            if (result.changes[i1] == null) {
              throw new bindings.MojoCodecError(
                'Trying to decode null union for non-nullable GraphUpdate.');
            }
        }
      }
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    try {
      if (changes == null) {
        encoder0.encodeNullPointer(8, false);
      } else {
        var encoder1 = encoder0.encodeUnionArray(changes.length, 8, bindings.kUnspecifiedArrayLength);
        for (int i0 = 0; i0 < changes.length; ++i0) {
          encoder1.encodeUnion(changes[i0], bindings.ArrayDataHeader.kHeaderSize + bindings.kUnionSize * i0, false);
        }
      }
    } on bindings.MojoCodecError catch(e) {
      e.message = "Error encountered while encoding field "
          "changes of struct _LedgerObserverOnChangeParams: $e";
      rethrow;
    }
  }

  String toString() {
    return "_LedgerObserverOnChangeParams("
           "changes: $changes" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["changes"] = changes;
    return map;
  }
}


class LedgerObserverOnChangeResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(8, 0)
  ];

  LedgerObserverOnChangeResponseParams() : super(kVersions.last.size);

  LedgerObserverOnChangeResponseParams.init(
  ) : super(kVersions.last.size);

  static LedgerObserverOnChangeResponseParams deserialize(bindings.Message message) {
    var decoder = new bindings.Decoder(message);
    var result = decode(decoder);
    if (decoder.excessHandles != null) {
      decoder.excessHandles.forEach((h) => h.close());
    }
    return result;
  }

  static LedgerObserverOnChangeResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    LedgerObserverOnChangeResponseParams result = new LedgerObserverOnChangeResponseParams();

    var mainDataHeader = decoder0.decodeStructDataHeader();
    if (mainDataHeader.version <= kVersions.last.version) {
      // Scan in reverse order to optimize for more recent versions.
      for (int i = kVersions.length - 1; i >= 0; --i) {
        if (mainDataHeader.version >= kVersions[i].version) {
          if (mainDataHeader.size == kVersions[i].size) {
            // Found a match.
            break;
          }
          throw new bindings.MojoCodecError(
              'Header size doesn\'t correspond to known version size.');
        }
      }
    } else if (mainDataHeader.size < kVersions.last.size) {
      throw new bindings.MojoCodecError(
        'Message newer than the last known version cannot be shorter than '
        'required by the last known version.');
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    encoder.getStructEncoderAtOffset(kVersions.last);
  }

  String toString() {
    return "LedgerObserverOnChangeResponseParams("")";
  }

  Map toJson() {
    Map map = new Map();
    return map;
  }
}



enum GraphUpdateTag {
  nodeAdded,
  nodeRemoved,
  edgeAdded,
  edgeRemoved,
  valueUpdated,
  unknown
}

class GraphUpdate extends bindings.Union {
  static final _tagToInt = const {
    GraphUpdateTag.nodeAdded: 0,
    GraphUpdateTag.nodeRemoved: 1,
    GraphUpdateTag.edgeAdded: 2,
    GraphUpdateTag.edgeRemoved: 3,
    GraphUpdateTag.valueUpdated: 4,
  };

  static final _intToTag = const {
    0: GraphUpdateTag.nodeAdded,
    1: GraphUpdateTag.nodeRemoved,
    2: GraphUpdateTag.edgeAdded,
    3: GraphUpdateTag.edgeRemoved,
    4: GraphUpdateTag.valueUpdated,
  };

  var _data;
  GraphUpdateTag _tag = GraphUpdateTag.unknown;

  GraphUpdateTag get tag => _tag;
  NodeRecord get nodeAdded {
    if (_tag != GraphUpdateTag.nodeAdded) {
      throw new bindings.UnsetUnionTagError(_tag, GraphUpdateTag.nodeAdded);
    }
    return _data;
  }

  set nodeAdded(NodeRecord value) {
    _tag = GraphUpdateTag.nodeAdded;
    _data = value;
  }
  NodeId get nodeRemoved {
    if (_tag != GraphUpdateTag.nodeRemoved) {
      throw new bindings.UnsetUnionTagError(_tag, GraphUpdateTag.nodeRemoved);
    }
    return _data;
  }

  set nodeRemoved(NodeId value) {
    _tag = GraphUpdateTag.nodeRemoved;
    _data = value;
  }
  EdgeRecord get edgeAdded {
    if (_tag != GraphUpdateTag.edgeAdded) {
      throw new bindings.UnsetUnionTagError(_tag, GraphUpdateTag.edgeAdded);
    }
    return _data;
  }

  set edgeAdded(EdgeRecord value) {
    _tag = GraphUpdateTag.edgeAdded;
    _data = value;
  }
  EdgeId get edgeRemoved {
    if (_tag != GraphUpdateTag.edgeRemoved) {
      throw new bindings.UnsetUnionTagError(_tag, GraphUpdateTag.edgeRemoved);
    }
    return _data;
  }

  set edgeRemoved(EdgeId value) {
    _tag = GraphUpdateTag.edgeRemoved;
    _data = value;
  }
  Representation get valueUpdated {
    if (_tag != GraphUpdateTag.valueUpdated) {
      throw new bindings.UnsetUnionTagError(_tag, GraphUpdateTag.valueUpdated);
    }
    return _data;
  }

  set valueUpdated(Representation value) {
    _tag = GraphUpdateTag.valueUpdated;
    _data = value;
  }

  static GraphUpdate decode(bindings.Decoder decoder0, int offset) {
    int size = decoder0.decodeUint32(offset);
    if (size == 0) {
      return null;
    }
    GraphUpdate result = new GraphUpdate();

    
    GraphUpdateTag tag = _intToTag[decoder0.decodeUint32(offset + 4)];
    switch (tag) {
      case GraphUpdateTag.nodeAdded:
        
        var decoder1 = decoder0.decodePointer(offset + 8, false);
        result.nodeAdded = NodeRecord.decode(decoder1);
        break;
      case GraphUpdateTag.nodeRemoved:
        
        var decoder1 = decoder0.decodePointer(offset + 8, false);
        result.nodeRemoved = NodeId.decode(decoder1);
        break;
      case GraphUpdateTag.edgeAdded:
        
        var decoder1 = decoder0.decodePointer(offset + 8, false);
        result.edgeAdded = EdgeRecord.decode(decoder1);
        break;
      case GraphUpdateTag.edgeRemoved:
        
        var decoder1 = decoder0.decodePointer(offset + 8, false);
        result.edgeRemoved = EdgeId.decode(decoder1);
        break;
      case GraphUpdateTag.valueUpdated:
        
        var decoder1 = decoder0.decodePointer(offset + 8, false);
        result.valueUpdated = Representation.decode(decoder1);
        break;
      default:
        throw new bindings.MojoCodecError("Bad union tag: $tag");
    }

    return result;
  }

  void encode(bindings.Encoder encoder0, int offset) {
    
    encoder0.encodeUint32(16, offset);
    encoder0.encodeUint32(_tagToInt[_tag], offset + 4);
    switch (_tag) {
      case GraphUpdateTag.nodeAdded:
        encoder0.encodeStruct(nodeAdded, offset + 8, false);
        break;
      case GraphUpdateTag.nodeRemoved:
        encoder0.encodeStruct(nodeRemoved, offset + 8, false);
        break;
      case GraphUpdateTag.edgeAdded:
        encoder0.encodeStruct(edgeAdded, offset + 8, false);
        break;
      case GraphUpdateTag.edgeRemoved:
        encoder0.encodeStruct(edgeRemoved, offset + 8, false);
        break;
      case GraphUpdateTag.valueUpdated:
        encoder0.encodeStruct(valueUpdated, offset + 8, false);
        break;
      default:
        throw new bindings.MojoCodecError("Bad union tag: $_tag");
    }
  }

  String toString() {
    String result = "GraphUpdate(";
    switch (_tag) {
      case GraphUpdateTag.nodeAdded:
        result += "nodeAdded";
        break;
      case GraphUpdateTag.nodeRemoved:
        result += "nodeRemoved";
        break;
      case GraphUpdateTag.edgeAdded:
        result += "edgeAdded";
        break;
      case GraphUpdateTag.edgeRemoved:
        result += "edgeRemoved";
        break;
      case GraphUpdateTag.valueUpdated:
        result += "valueUpdated";
        break;
      default:
        result += "unknown";
    }
    result += ": $_data)";
    return result;
  }
}


enum LabelExpressionTag {
  semantic,
  representation,
  unknown
}

class LabelExpression extends bindings.Union {
  static final _tagToInt = const {
    LabelExpressionTag.semantic: 0,
    LabelExpressionTag.representation: 1,
  };

  static final _intToTag = const {
    0: LabelExpressionTag.semantic,
    1: LabelExpressionTag.representation,
  };

  var _data;
  LabelExpressionTag _tag = LabelExpressionTag.unknown;

  LabelExpressionTag get tag => _tag;
  SemanticExpression get semantic {
    if (_tag != LabelExpressionTag.semantic) {
      throw new bindings.UnsetUnionTagError(_tag, LabelExpressionTag.semantic);
    }
    return _data;
  }

  set semantic(SemanticExpression value) {
    _tag = LabelExpressionTag.semantic;
    _data = value;
  }
  RepresentationExpression get representation {
    if (_tag != LabelExpressionTag.representation) {
      throw new bindings.UnsetUnionTagError(_tag, LabelExpressionTag.representation);
    }
    return _data;
  }

  set representation(RepresentationExpression value) {
    _tag = LabelExpressionTag.representation;
    _data = value;
  }

  static LabelExpression decode(bindings.Decoder decoder0, int offset) {
    int size = decoder0.decodeUint32(offset);
    if (size == 0) {
      return null;
    }
    LabelExpression result = new LabelExpression();

    
    LabelExpressionTag tag = _intToTag[decoder0.decodeUint32(offset + 4)];
    switch (tag) {
      case LabelExpressionTag.semantic:
        
        var decoder1 = decoder0.decodePointer(offset + 8, false);
        result.semantic = SemanticExpression.decode(decoder1);
        break;
      case LabelExpressionTag.representation:
        
        var decoder1 = decoder0.decodePointer(offset + 8, false);
        result.representation = RepresentationExpression.decode(decoder1);
        break;
      default:
        throw new bindings.MojoCodecError("Bad union tag: $tag");
    }

    return result;
  }

  void encode(bindings.Encoder encoder0, int offset) {
    
    encoder0.encodeUint32(16, offset);
    encoder0.encodeUint32(_tagToInt[_tag], offset + 4);
    switch (_tag) {
      case LabelExpressionTag.semantic:
        encoder0.encodeStruct(semantic, offset + 8, false);
        break;
      case LabelExpressionTag.representation:
        encoder0.encodeStruct(representation, offset + 8, false);
        break;
      default:
        throw new bindings.MojoCodecError("Bad union tag: $_tag");
    }
  }

  String toString() {
    String result = "LabelExpression(";
    switch (_tag) {
      case LabelExpressionTag.semantic:
        result += "semantic";
        break;
      case LabelExpressionTag.representation:
        result += "representation";
        break;
      default:
        result += "unknown";
    }
    result += ": $_data)";
    return result;
  }
}
const int _ledgerMethodAuthenticateName = 0;
const int _ledgerMethodCreateSessionName = 1;
const int _ledgerMethodGetSessionGraphName = 2;
const int _ledgerMethodAddObserverName = 3;
const int _ledgerMethodUpdateSessionGraphName = 4;
  
class LedgerStatus extends bindings.MojoEnum {
  static const LedgerStatus ok = const LedgerStatus._(0);
  static const LedgerStatus notFound = const LedgerStatus._(1);
  static const LedgerStatus notAuthorized = const LedgerStatus._(2);
  static const LedgerStatus illegalArgument = const LedgerStatus._(3);
  static const LedgerStatus internalError = const LedgerStatus._(4);

  const LedgerStatus._(int v) : super(v);

  static const Map<String, LedgerStatus> valuesMap = const {
    "ok": ok,
    "notFound": notFound,
    "notAuthorized": notAuthorized,
    "illegalArgument": illegalArgument,
    "internalError": internalError,
  };
  static const List<LedgerStatus> values = const [
    ok,
    notFound,
    notAuthorized,
    illegalArgument,
    internalError,
  ];

  static LedgerStatus valueOf(String name) => valuesMap[name];

  factory LedgerStatus(int v) {
    switch (v) {
      case 0:
        return LedgerStatus.ok;
      case 1:
        return LedgerStatus.notFound;
      case 2:
        return LedgerStatus.notAuthorized;
      case 3:
        return LedgerStatus.illegalArgument;
      case 4:
        return LedgerStatus.internalError;
      default:
        return null;
    }
  }

  static LedgerStatus decode(bindings.Decoder decoder0, int offset) {
    int v = decoder0.decodeUint32(offset);
    LedgerStatus result = new LedgerStatus(v);
    if (result == null) {
      throw new bindings.MojoCodecError(
          'Bad value $v for enum LedgerStatus.');
    }
    return result;
  }

  String toString() {
    switch(this) {
      case ok:
        return 'LedgerStatus.ok';
      case notFound:
        return 'LedgerStatus.notFound';
      case notAuthorized:
        return 'LedgerStatus.notAuthorized';
      case illegalArgument:
        return 'LedgerStatus.illegalArgument';
      case internalError:
        return 'LedgerStatus.internalError';
      default:
        return null;
    }
  }

  int toJson() => mojoEnumValue;
}

class _LedgerServiceDescription implements service_describer.ServiceDescription {
  void getTopLevelInterface(Function responder) {
    responder(null);
  }

  void getTypeDefinition(String typeKey, Function responder) {
    responder(null);
  }

  void getAllTypeDefinitions(Function responder) {
    responder(null);
  }
}

abstract class Ledger {
  static const String serviceName = "ledger::Ledger";

  static service_describer.ServiceDescription _cachedServiceDescription;
  static service_describer.ServiceDescription get serviceDescription {
    if (_cachedServiceDescription == null) {
      _cachedServiceDescription = new _LedgerServiceDescription();
    }
    return _cachedServiceDescription;
  }

  static LedgerProxy connectToService(
      bindings.ServiceConnector s, String url, [String serviceName]) {
    LedgerProxy p = new LedgerProxy.unbound();
    String name = serviceName ?? Ledger.serviceName;
    if ((name == null) || name.isEmpty) {
      throw new core.MojoApiError(
          "If an interface has no ServiceName, then one must be provided.");
    }
    s.connectToService(url, p, name);
    return p;
  }
  void authenticate(String username,void callback(UserId userId, LedgerStatus status));
  void createSession(void callback(SessionId sessionId, LedgerStatus status));
  void getSessionGraph(SessionId sessionId,LedgerOptions options,void callback(SessionGraph sessionGraph, LedgerStatus status));
  void addObserver(SessionId sessionId,PathExpression query,LedgerObserverInterface observer,void callback(LedgerStatus status));
  void updateSessionGraph(SessionId sessionId,List<NodeRecord> nodesToAdd,List<EdgeRecord> edgesToAdd,List<Representation> valuesToUpdate,List<NodeId> nodesToRemove,List<EdgeId> edgesToRemove,void callback(LedgerStatus status));
}

abstract class LedgerInterface
    implements bindings.MojoInterface<Ledger>,
               Ledger {
  factory LedgerInterface([Ledger impl]) =>
      new LedgerStub.unbound(impl);

  factory LedgerInterface.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint,
      [Ledger impl]) =>
      new LedgerStub.fromEndpoint(endpoint, impl);

  factory LedgerInterface.fromMock(
      Ledger mock) =>
      new LedgerProxy.fromMock(mock);
}

abstract class LedgerInterfaceRequest
    implements bindings.MojoInterface<Ledger>,
               Ledger {
  factory LedgerInterfaceRequest() =>
      new LedgerProxy.unbound();
}

class _LedgerProxyControl
    extends bindings.ProxyMessageHandler
    implements bindings.ProxyControl<Ledger> {
  Ledger impl;

  _LedgerProxyControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) : super.fromEndpoint(endpoint);

  _LedgerProxyControl.fromHandle(
      core.MojoHandle handle) : super.fromHandle(handle);

  _LedgerProxyControl.unbound() : super.unbound();

  String get serviceName => Ledger.serviceName;

  void handleResponse(bindings.ServiceMessage message) {
    switch (message.header.type) {
      case _ledgerMethodAuthenticateName:
        var r = LedgerAuthenticateResponseParams.deserialize(
            message.payload);
        if (!message.header.hasRequestId) {
          proxyError("Expected a message with a valid request Id.");
          return;
        }
        Function callback = callbackMap[message.header.requestId];
        if (callback == null) {
          proxyError(
              "Message had unknown request Id: ${message.header.requestId}");
          return;
        }
        callbackMap.remove(message.header.requestId);
        callback(r.userId , r.status );
        break;
      case _ledgerMethodCreateSessionName:
        var r = LedgerCreateSessionResponseParams.deserialize(
            message.payload);
        if (!message.header.hasRequestId) {
          proxyError("Expected a message with a valid request Id.");
          return;
        }
        Function callback = callbackMap[message.header.requestId];
        if (callback == null) {
          proxyError(
              "Message had unknown request Id: ${message.header.requestId}");
          return;
        }
        callbackMap.remove(message.header.requestId);
        callback(r.sessionId , r.status );
        break;
      case _ledgerMethodGetSessionGraphName:
        var r = LedgerGetSessionGraphResponseParams.deserialize(
            message.payload);
        if (!message.header.hasRequestId) {
          proxyError("Expected a message with a valid request Id.");
          return;
        }
        Function callback = callbackMap[message.header.requestId];
        if (callback == null) {
          proxyError(
              "Message had unknown request Id: ${message.header.requestId}");
          return;
        }
        callbackMap.remove(message.header.requestId);
        callback(r.sessionGraph , r.status );
        break;
      case _ledgerMethodAddObserverName:
        var r = LedgerAddObserverResponseParams.deserialize(
            message.payload);
        if (!message.header.hasRequestId) {
          proxyError("Expected a message with a valid request Id.");
          return;
        }
        Function callback = callbackMap[message.header.requestId];
        if (callback == null) {
          proxyError(
              "Message had unknown request Id: ${message.header.requestId}");
          return;
        }
        callbackMap.remove(message.header.requestId);
        callback(r.status );
        break;
      case _ledgerMethodUpdateSessionGraphName:
        var r = LedgerUpdateSessionGraphResponseParams.deserialize(
            message.payload);
        if (!message.header.hasRequestId) {
          proxyError("Expected a message with a valid request Id.");
          return;
        }
        Function callback = callbackMap[message.header.requestId];
        if (callback == null) {
          proxyError(
              "Message had unknown request Id: ${message.header.requestId}");
          return;
        }
        callbackMap.remove(message.header.requestId);
        callback(r.status );
        break;
      default:
        proxyError("Unexpected message type: ${message.header.type}");
        close(immediate: true);
        break;
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_LedgerProxyControl($superString)";
  }
}

class LedgerProxy
    extends bindings.Proxy<Ledger>
    implements Ledger,
               LedgerInterface,
               LedgerInterfaceRequest {
  LedgerProxy.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint)
      : super(new _LedgerProxyControl.fromEndpoint(endpoint));

  LedgerProxy.fromHandle(core.MojoHandle handle)
      : super(new _LedgerProxyControl.fromHandle(handle));

  LedgerProxy.unbound()
      : super(new _LedgerProxyControl.unbound());

  factory LedgerProxy.fromMock(Ledger mock) {
    LedgerProxy newMockedProxy =
        new LedgerProxy.unbound();
    newMockedProxy.impl = mock;
    return newMockedProxy;
  }

  static LedgerProxy newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For LedgerProxy"));
    return new LedgerProxy.fromEndpoint(endpoint);
  }


  void authenticate(String username,void callback(UserId userId, LedgerStatus status)) {
    if (impl != null) {
      impl.authenticate(username,callback);
      return;
    }
    var params = new _LedgerAuthenticateParams();
    params.username = username;
    Function zonedCallback;
    if (identical(Zone.current, Zone.ROOT)) {
      zonedCallback = callback;
    } else {
      Zone z = Zone.current;
      zonedCallback = ((UserId userId, LedgerStatus status) {
        z.bindCallback(() {
          callback(userId, status);
        })();
      });
    }
    ctrl.sendMessageWithRequestId(
        params,
        _ledgerMethodAuthenticateName,
        -1,
        bindings.MessageHeader.kMessageExpectsResponse,
        zonedCallback);
  }
  void createSession(void callback(SessionId sessionId, LedgerStatus status)) {
    if (impl != null) {
      impl.createSession(callback);
      return;
    }
    var params = new _LedgerCreateSessionParams();
    Function zonedCallback;
    if (identical(Zone.current, Zone.ROOT)) {
      zonedCallback = callback;
    } else {
      Zone z = Zone.current;
      zonedCallback = ((SessionId sessionId, LedgerStatus status) {
        z.bindCallback(() {
          callback(sessionId, status);
        })();
      });
    }
    ctrl.sendMessageWithRequestId(
        params,
        _ledgerMethodCreateSessionName,
        -1,
        bindings.MessageHeader.kMessageExpectsResponse,
        zonedCallback);
  }
  void getSessionGraph(SessionId sessionId,LedgerOptions options,void callback(SessionGraph sessionGraph, LedgerStatus status)) {
    if (impl != null) {
      impl.getSessionGraph(sessionId,options,callback);
      return;
    }
    var params = new _LedgerGetSessionGraphParams();
    params.sessionId = sessionId;
    params.options = options;
    Function zonedCallback;
    if (identical(Zone.current, Zone.ROOT)) {
      zonedCallback = callback;
    } else {
      Zone z = Zone.current;
      zonedCallback = ((SessionGraph sessionGraph, LedgerStatus status) {
        z.bindCallback(() {
          callback(sessionGraph, status);
        })();
      });
    }
    ctrl.sendMessageWithRequestId(
        params,
        _ledgerMethodGetSessionGraphName,
        -1,
        bindings.MessageHeader.kMessageExpectsResponse,
        zonedCallback);
  }
  void addObserver(SessionId sessionId,PathExpression query,LedgerObserverInterface observer,void callback(LedgerStatus status)) {
    if (impl != null) {
      impl.addObserver(sessionId,query,observer,callback);
      return;
    }
    var params = new _LedgerAddObserverParams();
    params.sessionId = sessionId;
    params.query = query;
    params.observer = observer;
    Function zonedCallback;
    if (identical(Zone.current, Zone.ROOT)) {
      zonedCallback = callback;
    } else {
      Zone z = Zone.current;
      zonedCallback = ((LedgerStatus status) {
        z.bindCallback(() {
          callback(status);
        })();
      });
    }
    ctrl.sendMessageWithRequestId(
        params,
        _ledgerMethodAddObserverName,
        -1,
        bindings.MessageHeader.kMessageExpectsResponse,
        zonedCallback);
  }
  void updateSessionGraph(SessionId sessionId,List<NodeRecord> nodesToAdd,List<EdgeRecord> edgesToAdd,List<Representation> valuesToUpdate,List<NodeId> nodesToRemove,List<EdgeId> edgesToRemove,void callback(LedgerStatus status)) {
    if (impl != null) {
      impl.updateSessionGraph(sessionId,nodesToAdd,edgesToAdd,valuesToUpdate,nodesToRemove,edgesToRemove,callback);
      return;
    }
    var params = new _LedgerUpdateSessionGraphParams();
    params.sessionId = sessionId;
    params.nodesToAdd = nodesToAdd;
    params.edgesToAdd = edgesToAdd;
    params.valuesToUpdate = valuesToUpdate;
    params.nodesToRemove = nodesToRemove;
    params.edgesToRemove = edgesToRemove;
    Function zonedCallback;
    if (identical(Zone.current, Zone.ROOT)) {
      zonedCallback = callback;
    } else {
      Zone z = Zone.current;
      zonedCallback = ((LedgerStatus status) {
        z.bindCallback(() {
          callback(status);
        })();
      });
    }
    ctrl.sendMessageWithRequestId(
        params,
        _ledgerMethodUpdateSessionGraphName,
        -1,
        bindings.MessageHeader.kMessageExpectsResponse,
        zonedCallback);
  }
}

class _LedgerStubControl
    extends bindings.StubMessageHandler
    implements bindings.StubControl<Ledger> {
  Ledger _impl;

  _LedgerStubControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [Ledger impl])
      : super.fromEndpoint(endpoint, autoBegin: impl != null) {
    _impl = impl;
  }

  _LedgerStubControl.fromHandle(
      core.MojoHandle handle, [Ledger impl])
      : super.fromHandle(handle, autoBegin: impl != null) {
    _impl = impl;
  }

  _LedgerStubControl.unbound([this._impl]) : super.unbound();

  String get serviceName => Ledger.serviceName;


  Function _ledgerAuthenticateResponseParamsResponder(
      int requestId) {
  return (UserId userId, LedgerStatus status) {
      var result = new LedgerAuthenticateResponseParams();
      result.userId = userId;
      result.status = status;
      sendResponse(buildResponseWithId(
          result,
          _ledgerMethodAuthenticateName,
          requestId,
          bindings.MessageHeader.kMessageIsResponse));
    };
  }
  Function _ledgerCreateSessionResponseParamsResponder(
      int requestId) {
  return (SessionId sessionId, LedgerStatus status) {
      var result = new LedgerCreateSessionResponseParams();
      result.sessionId = sessionId;
      result.status = status;
      sendResponse(buildResponseWithId(
          result,
          _ledgerMethodCreateSessionName,
          requestId,
          bindings.MessageHeader.kMessageIsResponse));
    };
  }
  Function _ledgerGetSessionGraphResponseParamsResponder(
      int requestId) {
  return (SessionGraph sessionGraph, LedgerStatus status) {
      var result = new LedgerGetSessionGraphResponseParams();
      result.sessionGraph = sessionGraph;
      result.status = status;
      sendResponse(buildResponseWithId(
          result,
          _ledgerMethodGetSessionGraphName,
          requestId,
          bindings.MessageHeader.kMessageIsResponse));
    };
  }
  Function _ledgerAddObserverResponseParamsResponder(
      int requestId) {
  return (LedgerStatus status) {
      var result = new LedgerAddObserverResponseParams();
      result.status = status;
      sendResponse(buildResponseWithId(
          result,
          _ledgerMethodAddObserverName,
          requestId,
          bindings.MessageHeader.kMessageIsResponse));
    };
  }
  Function _ledgerUpdateSessionGraphResponseParamsResponder(
      int requestId) {
  return (LedgerStatus status) {
      var result = new LedgerUpdateSessionGraphResponseParams();
      result.status = status;
      sendResponse(buildResponseWithId(
          result,
          _ledgerMethodUpdateSessionGraphName,
          requestId,
          bindings.MessageHeader.kMessageIsResponse));
    };
  }

  void handleMessage(bindings.ServiceMessage message) {
    if (bindings.ControlMessageHandler.isControlMessage(message)) {
      bindings.ControlMessageHandler.handleMessage(
          this, 0, message);
      return;
    }
    if (_impl == null) {
      throw new core.MojoApiError("$this has no implementation set");
    }
    switch (message.header.type) {
      case _ledgerMethodAuthenticateName:
        var params = _LedgerAuthenticateParams.deserialize(
            message.payload);
        _impl.authenticate(params.username, _ledgerAuthenticateResponseParamsResponder(message.header.requestId));
        break;
      case _ledgerMethodCreateSessionName:
        _impl.createSession(_ledgerCreateSessionResponseParamsResponder(message.header.requestId));
        break;
      case _ledgerMethodGetSessionGraphName:
        var params = _LedgerGetSessionGraphParams.deserialize(
            message.payload);
        _impl.getSessionGraph(params.sessionId, params.options, _ledgerGetSessionGraphResponseParamsResponder(message.header.requestId));
        break;
      case _ledgerMethodAddObserverName:
        var params = _LedgerAddObserverParams.deserialize(
            message.payload);
        _impl.addObserver(params.sessionId, params.query, params.observer, _ledgerAddObserverResponseParamsResponder(message.header.requestId));
        break;
      case _ledgerMethodUpdateSessionGraphName:
        var params = _LedgerUpdateSessionGraphParams.deserialize(
            message.payload);
        _impl.updateSessionGraph(params.sessionId, params.nodesToAdd, params.edgesToAdd, params.valuesToUpdate, params.nodesToRemove, params.edgesToRemove, _ledgerUpdateSessionGraphResponseParamsResponder(message.header.requestId));
        break;
      default:
        throw new bindings.MojoCodecError("Unexpected message name");
        break;
    }
  }

  Ledger get impl => _impl;
  set impl(Ledger d) {
    if (d == null) {
      throw new core.MojoApiError("$this: Cannot set a null implementation");
    }
    if (isBound && (_impl == null)) {
      beginHandlingEvents();
    }
    _impl = d;
  }

  @override
  void bind(core.MojoMessagePipeEndpoint endpoint) {
    super.bind(endpoint);
    if (!isOpen && (_impl != null)) {
      beginHandlingEvents();
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_LedgerStubControl($superString)";
  }

  int get version => 0;
}

class LedgerStub
    extends bindings.Stub<Ledger>
    implements Ledger,
               LedgerInterface,
               LedgerInterfaceRequest {
  LedgerStub.unbound([Ledger impl])
      : super(new _LedgerStubControl.unbound(impl));

  LedgerStub.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [Ledger impl])
      : super(new _LedgerStubControl.fromEndpoint(endpoint, impl));

  LedgerStub.fromHandle(
      core.MojoHandle handle, [Ledger impl])
      : super(new _LedgerStubControl.fromHandle(handle, impl));

  static LedgerStub newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For LedgerStub"));
    return new LedgerStub.fromEndpoint(endpoint);
  }


  void authenticate(String username,void callback(UserId userId, LedgerStatus status)) {
    return impl.authenticate(username,callback);
  }
  void createSession(void callback(SessionId sessionId, LedgerStatus status)) {
    return impl.createSession(callback);
  }
  void getSessionGraph(SessionId sessionId,LedgerOptions options,void callback(SessionGraph sessionGraph, LedgerStatus status)) {
    return impl.getSessionGraph(sessionId,options,callback);
  }
  void addObserver(SessionId sessionId,PathExpression query,LedgerObserverInterface observer,void callback(LedgerStatus status)) {
    return impl.addObserver(sessionId,query,observer,callback);
  }
  void updateSessionGraph(SessionId sessionId,List<NodeRecord> nodesToAdd,List<EdgeRecord> edgesToAdd,List<Representation> valuesToUpdate,List<NodeId> nodesToRemove,List<EdgeId> edgesToRemove,void callback(LedgerStatus status)) {
    return impl.updateSessionGraph(sessionId,nodesToAdd,edgesToAdd,valuesToUpdate,nodesToRemove,edgesToRemove,callback);
  }
}

const int _ledgerObserverMethodOnChangeName = 0;

class _LedgerObserverServiceDescription implements service_describer.ServiceDescription {
  void getTopLevelInterface(Function responder) {
    responder(null);
  }

  void getTypeDefinition(String typeKey, Function responder) {
    responder(null);
  }

  void getAllTypeDefinitions(Function responder) {
    responder(null);
  }
}

abstract class LedgerObserver {
  static const String serviceName = null;

  static service_describer.ServiceDescription _cachedServiceDescription;
  static service_describer.ServiceDescription get serviceDescription {
    if (_cachedServiceDescription == null) {
      _cachedServiceDescription = new _LedgerObserverServiceDescription();
    }
    return _cachedServiceDescription;
  }

  static LedgerObserverProxy connectToService(
      bindings.ServiceConnector s, String url, [String serviceName]) {
    LedgerObserverProxy p = new LedgerObserverProxy.unbound();
    String name = serviceName ?? LedgerObserver.serviceName;
    if ((name == null) || name.isEmpty) {
      throw new core.MojoApiError(
          "If an interface has no ServiceName, then one must be provided.");
    }
    s.connectToService(url, p, name);
    return p;
  }
  void onChange(List<GraphUpdate> changes,void callback());
}

abstract class LedgerObserverInterface
    implements bindings.MojoInterface<LedgerObserver>,
               LedgerObserver {
  factory LedgerObserverInterface([LedgerObserver impl]) =>
      new LedgerObserverStub.unbound(impl);

  factory LedgerObserverInterface.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint,
      [LedgerObserver impl]) =>
      new LedgerObserverStub.fromEndpoint(endpoint, impl);

  factory LedgerObserverInterface.fromMock(
      LedgerObserver mock) =>
      new LedgerObserverProxy.fromMock(mock);
}

abstract class LedgerObserverInterfaceRequest
    implements bindings.MojoInterface<LedgerObserver>,
               LedgerObserver {
  factory LedgerObserverInterfaceRequest() =>
      new LedgerObserverProxy.unbound();
}

class _LedgerObserverProxyControl
    extends bindings.ProxyMessageHandler
    implements bindings.ProxyControl<LedgerObserver> {
  LedgerObserver impl;

  _LedgerObserverProxyControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) : super.fromEndpoint(endpoint);

  _LedgerObserverProxyControl.fromHandle(
      core.MojoHandle handle) : super.fromHandle(handle);

  _LedgerObserverProxyControl.unbound() : super.unbound();

  String get serviceName => LedgerObserver.serviceName;

  void handleResponse(bindings.ServiceMessage message) {
    switch (message.header.type) {
      case _ledgerObserverMethodOnChangeName:
        var r = LedgerObserverOnChangeResponseParams.deserialize(
            message.payload);
        if (!message.header.hasRequestId) {
          proxyError("Expected a message with a valid request Id.");
          return;
        }
        Function callback = callbackMap[message.header.requestId];
        if (callback == null) {
          proxyError(
              "Message had unknown request Id: ${message.header.requestId}");
          return;
        }
        callbackMap.remove(message.header.requestId);
        callback();
        break;
      default:
        proxyError("Unexpected message type: ${message.header.type}");
        close(immediate: true);
        break;
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_LedgerObserverProxyControl($superString)";
  }
}

class LedgerObserverProxy
    extends bindings.Proxy<LedgerObserver>
    implements LedgerObserver,
               LedgerObserverInterface,
               LedgerObserverInterfaceRequest {
  LedgerObserverProxy.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint)
      : super(new _LedgerObserverProxyControl.fromEndpoint(endpoint));

  LedgerObserverProxy.fromHandle(core.MojoHandle handle)
      : super(new _LedgerObserverProxyControl.fromHandle(handle));

  LedgerObserverProxy.unbound()
      : super(new _LedgerObserverProxyControl.unbound());

  factory LedgerObserverProxy.fromMock(LedgerObserver mock) {
    LedgerObserverProxy newMockedProxy =
        new LedgerObserverProxy.unbound();
    newMockedProxy.impl = mock;
    return newMockedProxy;
  }

  static LedgerObserverProxy newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For LedgerObserverProxy"));
    return new LedgerObserverProxy.fromEndpoint(endpoint);
  }


  void onChange(List<GraphUpdate> changes,void callback()) {
    if (impl != null) {
      impl.onChange(changes,callback);
      return;
    }
    var params = new _LedgerObserverOnChangeParams();
    params.changes = changes;
    Function zonedCallback;
    if (identical(Zone.current, Zone.ROOT)) {
      zonedCallback = callback;
    } else {
      Zone z = Zone.current;
      zonedCallback = (() {
        z.bindCallback(() {
          callback();
        })();
      });
    }
    ctrl.sendMessageWithRequestId(
        params,
        _ledgerObserverMethodOnChangeName,
        -1,
        bindings.MessageHeader.kMessageExpectsResponse,
        zonedCallback);
  }
}

class _LedgerObserverStubControl
    extends bindings.StubMessageHandler
    implements bindings.StubControl<LedgerObserver> {
  LedgerObserver _impl;

  _LedgerObserverStubControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [LedgerObserver impl])
      : super.fromEndpoint(endpoint, autoBegin: impl != null) {
    _impl = impl;
  }

  _LedgerObserverStubControl.fromHandle(
      core.MojoHandle handle, [LedgerObserver impl])
      : super.fromHandle(handle, autoBegin: impl != null) {
    _impl = impl;
  }

  _LedgerObserverStubControl.unbound([this._impl]) : super.unbound();

  String get serviceName => LedgerObserver.serviceName;


  Function _ledgerObserverOnChangeResponseParamsResponder(
      int requestId) {
  return () {
      var result = new LedgerObserverOnChangeResponseParams();
      sendResponse(buildResponseWithId(
          result,
          _ledgerObserverMethodOnChangeName,
          requestId,
          bindings.MessageHeader.kMessageIsResponse));
    };
  }

  void handleMessage(bindings.ServiceMessage message) {
    if (bindings.ControlMessageHandler.isControlMessage(message)) {
      bindings.ControlMessageHandler.handleMessage(
          this, 0, message);
      return;
    }
    if (_impl == null) {
      throw new core.MojoApiError("$this has no implementation set");
    }
    switch (message.header.type) {
      case _ledgerObserverMethodOnChangeName:
        var params = _LedgerObserverOnChangeParams.deserialize(
            message.payload);
        _impl.onChange(params.changes, _ledgerObserverOnChangeResponseParamsResponder(message.header.requestId));
        break;
      default:
        throw new bindings.MojoCodecError("Unexpected message name");
        break;
    }
  }

  LedgerObserver get impl => _impl;
  set impl(LedgerObserver d) {
    if (d == null) {
      throw new core.MojoApiError("$this: Cannot set a null implementation");
    }
    if (isBound && (_impl == null)) {
      beginHandlingEvents();
    }
    _impl = d;
  }

  @override
  void bind(core.MojoMessagePipeEndpoint endpoint) {
    super.bind(endpoint);
    if (!isOpen && (_impl != null)) {
      beginHandlingEvents();
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_LedgerObserverStubControl($superString)";
  }

  int get version => 0;
}

class LedgerObserverStub
    extends bindings.Stub<LedgerObserver>
    implements LedgerObserver,
               LedgerObserverInterface,
               LedgerObserverInterfaceRequest {
  LedgerObserverStub.unbound([LedgerObserver impl])
      : super(new _LedgerObserverStubControl.unbound(impl));

  LedgerObserverStub.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [LedgerObserver impl])
      : super(new _LedgerObserverStubControl.fromEndpoint(endpoint, impl));

  LedgerObserverStub.fromHandle(
      core.MojoHandle handle, [LedgerObserver impl])
      : super(new _LedgerObserverStubControl.fromHandle(handle, impl));

  static LedgerObserverStub newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For LedgerObserverStub"));
    return new LedgerObserverStub.fromEndpoint(endpoint);
  }


  void onChange(List<GraphUpdate> changes,void callback()) {
    return impl.onChange(changes,callback);
  }
}



