// Copyright 2016 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// WARNING: DO NOT EDIT. This file was generated by a program.
// See $MOJO_SDK/tools/bindings/mojom_bindings_generator.py.

library ledger2_mojom;
import 'dart:async';
import 'package:mojo/bindings.dart' as bindings;
import 'package:mojo/core.dart' as core;
import 'package:mojo/mojo/bindings/types/service_describer.mojom.dart' as service_describer;
import 'package:modular/modular/graph.mojom.dart' as graph_mojom;



class _LedgerMutatorApplyEventParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  graph_mojom.GraphEvent event = null;

  _LedgerMutatorApplyEventParams() : super(kVersions.last.size);

  _LedgerMutatorApplyEventParams.init(
    graph_mojom.GraphEvent this.event
  ) : super(kVersions.last.size);

  static _LedgerMutatorApplyEventParams deserialize(bindings.Message message) {
    var decoder = new bindings.Decoder(message);
    var result = decode(decoder);
    if (decoder.excessHandles != null) {
      decoder.excessHandles.forEach((h) => h.close());
    }
    return result;
  }

  static _LedgerMutatorApplyEventParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _LedgerMutatorApplyEventParams result = new _LedgerMutatorApplyEventParams();

    var mainDataHeader = decoder0.decodeStructDataHeader();
    if (mainDataHeader.version <= kVersions.last.version) {
      // Scan in reverse order to optimize for more recent versions.
      for (int i = kVersions.length - 1; i >= 0; --i) {
        if (mainDataHeader.version >= kVersions[i].version) {
          if (mainDataHeader.size == kVersions[i].size) {
            // Found a match.
            break;
          }
          throw new bindings.MojoCodecError(
              'Header size doesn\'t correspond to known version size.');
        }
      }
    } else if (mainDataHeader.size < kVersions.last.size) {
      throw new bindings.MojoCodecError(
        'Message newer than the last known version cannot be shorter than '
        'required by the last known version.');
    }
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(8, false);
      result.event = graph_mojom.GraphEvent.decode(decoder1);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    try {
      encoder0.encodeStruct(event, 8, false);
    } on bindings.MojoCodecError catch(e) {
      e.message = "Error encountered while encoding field "
          "event of struct _LedgerMutatorApplyEventParams: $e";
      rethrow;
    }
  }

  String toString() {
    return "_LedgerMutatorApplyEventParams("
           "event: $event" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["event"] = event;
    return map;
  }
}


class _LedgerObserverOnSuccessParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  graph_mojom.GraphEvent event = null;

  _LedgerObserverOnSuccessParams() : super(kVersions.last.size);

  _LedgerObserverOnSuccessParams.init(
    graph_mojom.GraphEvent this.event
  ) : super(kVersions.last.size);

  static _LedgerObserverOnSuccessParams deserialize(bindings.Message message) {
    var decoder = new bindings.Decoder(message);
    var result = decode(decoder);
    if (decoder.excessHandles != null) {
      decoder.excessHandles.forEach((h) => h.close());
    }
    return result;
  }

  static _LedgerObserverOnSuccessParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _LedgerObserverOnSuccessParams result = new _LedgerObserverOnSuccessParams();

    var mainDataHeader = decoder0.decodeStructDataHeader();
    if (mainDataHeader.version <= kVersions.last.version) {
      // Scan in reverse order to optimize for more recent versions.
      for (int i = kVersions.length - 1; i >= 0; --i) {
        if (mainDataHeader.version >= kVersions[i].version) {
          if (mainDataHeader.size == kVersions[i].size) {
            // Found a match.
            break;
          }
          throw new bindings.MojoCodecError(
              'Header size doesn\'t correspond to known version size.');
        }
      }
    } else if (mainDataHeader.size < kVersions.last.size) {
      throw new bindings.MojoCodecError(
        'Message newer than the last known version cannot be shorter than '
        'required by the last known version.');
    }
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(8, false);
      result.event = graph_mojom.GraphEvent.decode(decoder1);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    try {
      encoder0.encodeStruct(event, 8, false);
    } on bindings.MojoCodecError catch(e) {
      e.message = "Error encountered while encoding field "
          "event of struct _LedgerObserverOnSuccessParams: $e";
      rethrow;
    }
  }

  String toString() {
    return "_LedgerObserverOnSuccessParams("
           "event: $event" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["event"] = event;
    return map;
  }
}


class _LedgerObserverOnFailureParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(32, 0)
  ];
  graph_mojom.GraphEvent event = null;
  graph_mojom.GraphMutation failed = null;

  _LedgerObserverOnFailureParams() : super(kVersions.last.size);

  _LedgerObserverOnFailureParams.init(
    graph_mojom.GraphEvent this.event, 
    graph_mojom.GraphMutation this.failed
  ) : super(kVersions.last.size);

  static _LedgerObserverOnFailureParams deserialize(bindings.Message message) {
    var decoder = new bindings.Decoder(message);
    var result = decode(decoder);
    if (decoder.excessHandles != null) {
      decoder.excessHandles.forEach((h) => h.close());
    }
    return result;
  }

  static _LedgerObserverOnFailureParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _LedgerObserverOnFailureParams result = new _LedgerObserverOnFailureParams();

    var mainDataHeader = decoder0.decodeStructDataHeader();
    if (mainDataHeader.version <= kVersions.last.version) {
      // Scan in reverse order to optimize for more recent versions.
      for (int i = kVersions.length - 1; i >= 0; --i) {
        if (mainDataHeader.version >= kVersions[i].version) {
          if (mainDataHeader.size == kVersions[i].size) {
            // Found a match.
            break;
          }
          throw new bindings.MojoCodecError(
              'Header size doesn\'t correspond to known version size.');
        }
      }
    } else if (mainDataHeader.size < kVersions.last.size) {
      throw new bindings.MojoCodecError(
        'Message newer than the last known version cannot be shorter than '
        'required by the last known version.');
    }
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(8, false);
      result.event = graph_mojom.GraphEvent.decode(decoder1);
    }
    if (mainDataHeader.version >= 0) {
      
        result.failed = graph_mojom.GraphMutation.decode(decoder0, 16);
        if (result.failed == null) {
          throw new bindings.MojoCodecError(
            'Trying to decode null union for non-nullable graph_mojom.GraphMutation.');
        }
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    try {
      encoder0.encodeStruct(event, 8, false);
    } on bindings.MojoCodecError catch(e) {
      e.message = "Error encountered while encoding field "
          "event of struct _LedgerObserverOnFailureParams: $e";
      rethrow;
    }
    try {
      encoder0.encodeUnion(failed, 16, false);
    } on bindings.MojoCodecError catch(e) {
      e.message = "Error encountered while encoding field "
          "failed of struct _LedgerObserverOnFailureParams: $e";
      rethrow;
    }
  }

  String toString() {
    return "_LedgerObserverOnFailureParams("
           "event: $event" ", "
           "failed: $failed" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["event"] = event;
    map["failed"] = failed;
    return map;
  }
}


class _LedgerObserverOnChangeParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  graph_mojom.GraphEvent event = null;

  _LedgerObserverOnChangeParams() : super(kVersions.last.size);

  _LedgerObserverOnChangeParams.init(
    graph_mojom.GraphEvent this.event
  ) : super(kVersions.last.size);

  static _LedgerObserverOnChangeParams deserialize(bindings.Message message) {
    var decoder = new bindings.Decoder(message);
    var result = decode(decoder);
    if (decoder.excessHandles != null) {
      decoder.excessHandles.forEach((h) => h.close());
    }
    return result;
  }

  static _LedgerObserverOnChangeParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _LedgerObserverOnChangeParams result = new _LedgerObserverOnChangeParams();

    var mainDataHeader = decoder0.decodeStructDataHeader();
    if (mainDataHeader.version <= kVersions.last.version) {
      // Scan in reverse order to optimize for more recent versions.
      for (int i = kVersions.length - 1; i >= 0; --i) {
        if (mainDataHeader.version >= kVersions[i].version) {
          if (mainDataHeader.size == kVersions[i].size) {
            // Found a match.
            break;
          }
          throw new bindings.MojoCodecError(
              'Header size doesn\'t correspond to known version size.');
        }
      }
    } else if (mainDataHeader.size < kVersions.last.size) {
      throw new bindings.MojoCodecError(
        'Message newer than the last known version cannot be shorter than '
        'required by the last known version.');
    }
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(8, false);
      result.event = graph_mojom.GraphEvent.decode(decoder1);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    try {
      encoder0.encodeStruct(event, 8, false);
    } on bindings.MojoCodecError catch(e) {
      e.message = "Error encountered while encoding field "
          "event of struct _LedgerObserverOnChangeParams: $e";
      rethrow;
    }
  }

  String toString() {
    return "_LedgerObserverOnChangeParams("
           "event: $event" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["event"] = event;
    return map;
  }
}


class _LedgerCreateSessionParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(32, 0)
  ];
  List<int> uuid = null;
  LedgerMutatorInterfaceRequest mutator = null;
  LedgerObserverInterface observer = null;

  _LedgerCreateSessionParams() : super(kVersions.last.size);

  _LedgerCreateSessionParams.init(
    List<int> this.uuid, 
    LedgerMutatorInterfaceRequest this.mutator, 
    LedgerObserverInterface this.observer
  ) : super(kVersions.last.size);

  static _LedgerCreateSessionParams deserialize(bindings.Message message) {
    var decoder = new bindings.Decoder(message);
    var result = decode(decoder);
    if (decoder.excessHandles != null) {
      decoder.excessHandles.forEach((h) => h.close());
    }
    return result;
  }

  static _LedgerCreateSessionParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _LedgerCreateSessionParams result = new _LedgerCreateSessionParams();

    var mainDataHeader = decoder0.decodeStructDataHeader();
    if (mainDataHeader.version <= kVersions.last.version) {
      // Scan in reverse order to optimize for more recent versions.
      for (int i = kVersions.length - 1; i >= 0; --i) {
        if (mainDataHeader.version >= kVersions[i].version) {
          if (mainDataHeader.size == kVersions[i].size) {
            // Found a match.
            break;
          }
          throw new bindings.MojoCodecError(
              'Header size doesn\'t correspond to known version size.');
        }
      }
    } else if (mainDataHeader.size < kVersions.last.size) {
      throw new bindings.MojoCodecError(
        'Message newer than the last known version cannot be shorter than '
        'required by the last known version.');
    }
    if (mainDataHeader.version >= 0) {
      
      result.uuid = decoder0.decodeUint8Array(8, bindings.kNothingNullable, 16);
    }
    if (mainDataHeader.version >= 0) {
      
      result.mutator = decoder0.decodeInterfaceRequest(16, false, LedgerMutatorStub.newFromEndpoint);
    }
    if (mainDataHeader.version >= 0) {
      
      result.observer = decoder0.decodeServiceInterface(20, false, LedgerObserverProxy.newFromEndpoint);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    try {
      encoder0.encodeUint8Array(uuid, 8, bindings.kNothingNullable, 16);
    } on bindings.MojoCodecError catch(e) {
      e.message = "Error encountered while encoding field "
          "uuid of struct _LedgerCreateSessionParams: $e";
      rethrow;
    }
    try {
      encoder0.encodeInterfaceRequest(mutator, 16, false);
    } on bindings.MojoCodecError catch(e) {
      e.message = "Error encountered while encoding field "
          "mutator of struct _LedgerCreateSessionParams: $e";
      rethrow;
    }
    try {
      encoder0.encodeInterface(observer, 20, false);
    } on bindings.MojoCodecError catch(e) {
      e.message = "Error encountered while encoding field "
          "observer of struct _LedgerCreateSessionParams: $e";
      rethrow;
    }
  }

  String toString() {
    return "_LedgerCreateSessionParams("
           "uuid: $uuid" ", "
           "mutator: $mutator" ", "
           "observer: $observer" ")";
  }

  Map toJson() {
    throw new bindings.MojoCodecError(
        'Object containing handles cannot be encoded to JSON.');
  }
}


class LedgerCreateSessionResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  LedgerStatus status = null;

  LedgerCreateSessionResponseParams() : super(kVersions.last.size);

  LedgerCreateSessionResponseParams.init(
    LedgerStatus this.status
  ) : super(kVersions.last.size);

  static LedgerCreateSessionResponseParams deserialize(bindings.Message message) {
    var decoder = new bindings.Decoder(message);
    var result = decode(decoder);
    if (decoder.excessHandles != null) {
      decoder.excessHandles.forEach((h) => h.close());
    }
    return result;
  }

  static LedgerCreateSessionResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    LedgerCreateSessionResponseParams result = new LedgerCreateSessionResponseParams();

    var mainDataHeader = decoder0.decodeStructDataHeader();
    if (mainDataHeader.version <= kVersions.last.version) {
      // Scan in reverse order to optimize for more recent versions.
      for (int i = kVersions.length - 1; i >= 0; --i) {
        if (mainDataHeader.version >= kVersions[i].version) {
          if (mainDataHeader.size == kVersions[i].size) {
            // Found a match.
            break;
          }
          throw new bindings.MojoCodecError(
              'Header size doesn\'t correspond to known version size.');
        }
      }
    } else if (mainDataHeader.size < kVersions.last.size) {
      throw new bindings.MojoCodecError(
        'Message newer than the last known version cannot be shorter than '
        'required by the last known version.');
    }
    if (mainDataHeader.version >= 0) {
      
        result.status = LedgerStatus.decode(decoder0, 8);
        if (result.status == null) {
          throw new bindings.MojoCodecError(
            'Trying to decode null union for non-nullable LedgerStatus.');
        }
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    try {
      encoder0.encodeEnum(status, 8);
    } on bindings.MojoCodecError catch(e) {
      e.message = "Error encountered while encoding field "
          "status of struct LedgerCreateSessionResponseParams: $e";
      rethrow;
    }
  }

  String toString() {
    return "LedgerCreateSessionResponseParams("
           "status: $status" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["status"] = status;
    return map;
  }
}


class _LedgerConnectToSessionParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(32, 0)
  ];
  List<int> uuid = null;
  LedgerMutatorInterfaceRequest mutator = null;
  LedgerObserverInterface observer = null;

  _LedgerConnectToSessionParams() : super(kVersions.last.size);

  _LedgerConnectToSessionParams.init(
    List<int> this.uuid, 
    LedgerMutatorInterfaceRequest this.mutator, 
    LedgerObserverInterface this.observer
  ) : super(kVersions.last.size);

  static _LedgerConnectToSessionParams deserialize(bindings.Message message) {
    var decoder = new bindings.Decoder(message);
    var result = decode(decoder);
    if (decoder.excessHandles != null) {
      decoder.excessHandles.forEach((h) => h.close());
    }
    return result;
  }

  static _LedgerConnectToSessionParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _LedgerConnectToSessionParams result = new _LedgerConnectToSessionParams();

    var mainDataHeader = decoder0.decodeStructDataHeader();
    if (mainDataHeader.version <= kVersions.last.version) {
      // Scan in reverse order to optimize for more recent versions.
      for (int i = kVersions.length - 1; i >= 0; --i) {
        if (mainDataHeader.version >= kVersions[i].version) {
          if (mainDataHeader.size == kVersions[i].size) {
            // Found a match.
            break;
          }
          throw new bindings.MojoCodecError(
              'Header size doesn\'t correspond to known version size.');
        }
      }
    } else if (mainDataHeader.size < kVersions.last.size) {
      throw new bindings.MojoCodecError(
        'Message newer than the last known version cannot be shorter than '
        'required by the last known version.');
    }
    if (mainDataHeader.version >= 0) {
      
      result.uuid = decoder0.decodeUint8Array(8, bindings.kNothingNullable, 16);
    }
    if (mainDataHeader.version >= 0) {
      
      result.mutator = decoder0.decodeInterfaceRequest(16, false, LedgerMutatorStub.newFromEndpoint);
    }
    if (mainDataHeader.version >= 0) {
      
      result.observer = decoder0.decodeServiceInterface(20, false, LedgerObserverProxy.newFromEndpoint);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    try {
      encoder0.encodeUint8Array(uuid, 8, bindings.kNothingNullable, 16);
    } on bindings.MojoCodecError catch(e) {
      e.message = "Error encountered while encoding field "
          "uuid of struct _LedgerConnectToSessionParams: $e";
      rethrow;
    }
    try {
      encoder0.encodeInterfaceRequest(mutator, 16, false);
    } on bindings.MojoCodecError catch(e) {
      e.message = "Error encountered while encoding field "
          "mutator of struct _LedgerConnectToSessionParams: $e";
      rethrow;
    }
    try {
      encoder0.encodeInterface(observer, 20, false);
    } on bindings.MojoCodecError catch(e) {
      e.message = "Error encountered while encoding field "
          "observer of struct _LedgerConnectToSessionParams: $e";
      rethrow;
    }
  }

  String toString() {
    return "_LedgerConnectToSessionParams("
           "uuid: $uuid" ", "
           "mutator: $mutator" ", "
           "observer: $observer" ")";
  }

  Map toJson() {
    throw new bindings.MojoCodecError(
        'Object containing handles cannot be encoded to JSON.');
  }
}


class LedgerConnectToSessionResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  LedgerStatus status = null;

  LedgerConnectToSessionResponseParams() : super(kVersions.last.size);

  LedgerConnectToSessionResponseParams.init(
    LedgerStatus this.status
  ) : super(kVersions.last.size);

  static LedgerConnectToSessionResponseParams deserialize(bindings.Message message) {
    var decoder = new bindings.Decoder(message);
    var result = decode(decoder);
    if (decoder.excessHandles != null) {
      decoder.excessHandles.forEach((h) => h.close());
    }
    return result;
  }

  static LedgerConnectToSessionResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    LedgerConnectToSessionResponseParams result = new LedgerConnectToSessionResponseParams();

    var mainDataHeader = decoder0.decodeStructDataHeader();
    if (mainDataHeader.version <= kVersions.last.version) {
      // Scan in reverse order to optimize for more recent versions.
      for (int i = kVersions.length - 1; i >= 0; --i) {
        if (mainDataHeader.version >= kVersions[i].version) {
          if (mainDataHeader.size == kVersions[i].size) {
            // Found a match.
            break;
          }
          throw new bindings.MojoCodecError(
              'Header size doesn\'t correspond to known version size.');
        }
      }
    } else if (mainDataHeader.size < kVersions.last.size) {
      throw new bindings.MojoCodecError(
        'Message newer than the last known version cannot be shorter than '
        'required by the last known version.');
    }
    if (mainDataHeader.version >= 0) {
      
        result.status = LedgerStatus.decode(decoder0, 8);
        if (result.status == null) {
          throw new bindings.MojoCodecError(
            'Trying to decode null union for non-nullable LedgerStatus.');
        }
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    try {
      encoder0.encodeEnum(status, 8);
    } on bindings.MojoCodecError catch(e) {
      e.message = "Error encountered while encoding field "
          "status of struct LedgerConnectToSessionResponseParams: $e";
      rethrow;
    }
  }

  String toString() {
    return "LedgerConnectToSessionResponseParams("
           "status: $status" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["status"] = status;
    return map;
  }
}

const int _ledgerMutatorMethodApplyEventName = 0;

class _LedgerMutatorServiceDescription implements service_describer.ServiceDescription {
  void getTopLevelInterface(Function responder) {
    responder(null);
  }

  void getTypeDefinition(String typeKey, Function responder) {
    responder(null);
  }

  void getAllTypeDefinitions(Function responder) {
    responder(null);
  }
}

abstract class LedgerMutator {
  static const String serviceName = null;

  static service_describer.ServiceDescription _cachedServiceDescription;
  static service_describer.ServiceDescription get serviceDescription {
    if (_cachedServiceDescription == null) {
      _cachedServiceDescription = new _LedgerMutatorServiceDescription();
    }
    return _cachedServiceDescription;
  }

  static LedgerMutatorProxy connectToService(
      bindings.ServiceConnector s, String url, [String serviceName]) {
    LedgerMutatorProxy p = new LedgerMutatorProxy.unbound();
    String name = serviceName ?? LedgerMutator.serviceName;
    if ((name == null) || name.isEmpty) {
      throw new core.MojoApiError(
          "If an interface has no ServiceName, then one must be provided.");
    }
    s.connectToService(url, p, name);
    return p;
  }
  void applyEvent(graph_mojom.GraphEvent event);
}

abstract class LedgerMutatorInterface
    implements bindings.MojoInterface<LedgerMutator>,
               LedgerMutator {
  factory LedgerMutatorInterface([LedgerMutator impl]) =>
      new LedgerMutatorStub.unbound(impl);

  factory LedgerMutatorInterface.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint,
      [LedgerMutator impl]) =>
      new LedgerMutatorStub.fromEndpoint(endpoint, impl);

  factory LedgerMutatorInterface.fromMock(
      LedgerMutator mock) =>
      new LedgerMutatorProxy.fromMock(mock);
}

abstract class LedgerMutatorInterfaceRequest
    implements bindings.MojoInterface<LedgerMutator>,
               LedgerMutator {
  factory LedgerMutatorInterfaceRequest() =>
      new LedgerMutatorProxy.unbound();
}

class _LedgerMutatorProxyControl
    extends bindings.ProxyMessageHandler
    implements bindings.ProxyControl<LedgerMutator> {
  LedgerMutator impl;

  _LedgerMutatorProxyControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) : super.fromEndpoint(endpoint);

  _LedgerMutatorProxyControl.fromHandle(
      core.MojoHandle handle) : super.fromHandle(handle);

  _LedgerMutatorProxyControl.unbound() : super.unbound();

  String get serviceName => LedgerMutator.serviceName;

  void handleResponse(bindings.ServiceMessage message) {
    switch (message.header.type) {
      default:
        proxyError("Unexpected message type: ${message.header.type}");
        close(immediate: true);
        break;
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_LedgerMutatorProxyControl($superString)";
  }
}

class LedgerMutatorProxy
    extends bindings.Proxy<LedgerMutator>
    implements LedgerMutator,
               LedgerMutatorInterface,
               LedgerMutatorInterfaceRequest {
  LedgerMutatorProxy.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint)
      : super(new _LedgerMutatorProxyControl.fromEndpoint(endpoint));

  LedgerMutatorProxy.fromHandle(core.MojoHandle handle)
      : super(new _LedgerMutatorProxyControl.fromHandle(handle));

  LedgerMutatorProxy.unbound()
      : super(new _LedgerMutatorProxyControl.unbound());

  factory LedgerMutatorProxy.fromMock(LedgerMutator mock) {
    LedgerMutatorProxy newMockedProxy =
        new LedgerMutatorProxy.unbound();
    newMockedProxy.impl = mock;
    return newMockedProxy;
  }

  static LedgerMutatorProxy newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For LedgerMutatorProxy"));
    return new LedgerMutatorProxy.fromEndpoint(endpoint);
  }


  void applyEvent(graph_mojom.GraphEvent event) {
    if (impl != null) {
      impl.applyEvent(event);
      return;
    }
    if (!ctrl.isBound) {
      ctrl.proxyError("The Proxy is closed.");
      return;
    }
    var params = new _LedgerMutatorApplyEventParams();
    params.event = event;
    ctrl.sendMessage(params,
        _ledgerMutatorMethodApplyEventName);
  }
}

class _LedgerMutatorStubControl
    extends bindings.StubMessageHandler
    implements bindings.StubControl<LedgerMutator> {
  LedgerMutator _impl;

  _LedgerMutatorStubControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [LedgerMutator impl])
      : super.fromEndpoint(endpoint, autoBegin: impl != null) {
    _impl = impl;
  }

  _LedgerMutatorStubControl.fromHandle(
      core.MojoHandle handle, [LedgerMutator impl])
      : super.fromHandle(handle, autoBegin: impl != null) {
    _impl = impl;
  }

  _LedgerMutatorStubControl.unbound([this._impl]) : super.unbound();

  String get serviceName => LedgerMutator.serviceName;



  void handleMessage(bindings.ServiceMessage message) {
    if (bindings.ControlMessageHandler.isControlMessage(message)) {
      bindings.ControlMessageHandler.handleMessage(
          this, 0, message);
      return;
    }
    if (_impl == null) {
      throw new core.MojoApiError("$this has no implementation set");
    }
    switch (message.header.type) {
      case _ledgerMutatorMethodApplyEventName:
        var params = _LedgerMutatorApplyEventParams.deserialize(
            message.payload);
        _impl.applyEvent(params.event);
        break;
      default:
        throw new bindings.MojoCodecError("Unexpected message name");
        break;
    }
  }

  LedgerMutator get impl => _impl;
  set impl(LedgerMutator d) {
    if (d == null) {
      throw new core.MojoApiError("$this: Cannot set a null implementation");
    }
    if (isBound && (_impl == null)) {
      beginHandlingEvents();
    }
    _impl = d;
  }

  @override
  void bind(core.MojoMessagePipeEndpoint endpoint) {
    super.bind(endpoint);
    if (!isOpen && (_impl != null)) {
      beginHandlingEvents();
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_LedgerMutatorStubControl($superString)";
  }

  int get version => 0;
}

class LedgerMutatorStub
    extends bindings.Stub<LedgerMutator>
    implements LedgerMutator,
               LedgerMutatorInterface,
               LedgerMutatorInterfaceRequest {
  LedgerMutatorStub.unbound([LedgerMutator impl])
      : super(new _LedgerMutatorStubControl.unbound(impl));

  LedgerMutatorStub.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [LedgerMutator impl])
      : super(new _LedgerMutatorStubControl.fromEndpoint(endpoint, impl));

  LedgerMutatorStub.fromHandle(
      core.MojoHandle handle, [LedgerMutator impl])
      : super(new _LedgerMutatorStubControl.fromHandle(handle, impl));

  static LedgerMutatorStub newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For LedgerMutatorStub"));
    return new LedgerMutatorStub.fromEndpoint(endpoint);
  }


  void applyEvent(graph_mojom.GraphEvent event) {
    return impl.applyEvent(event);
  }
}

const int _ledgerObserverMethodOnSuccessName = 0;
const int _ledgerObserverMethodOnFailureName = 1;
const int _ledgerObserverMethodOnChangeName = 2;

class _LedgerObserverServiceDescription implements service_describer.ServiceDescription {
  void getTopLevelInterface(Function responder) {
    responder(null);
  }

  void getTypeDefinition(String typeKey, Function responder) {
    responder(null);
  }

  void getAllTypeDefinitions(Function responder) {
    responder(null);
  }
}

abstract class LedgerObserver {
  static const String serviceName = null;

  static service_describer.ServiceDescription _cachedServiceDescription;
  static service_describer.ServiceDescription get serviceDescription {
    if (_cachedServiceDescription == null) {
      _cachedServiceDescription = new _LedgerObserverServiceDescription();
    }
    return _cachedServiceDescription;
  }

  static LedgerObserverProxy connectToService(
      bindings.ServiceConnector s, String url, [String serviceName]) {
    LedgerObserverProxy p = new LedgerObserverProxy.unbound();
    String name = serviceName ?? LedgerObserver.serviceName;
    if ((name == null) || name.isEmpty) {
      throw new core.MojoApiError(
          "If an interface has no ServiceName, then one must be provided.");
    }
    s.connectToService(url, p, name);
    return p;
  }
  void onSuccess(graph_mojom.GraphEvent event);
  void onFailure(graph_mojom.GraphEvent event, graph_mojom.GraphMutation failed);
  void onChange(graph_mojom.GraphEvent event);
}

abstract class LedgerObserverInterface
    implements bindings.MojoInterface<LedgerObserver>,
               LedgerObserver {
  factory LedgerObserverInterface([LedgerObserver impl]) =>
      new LedgerObserverStub.unbound(impl);

  factory LedgerObserverInterface.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint,
      [LedgerObserver impl]) =>
      new LedgerObserverStub.fromEndpoint(endpoint, impl);

  factory LedgerObserverInterface.fromMock(
      LedgerObserver mock) =>
      new LedgerObserverProxy.fromMock(mock);
}

abstract class LedgerObserverInterfaceRequest
    implements bindings.MojoInterface<LedgerObserver>,
               LedgerObserver {
  factory LedgerObserverInterfaceRequest() =>
      new LedgerObserverProxy.unbound();
}

class _LedgerObserverProxyControl
    extends bindings.ProxyMessageHandler
    implements bindings.ProxyControl<LedgerObserver> {
  LedgerObserver impl;

  _LedgerObserverProxyControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) : super.fromEndpoint(endpoint);

  _LedgerObserverProxyControl.fromHandle(
      core.MojoHandle handle) : super.fromHandle(handle);

  _LedgerObserverProxyControl.unbound() : super.unbound();

  String get serviceName => LedgerObserver.serviceName;

  void handleResponse(bindings.ServiceMessage message) {
    switch (message.header.type) {
      default:
        proxyError("Unexpected message type: ${message.header.type}");
        close(immediate: true);
        break;
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_LedgerObserverProxyControl($superString)";
  }
}

class LedgerObserverProxy
    extends bindings.Proxy<LedgerObserver>
    implements LedgerObserver,
               LedgerObserverInterface,
               LedgerObserverInterfaceRequest {
  LedgerObserverProxy.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint)
      : super(new _LedgerObserverProxyControl.fromEndpoint(endpoint));

  LedgerObserverProxy.fromHandle(core.MojoHandle handle)
      : super(new _LedgerObserverProxyControl.fromHandle(handle));

  LedgerObserverProxy.unbound()
      : super(new _LedgerObserverProxyControl.unbound());

  factory LedgerObserverProxy.fromMock(LedgerObserver mock) {
    LedgerObserverProxy newMockedProxy =
        new LedgerObserverProxy.unbound();
    newMockedProxy.impl = mock;
    return newMockedProxy;
  }

  static LedgerObserverProxy newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For LedgerObserverProxy"));
    return new LedgerObserverProxy.fromEndpoint(endpoint);
  }


  void onSuccess(graph_mojom.GraphEvent event) {
    if (impl != null) {
      impl.onSuccess(event);
      return;
    }
    if (!ctrl.isBound) {
      ctrl.proxyError("The Proxy is closed.");
      return;
    }
    var params = new _LedgerObserverOnSuccessParams();
    params.event = event;
    ctrl.sendMessage(params,
        _ledgerObserverMethodOnSuccessName);
  }
  void onFailure(graph_mojom.GraphEvent event, graph_mojom.GraphMutation failed) {
    if (impl != null) {
      impl.onFailure(event, failed);
      return;
    }
    if (!ctrl.isBound) {
      ctrl.proxyError("The Proxy is closed.");
      return;
    }
    var params = new _LedgerObserverOnFailureParams();
    params.event = event;
    params.failed = failed;
    ctrl.sendMessage(params,
        _ledgerObserverMethodOnFailureName);
  }
  void onChange(graph_mojom.GraphEvent event) {
    if (impl != null) {
      impl.onChange(event);
      return;
    }
    if (!ctrl.isBound) {
      ctrl.proxyError("The Proxy is closed.");
      return;
    }
    var params = new _LedgerObserverOnChangeParams();
    params.event = event;
    ctrl.sendMessage(params,
        _ledgerObserverMethodOnChangeName);
  }
}

class _LedgerObserverStubControl
    extends bindings.StubMessageHandler
    implements bindings.StubControl<LedgerObserver> {
  LedgerObserver _impl;

  _LedgerObserverStubControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [LedgerObserver impl])
      : super.fromEndpoint(endpoint, autoBegin: impl != null) {
    _impl = impl;
  }

  _LedgerObserverStubControl.fromHandle(
      core.MojoHandle handle, [LedgerObserver impl])
      : super.fromHandle(handle, autoBegin: impl != null) {
    _impl = impl;
  }

  _LedgerObserverStubControl.unbound([this._impl]) : super.unbound();

  String get serviceName => LedgerObserver.serviceName;



  void handleMessage(bindings.ServiceMessage message) {
    if (bindings.ControlMessageHandler.isControlMessage(message)) {
      bindings.ControlMessageHandler.handleMessage(
          this, 0, message);
      return;
    }
    if (_impl == null) {
      throw new core.MojoApiError("$this has no implementation set");
    }
    switch (message.header.type) {
      case _ledgerObserverMethodOnSuccessName:
        var params = _LedgerObserverOnSuccessParams.deserialize(
            message.payload);
        _impl.onSuccess(params.event);
        break;
      case _ledgerObserverMethodOnFailureName:
        var params = _LedgerObserverOnFailureParams.deserialize(
            message.payload);
        _impl.onFailure(params.event, params.failed);
        break;
      case _ledgerObserverMethodOnChangeName:
        var params = _LedgerObserverOnChangeParams.deserialize(
            message.payload);
        _impl.onChange(params.event);
        break;
      default:
        throw new bindings.MojoCodecError("Unexpected message name");
        break;
    }
  }

  LedgerObserver get impl => _impl;
  set impl(LedgerObserver d) {
    if (d == null) {
      throw new core.MojoApiError("$this: Cannot set a null implementation");
    }
    if (isBound && (_impl == null)) {
      beginHandlingEvents();
    }
    _impl = d;
  }

  @override
  void bind(core.MojoMessagePipeEndpoint endpoint) {
    super.bind(endpoint);
    if (!isOpen && (_impl != null)) {
      beginHandlingEvents();
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_LedgerObserverStubControl($superString)";
  }

  int get version => 0;
}

class LedgerObserverStub
    extends bindings.Stub<LedgerObserver>
    implements LedgerObserver,
               LedgerObserverInterface,
               LedgerObserverInterfaceRequest {
  LedgerObserverStub.unbound([LedgerObserver impl])
      : super(new _LedgerObserverStubControl.unbound(impl));

  LedgerObserverStub.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [LedgerObserver impl])
      : super(new _LedgerObserverStubControl.fromEndpoint(endpoint, impl));

  LedgerObserverStub.fromHandle(
      core.MojoHandle handle, [LedgerObserver impl])
      : super(new _LedgerObserverStubControl.fromHandle(handle, impl));

  static LedgerObserverStub newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For LedgerObserverStub"));
    return new LedgerObserverStub.fromEndpoint(endpoint);
  }


  void onSuccess(graph_mojom.GraphEvent event) {
    return impl.onSuccess(event);
  }
  void onFailure(graph_mojom.GraphEvent event, graph_mojom.GraphMutation failed) {
    return impl.onFailure(event, failed);
  }
  void onChange(graph_mojom.GraphEvent event) {
    return impl.onChange(event);
  }
}

const int _ledgerMethodCreateSessionName = 0;
const int _ledgerMethodConnectToSessionName = 1;
  
class LedgerStatus extends bindings.MojoEnum {
  static const LedgerStatus ok = const LedgerStatus._(0);
  static const LedgerStatus internalError = const LedgerStatus._(1);
  static const LedgerStatus authenticationError = const LedgerStatus._(2);
  static const LedgerStatus sessionAlreadyExists = const LedgerStatus._(3);
  static const LedgerStatus sessionDoesNotExist = const LedgerStatus._(4);

  const LedgerStatus._(int v) : super(v);

  static const Map<String, LedgerStatus> valuesMap = const {
    "ok": ok,
    "internalError": internalError,
    "authenticationError": authenticationError,
    "sessionAlreadyExists": sessionAlreadyExists,
    "sessionDoesNotExist": sessionDoesNotExist,
  };
  static const List<LedgerStatus> values = const [
    ok,
    internalError,
    authenticationError,
    sessionAlreadyExists,
    sessionDoesNotExist,
  ];

  static LedgerStatus valueOf(String name) => valuesMap[name];

  factory LedgerStatus(int v) {
    switch (v) {
      case 0:
        return LedgerStatus.ok;
      case 1:
        return LedgerStatus.internalError;
      case 2:
        return LedgerStatus.authenticationError;
      case 3:
        return LedgerStatus.sessionAlreadyExists;
      case 4:
        return LedgerStatus.sessionDoesNotExist;
      default:
        return null;
    }
  }

  static LedgerStatus decode(bindings.Decoder decoder0, int offset) {
    int v = decoder0.decodeUint32(offset);
    LedgerStatus result = new LedgerStatus(v);
    if (result == null) {
      throw new bindings.MojoCodecError(
          'Bad value $v for enum LedgerStatus.');
    }
    return result;
  }

  String toString() {
    switch(this) {
      case ok:
        return 'LedgerStatus.ok';
      case internalError:
        return 'LedgerStatus.internalError';
      case authenticationError:
        return 'LedgerStatus.authenticationError';
      case sessionAlreadyExists:
        return 'LedgerStatus.sessionAlreadyExists';
      case sessionDoesNotExist:
        return 'LedgerStatus.sessionDoesNotExist';
      default:
        return null;
    }
  }

  int toJson() => mojoEnumValue;
}

class _LedgerServiceDescription implements service_describer.ServiceDescription {
  void getTopLevelInterface(Function responder) {
    responder(null);
  }

  void getTypeDefinition(String typeKey, Function responder) {
    responder(null);
  }

  void getAllTypeDefinitions(Function responder) {
    responder(null);
  }
}

abstract class Ledger {
  static const String serviceName = "ledger2::Ledger";

  static service_describer.ServiceDescription _cachedServiceDescription;
  static service_describer.ServiceDescription get serviceDescription {
    if (_cachedServiceDescription == null) {
      _cachedServiceDescription = new _LedgerServiceDescription();
    }
    return _cachedServiceDescription;
  }

  static LedgerProxy connectToService(
      bindings.ServiceConnector s, String url, [String serviceName]) {
    LedgerProxy p = new LedgerProxy.unbound();
    String name = serviceName ?? Ledger.serviceName;
    if ((name == null) || name.isEmpty) {
      throw new core.MojoApiError(
          "If an interface has no ServiceName, then one must be provided.");
    }
    s.connectToService(url, p, name);
    return p;
  }
  void createSession(List<int> uuid,LedgerMutatorInterfaceRequest mutator,LedgerObserverInterface observer,void callback(LedgerStatus status));
  void connectToSession(List<int> uuid,LedgerMutatorInterfaceRequest mutator,LedgerObserverInterface observer,void callback(LedgerStatus status));
}

abstract class LedgerInterface
    implements bindings.MojoInterface<Ledger>,
               Ledger {
  factory LedgerInterface([Ledger impl]) =>
      new LedgerStub.unbound(impl);

  factory LedgerInterface.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint,
      [Ledger impl]) =>
      new LedgerStub.fromEndpoint(endpoint, impl);

  factory LedgerInterface.fromMock(
      Ledger mock) =>
      new LedgerProxy.fromMock(mock);
}

abstract class LedgerInterfaceRequest
    implements bindings.MojoInterface<Ledger>,
               Ledger {
  factory LedgerInterfaceRequest() =>
      new LedgerProxy.unbound();
}

class _LedgerProxyControl
    extends bindings.ProxyMessageHandler
    implements bindings.ProxyControl<Ledger> {
  Ledger impl;

  _LedgerProxyControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) : super.fromEndpoint(endpoint);

  _LedgerProxyControl.fromHandle(
      core.MojoHandle handle) : super.fromHandle(handle);

  _LedgerProxyControl.unbound() : super.unbound();

  String get serviceName => Ledger.serviceName;

  void handleResponse(bindings.ServiceMessage message) {
    switch (message.header.type) {
      case _ledgerMethodCreateSessionName:
        var r = LedgerCreateSessionResponseParams.deserialize(
            message.payload);
        if (!message.header.hasRequestId) {
          proxyError("Expected a message with a valid request Id.");
          return;
        }
        Function callback = callbackMap[message.header.requestId];
        if (callback == null) {
          proxyError(
              "Message had unknown request Id: ${message.header.requestId}");
          return;
        }
        callbackMap.remove(message.header.requestId);
        callback(r.status );
        break;
      case _ledgerMethodConnectToSessionName:
        var r = LedgerConnectToSessionResponseParams.deserialize(
            message.payload);
        if (!message.header.hasRequestId) {
          proxyError("Expected a message with a valid request Id.");
          return;
        }
        Function callback = callbackMap[message.header.requestId];
        if (callback == null) {
          proxyError(
              "Message had unknown request Id: ${message.header.requestId}");
          return;
        }
        callbackMap.remove(message.header.requestId);
        callback(r.status );
        break;
      default:
        proxyError("Unexpected message type: ${message.header.type}");
        close(immediate: true);
        break;
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_LedgerProxyControl($superString)";
  }
}

class LedgerProxy
    extends bindings.Proxy<Ledger>
    implements Ledger,
               LedgerInterface,
               LedgerInterfaceRequest {
  LedgerProxy.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint)
      : super(new _LedgerProxyControl.fromEndpoint(endpoint));

  LedgerProxy.fromHandle(core.MojoHandle handle)
      : super(new _LedgerProxyControl.fromHandle(handle));

  LedgerProxy.unbound()
      : super(new _LedgerProxyControl.unbound());

  factory LedgerProxy.fromMock(Ledger mock) {
    LedgerProxy newMockedProxy =
        new LedgerProxy.unbound();
    newMockedProxy.impl = mock;
    return newMockedProxy;
  }

  static LedgerProxy newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For LedgerProxy"));
    return new LedgerProxy.fromEndpoint(endpoint);
  }


  void createSession(List<int> uuid,LedgerMutatorInterfaceRequest mutator,LedgerObserverInterface observer,void callback(LedgerStatus status)) {
    if (impl != null) {
      impl.createSession(uuid,mutator,observer,callback);
      return;
    }
    var params = new _LedgerCreateSessionParams();
    params.uuid = uuid;
    params.mutator = mutator;
    params.observer = observer;
    Function zonedCallback;
    if (identical(Zone.current, Zone.ROOT)) {
      zonedCallback = callback;
    } else {
      Zone z = Zone.current;
      zonedCallback = ((LedgerStatus status) {
        z.bindCallback(() {
          callback(status);
        })();
      });
    }
    ctrl.sendMessageWithRequestId(
        params,
        _ledgerMethodCreateSessionName,
        -1,
        bindings.MessageHeader.kMessageExpectsResponse,
        zonedCallback);
  }
  void connectToSession(List<int> uuid,LedgerMutatorInterfaceRequest mutator,LedgerObserverInterface observer,void callback(LedgerStatus status)) {
    if (impl != null) {
      impl.connectToSession(uuid,mutator,observer,callback);
      return;
    }
    var params = new _LedgerConnectToSessionParams();
    params.uuid = uuid;
    params.mutator = mutator;
    params.observer = observer;
    Function zonedCallback;
    if (identical(Zone.current, Zone.ROOT)) {
      zonedCallback = callback;
    } else {
      Zone z = Zone.current;
      zonedCallback = ((LedgerStatus status) {
        z.bindCallback(() {
          callback(status);
        })();
      });
    }
    ctrl.sendMessageWithRequestId(
        params,
        _ledgerMethodConnectToSessionName,
        -1,
        bindings.MessageHeader.kMessageExpectsResponse,
        zonedCallback);
  }
}

class _LedgerStubControl
    extends bindings.StubMessageHandler
    implements bindings.StubControl<Ledger> {
  Ledger _impl;

  _LedgerStubControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [Ledger impl])
      : super.fromEndpoint(endpoint, autoBegin: impl != null) {
    _impl = impl;
  }

  _LedgerStubControl.fromHandle(
      core.MojoHandle handle, [Ledger impl])
      : super.fromHandle(handle, autoBegin: impl != null) {
    _impl = impl;
  }

  _LedgerStubControl.unbound([this._impl]) : super.unbound();

  String get serviceName => Ledger.serviceName;


  Function _ledgerCreateSessionResponseParamsResponder(
      int requestId) {
  return (LedgerStatus status) {
      var result = new LedgerCreateSessionResponseParams();
      result.status = status;
      sendResponse(buildResponseWithId(
          result,
          _ledgerMethodCreateSessionName,
          requestId,
          bindings.MessageHeader.kMessageIsResponse));
    };
  }
  Function _ledgerConnectToSessionResponseParamsResponder(
      int requestId) {
  return (LedgerStatus status) {
      var result = new LedgerConnectToSessionResponseParams();
      result.status = status;
      sendResponse(buildResponseWithId(
          result,
          _ledgerMethodConnectToSessionName,
          requestId,
          bindings.MessageHeader.kMessageIsResponse));
    };
  }

  void handleMessage(bindings.ServiceMessage message) {
    if (bindings.ControlMessageHandler.isControlMessage(message)) {
      bindings.ControlMessageHandler.handleMessage(
          this, 0, message);
      return;
    }
    if (_impl == null) {
      throw new core.MojoApiError("$this has no implementation set");
    }
    switch (message.header.type) {
      case _ledgerMethodCreateSessionName:
        var params = _LedgerCreateSessionParams.deserialize(
            message.payload);
        _impl.createSession(params.uuid, params.mutator, params.observer, _ledgerCreateSessionResponseParamsResponder(message.header.requestId));
        break;
      case _ledgerMethodConnectToSessionName:
        var params = _LedgerConnectToSessionParams.deserialize(
            message.payload);
        _impl.connectToSession(params.uuid, params.mutator, params.observer, _ledgerConnectToSessionResponseParamsResponder(message.header.requestId));
        break;
      default:
        throw new bindings.MojoCodecError("Unexpected message name");
        break;
    }
  }

  Ledger get impl => _impl;
  set impl(Ledger d) {
    if (d == null) {
      throw new core.MojoApiError("$this: Cannot set a null implementation");
    }
    if (isBound && (_impl == null)) {
      beginHandlingEvents();
    }
    _impl = d;
  }

  @override
  void bind(core.MojoMessagePipeEndpoint endpoint) {
    super.bind(endpoint);
    if (!isOpen && (_impl != null)) {
      beginHandlingEvents();
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_LedgerStubControl($superString)";
  }

  int get version => 0;
}

class LedgerStub
    extends bindings.Stub<Ledger>
    implements Ledger,
               LedgerInterface,
               LedgerInterfaceRequest {
  LedgerStub.unbound([Ledger impl])
      : super(new _LedgerStubControl.unbound(impl));

  LedgerStub.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [Ledger impl])
      : super(new _LedgerStubControl.fromEndpoint(endpoint, impl));

  LedgerStub.fromHandle(
      core.MojoHandle handle, [Ledger impl])
      : super(new _LedgerStubControl.fromHandle(handle, impl));

  static LedgerStub newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For LedgerStub"));
    return new LedgerStub.fromEndpoint(endpoint);
  }


  void createSession(List<int> uuid,LedgerMutatorInterfaceRequest mutator,LedgerObserverInterface observer,void callback(LedgerStatus status)) {
    return impl.createSession(uuid,mutator,observer,callback);
  }
  void connectToSession(List<int> uuid,LedgerMutatorInterfaceRequest mutator,LedgerObserverInterface observer,void callback(LedgerStatus status)) {
    return impl.connectToSession(uuid,mutator,observer,callback);
  }
}



