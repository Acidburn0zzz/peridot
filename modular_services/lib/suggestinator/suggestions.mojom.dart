// Copyright 2016 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// WARNING: DO NOT EDIT. This file was generated by a program.
// See $MOJO_SDK/tools/bindings/mojom_bindings_generator.py.

library suggestions_mojom;
import 'dart:async';
import 'package:mojo/bindings.dart' as bindings;
import 'package:mojo/core.dart' as core;
import 'package:mojo/mojo/bindings/types/service_describer.mojom.dart' as service_describer;
import 'package:modular_services/common/uuid.mojom.dart' as uuid_mojom;



class Suggestion extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(40, 0)
  ];
  uuid_mojom.Uuid id = null;
  String description = null;
  bool createsNewSession = false;
  int themeColor = 0;
  String iconUrl = null;

  Suggestion() : super(kVersions.last.size);

  Suggestion.init(
    uuid_mojom.Uuid this.id, 
    String this.description, 
    bool this.createsNewSession, 
    int this.themeColor, 
    String this.iconUrl
  ) : super(kVersions.last.size);

  static Suggestion deserialize(bindings.Message message) {
    var decoder = new bindings.Decoder(message);
    var result = decode(decoder);
    if (decoder.excessHandles != null) {
      decoder.excessHandles.forEach((h) => h.close());
    }
    return result;
  }

  static Suggestion decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    Suggestion result = new Suggestion();

    var mainDataHeader = decoder0.decodeStructDataHeader();
    if (mainDataHeader.version <= kVersions.last.version) {
      // Scan in reverse order to optimize for more recent versions.
      for (int i = kVersions.length - 1; i >= 0; --i) {
        if (mainDataHeader.version >= kVersions[i].version) {
          if (mainDataHeader.size == kVersions[i].size) {
            // Found a match.
            break;
          }
          throw new bindings.MojoCodecError(
              'Header size doesn\'t correspond to known version size.');
        }
      }
    } else if (mainDataHeader.size < kVersions.last.size) {
      throw new bindings.MojoCodecError(
        'Message newer than the last known version cannot be shorter than '
        'required by the last known version.');
    }
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(8, false);
      result.id = uuid_mojom.Uuid.decode(decoder1);
    }
    if (mainDataHeader.version >= 0) {
      
      result.description = decoder0.decodeString(16, false);
    }
    if (mainDataHeader.version >= 0) {
      
      result.createsNewSession = decoder0.decodeBool(24, 0);
    }
    if (mainDataHeader.version >= 0) {
      
      result.themeColor = decoder0.decodeInt32(28);
    }
    if (mainDataHeader.version >= 0) {
      
      result.iconUrl = decoder0.decodeString(32, true);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    try {
      encoder0.encodeStruct(id, 8, false);
    } on bindings.MojoCodecError catch(e) {
      e.message = "Error encountered while encoding field "
          "id of struct Suggestion: $e";
      rethrow;
    }
    try {
      encoder0.encodeString(description, 16, false);
    } on bindings.MojoCodecError catch(e) {
      e.message = "Error encountered while encoding field "
          "description of struct Suggestion: $e";
      rethrow;
    }
    try {
      encoder0.encodeBool(createsNewSession, 24, 0);
    } on bindings.MojoCodecError catch(e) {
      e.message = "Error encountered while encoding field "
          "createsNewSession of struct Suggestion: $e";
      rethrow;
    }
    try {
      encoder0.encodeInt32(themeColor, 28);
    } on bindings.MojoCodecError catch(e) {
      e.message = "Error encountered while encoding field "
          "themeColor of struct Suggestion: $e";
      rethrow;
    }
    try {
      encoder0.encodeString(iconUrl, 32, true);
    } on bindings.MojoCodecError catch(e) {
      e.message = "Error encountered while encoding field "
          "iconUrl of struct Suggestion: $e";
      rethrow;
    }
  }

  String toString() {
    return "Suggestion("
           "id: $id" ", "
           "description: $description" ", "
           "createsNewSession: $createsNewSession" ", "
           "themeColor: $themeColor" ", "
           "iconUrl: $iconUrl" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["id"] = id;
    map["description"] = description;
    map["createsNewSession"] = createsNewSession;
    map["themeColor"] = themeColor;
    map["iconUrl"] = iconUrl;
    return map;
  }
}


class _SuggestionObserverOnSuggestionsUpdatedParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  List<Suggestion> suggestions = null;

  _SuggestionObserverOnSuggestionsUpdatedParams() : super(kVersions.last.size);

  _SuggestionObserverOnSuggestionsUpdatedParams.init(
    List<Suggestion> this.suggestions
  ) : super(kVersions.last.size);

  static _SuggestionObserverOnSuggestionsUpdatedParams deserialize(bindings.Message message) {
    var decoder = new bindings.Decoder(message);
    var result = decode(decoder);
    if (decoder.excessHandles != null) {
      decoder.excessHandles.forEach((h) => h.close());
    }
    return result;
  }

  static _SuggestionObserverOnSuggestionsUpdatedParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _SuggestionObserverOnSuggestionsUpdatedParams result = new _SuggestionObserverOnSuggestionsUpdatedParams();

    var mainDataHeader = decoder0.decodeStructDataHeader();
    if (mainDataHeader.version <= kVersions.last.version) {
      // Scan in reverse order to optimize for more recent versions.
      for (int i = kVersions.length - 1; i >= 0; --i) {
        if (mainDataHeader.version >= kVersions[i].version) {
          if (mainDataHeader.size == kVersions[i].size) {
            // Found a match.
            break;
          }
          throw new bindings.MojoCodecError(
              'Header size doesn\'t correspond to known version size.');
        }
      }
    } else if (mainDataHeader.size < kVersions.last.size) {
      throw new bindings.MojoCodecError(
        'Message newer than the last known version cannot be shorter than '
        'required by the last known version.');
    }
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(8, false);
      {
        var si1 = decoder1.decodeDataHeaderForPointerArray(bindings.kUnspecifiedArrayLength);
        result.suggestions = new List<Suggestion>(si1.numElements);
        for (int i1 = 0; i1 < si1.numElements; ++i1) {
          
          var decoder2 = decoder1.decodePointer(bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize * i1, false);
          result.suggestions[i1] = Suggestion.decode(decoder2);
        }
      }
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    try {
      if (suggestions == null) {
        encoder0.encodeNullPointer(8, false);
      } else {
        var encoder1 = encoder0.encodePointerArray(suggestions.length, 8, bindings.kUnspecifiedArrayLength);
        for (int i0 = 0; i0 < suggestions.length; ++i0) {
          encoder1.encodeStruct(suggestions[i0], bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize * i0, false);
        }
      }
    } on bindings.MojoCodecError catch(e) {
      e.message = "Error encountered while encoding field "
          "suggestions of struct _SuggestionObserverOnSuggestionsUpdatedParams: $e";
      rethrow;
    }
  }

  String toString() {
    return "_SuggestionObserverOnSuggestionsUpdatedParams("
           "suggestions: $suggestions" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["suggestions"] = suggestions;
    return map;
  }
}


class _SuggestionServiceAddObserverParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  SuggestionObserverInterface observer = null;

  _SuggestionServiceAddObserverParams() : super(kVersions.last.size);

  _SuggestionServiceAddObserverParams.init(
    SuggestionObserverInterface this.observer
  ) : super(kVersions.last.size);

  static _SuggestionServiceAddObserverParams deserialize(bindings.Message message) {
    var decoder = new bindings.Decoder(message);
    var result = decode(decoder);
    if (decoder.excessHandles != null) {
      decoder.excessHandles.forEach((h) => h.close());
    }
    return result;
  }

  static _SuggestionServiceAddObserverParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _SuggestionServiceAddObserverParams result = new _SuggestionServiceAddObserverParams();

    var mainDataHeader = decoder0.decodeStructDataHeader();
    if (mainDataHeader.version <= kVersions.last.version) {
      // Scan in reverse order to optimize for more recent versions.
      for (int i = kVersions.length - 1; i >= 0; --i) {
        if (mainDataHeader.version >= kVersions[i].version) {
          if (mainDataHeader.size == kVersions[i].size) {
            // Found a match.
            break;
          }
          throw new bindings.MojoCodecError(
              'Header size doesn\'t correspond to known version size.');
        }
      }
    } else if (mainDataHeader.size < kVersions.last.size) {
      throw new bindings.MojoCodecError(
        'Message newer than the last known version cannot be shorter than '
        'required by the last known version.');
    }
    if (mainDataHeader.version >= 0) {
      
      result.observer = decoder0.decodeServiceInterface(8, false, SuggestionObserverProxy.newFromEndpoint);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    try {
      encoder0.encodeInterface(observer, 8, false);
    } on bindings.MojoCodecError catch(e) {
      e.message = "Error encountered while encoding field "
          "observer of struct _SuggestionServiceAddObserverParams: $e";
      rethrow;
    }
  }

  String toString() {
    return "_SuggestionServiceAddObserverParams("
           "observer: $observer" ")";
  }

  Map toJson() {
    throw new bindings.MojoCodecError(
        'Object containing handles cannot be encoded to JSON.');
  }
}


class _SuggestionServiceSelectSuggestionParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  uuid_mojom.Uuid suggestionId = null;

  _SuggestionServiceSelectSuggestionParams() : super(kVersions.last.size);

  _SuggestionServiceSelectSuggestionParams.init(
    uuid_mojom.Uuid this.suggestionId
  ) : super(kVersions.last.size);

  static _SuggestionServiceSelectSuggestionParams deserialize(bindings.Message message) {
    var decoder = new bindings.Decoder(message);
    var result = decode(decoder);
    if (decoder.excessHandles != null) {
      decoder.excessHandles.forEach((h) => h.close());
    }
    return result;
  }

  static _SuggestionServiceSelectSuggestionParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _SuggestionServiceSelectSuggestionParams result = new _SuggestionServiceSelectSuggestionParams();

    var mainDataHeader = decoder0.decodeStructDataHeader();
    if (mainDataHeader.version <= kVersions.last.version) {
      // Scan in reverse order to optimize for more recent versions.
      for (int i = kVersions.length - 1; i >= 0; --i) {
        if (mainDataHeader.version >= kVersions[i].version) {
          if (mainDataHeader.size == kVersions[i].size) {
            // Found a match.
            break;
          }
          throw new bindings.MojoCodecError(
              'Header size doesn\'t correspond to known version size.');
        }
      }
    } else if (mainDataHeader.size < kVersions.last.size) {
      throw new bindings.MojoCodecError(
        'Message newer than the last known version cannot be shorter than '
        'required by the last known version.');
    }
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(8, false);
      result.suggestionId = uuid_mojom.Uuid.decode(decoder1);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    try {
      encoder0.encodeStruct(suggestionId, 8, false);
    } on bindings.MojoCodecError catch(e) {
      e.message = "Error encountered while encoding field "
          "suggestionId of struct _SuggestionServiceSelectSuggestionParams: $e";
      rethrow;
    }
  }

  String toString() {
    return "_SuggestionServiceSelectSuggestionParams("
           "suggestionId: $suggestionId" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["suggestionId"] = suggestionId;
    return map;
  }
}


class SuggestionServiceSelectSuggestionResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  String sessionId = null;

  SuggestionServiceSelectSuggestionResponseParams() : super(kVersions.last.size);

  SuggestionServiceSelectSuggestionResponseParams.init(
    String this.sessionId
  ) : super(kVersions.last.size);

  static SuggestionServiceSelectSuggestionResponseParams deserialize(bindings.Message message) {
    var decoder = new bindings.Decoder(message);
    var result = decode(decoder);
    if (decoder.excessHandles != null) {
      decoder.excessHandles.forEach((h) => h.close());
    }
    return result;
  }

  static SuggestionServiceSelectSuggestionResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    SuggestionServiceSelectSuggestionResponseParams result = new SuggestionServiceSelectSuggestionResponseParams();

    var mainDataHeader = decoder0.decodeStructDataHeader();
    if (mainDataHeader.version <= kVersions.last.version) {
      // Scan in reverse order to optimize for more recent versions.
      for (int i = kVersions.length - 1; i >= 0; --i) {
        if (mainDataHeader.version >= kVersions[i].version) {
          if (mainDataHeader.size == kVersions[i].size) {
            // Found a match.
            break;
          }
          throw new bindings.MojoCodecError(
              'Header size doesn\'t correspond to known version size.');
        }
      }
    } else if (mainDataHeader.size < kVersions.last.size) {
      throw new bindings.MojoCodecError(
        'Message newer than the last known version cannot be shorter than '
        'required by the last known version.');
    }
    if (mainDataHeader.version >= 0) {
      
      result.sessionId = decoder0.decodeString(8, true);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    try {
      encoder0.encodeString(sessionId, 8, true);
    } on bindings.MojoCodecError catch(e) {
      e.message = "Error encountered while encoding field "
          "sessionId of struct SuggestionServiceSelectSuggestionResponseParams: $e";
      rethrow;
    }
  }

  String toString() {
    return "SuggestionServiceSelectSuggestionResponseParams("
           "sessionId: $sessionId" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["sessionId"] = sessionId;
    return map;
  }
}

const int _suggestionObserverMethodOnSuggestionsUpdatedName = 0;

class _SuggestionObserverServiceDescription implements service_describer.ServiceDescription {
  void getTopLevelInterface(Function responder) {
    responder(null);
  }

  void getTypeDefinition(String typeKey, Function responder) {
    responder(null);
  }

  void getAllTypeDefinitions(Function responder) {
    responder(null);
  }
}

abstract class SuggestionObserver {
  static const String serviceName = null;

  static service_describer.ServiceDescription _cachedServiceDescription;
  static service_describer.ServiceDescription get serviceDescription {
    if (_cachedServiceDescription == null) {
      _cachedServiceDescription = new _SuggestionObserverServiceDescription();
    }
    return _cachedServiceDescription;
  }

  static SuggestionObserverProxy connectToService(
      bindings.ServiceConnector s, String url, [String serviceName]) {
    SuggestionObserverProxy p = new SuggestionObserverProxy.unbound();
    String name = serviceName ?? SuggestionObserver.serviceName;
    if ((name == null) || name.isEmpty) {
      throw new core.MojoApiError(
          "If an interface has no ServiceName, then one must be provided.");
    }
    s.connectToService(url, p, name);
    return p;
  }
  void onSuggestionsUpdated(List<Suggestion> suggestions);
}

abstract class SuggestionObserverInterface
    implements bindings.MojoInterface<SuggestionObserver>,
               SuggestionObserver {
  factory SuggestionObserverInterface([SuggestionObserver impl]) =>
      new SuggestionObserverStub.unbound(impl);

  factory SuggestionObserverInterface.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint,
      [SuggestionObserver impl]) =>
      new SuggestionObserverStub.fromEndpoint(endpoint, impl);

  factory SuggestionObserverInterface.fromMock(
      SuggestionObserver mock) =>
      new SuggestionObserverProxy.fromMock(mock);
}

abstract class SuggestionObserverInterfaceRequest
    implements bindings.MojoInterface<SuggestionObserver>,
               SuggestionObserver {
  factory SuggestionObserverInterfaceRequest() =>
      new SuggestionObserverProxy.unbound();
}

class _SuggestionObserverProxyControl
    extends bindings.ProxyMessageHandler
    implements bindings.ProxyControl<SuggestionObserver> {
  SuggestionObserver impl;

  _SuggestionObserverProxyControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) : super.fromEndpoint(endpoint);

  _SuggestionObserverProxyControl.fromHandle(
      core.MojoHandle handle) : super.fromHandle(handle);

  _SuggestionObserverProxyControl.unbound() : super.unbound();

  String get serviceName => SuggestionObserver.serviceName;

  void handleResponse(bindings.ServiceMessage message) {
    switch (message.header.type) {
      default:
        proxyError("Unexpected message type: ${message.header.type}");
        close(immediate: true);
        break;
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_SuggestionObserverProxyControl($superString)";
  }
}

class SuggestionObserverProxy
    extends bindings.Proxy<SuggestionObserver>
    implements SuggestionObserver,
               SuggestionObserverInterface,
               SuggestionObserverInterfaceRequest {
  SuggestionObserverProxy.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint)
      : super(new _SuggestionObserverProxyControl.fromEndpoint(endpoint));

  SuggestionObserverProxy.fromHandle(core.MojoHandle handle)
      : super(new _SuggestionObserverProxyControl.fromHandle(handle));

  SuggestionObserverProxy.unbound()
      : super(new _SuggestionObserverProxyControl.unbound());

  factory SuggestionObserverProxy.fromMock(SuggestionObserver mock) {
    SuggestionObserverProxy newMockedProxy =
        new SuggestionObserverProxy.unbound();
    newMockedProxy.impl = mock;
    return newMockedProxy;
  }

  static SuggestionObserverProxy newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For SuggestionObserverProxy"));
    return new SuggestionObserverProxy.fromEndpoint(endpoint);
  }


  void onSuggestionsUpdated(List<Suggestion> suggestions) {
    if (impl != null) {
      impl.onSuggestionsUpdated(suggestions);
      return;
    }
    if (!ctrl.isBound) {
      ctrl.proxyError("The Proxy is closed.");
      return;
    }
    var params = new _SuggestionObserverOnSuggestionsUpdatedParams();
    params.suggestions = suggestions;
    ctrl.sendMessage(params,
        _suggestionObserverMethodOnSuggestionsUpdatedName);
  }
}

class _SuggestionObserverStubControl
    extends bindings.StubMessageHandler
    implements bindings.StubControl<SuggestionObserver> {
  SuggestionObserver _impl;

  _SuggestionObserverStubControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [SuggestionObserver impl])
      : super.fromEndpoint(endpoint, autoBegin: impl != null) {
    _impl = impl;
  }

  _SuggestionObserverStubControl.fromHandle(
      core.MojoHandle handle, [SuggestionObserver impl])
      : super.fromHandle(handle, autoBegin: impl != null) {
    _impl = impl;
  }

  _SuggestionObserverStubControl.unbound([this._impl]) : super.unbound();

  String get serviceName => SuggestionObserver.serviceName;



  void handleMessage(bindings.ServiceMessage message) {
    if (bindings.ControlMessageHandler.isControlMessage(message)) {
      bindings.ControlMessageHandler.handleMessage(
          this, 0, message);
      return;
    }
    if (_impl == null) {
      throw new core.MojoApiError("$this has no implementation set");
    }
    switch (message.header.type) {
      case _suggestionObserverMethodOnSuggestionsUpdatedName:
        var params = _SuggestionObserverOnSuggestionsUpdatedParams.deserialize(
            message.payload);
        _impl.onSuggestionsUpdated(params.suggestions);
        break;
      default:
        throw new bindings.MojoCodecError("Unexpected message name");
        break;
    }
  }

  SuggestionObserver get impl => _impl;
  set impl(SuggestionObserver d) {
    if (d == null) {
      throw new core.MojoApiError("$this: Cannot set a null implementation");
    }
    if (isBound && (_impl == null)) {
      beginHandlingEvents();
    }
    _impl = d;
  }

  @override
  void bind(core.MojoMessagePipeEndpoint endpoint) {
    super.bind(endpoint);
    if (!isOpen && (_impl != null)) {
      beginHandlingEvents();
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_SuggestionObserverStubControl($superString)";
  }

  int get version => 0;
}

class SuggestionObserverStub
    extends bindings.Stub<SuggestionObserver>
    implements SuggestionObserver,
               SuggestionObserverInterface,
               SuggestionObserverInterfaceRequest {
  SuggestionObserverStub.unbound([SuggestionObserver impl])
      : super(new _SuggestionObserverStubControl.unbound(impl));

  SuggestionObserverStub.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [SuggestionObserver impl])
      : super(new _SuggestionObserverStubControl.fromEndpoint(endpoint, impl));

  SuggestionObserverStub.fromHandle(
      core.MojoHandle handle, [SuggestionObserver impl])
      : super(new _SuggestionObserverStubControl.fromHandle(handle, impl));

  static SuggestionObserverStub newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For SuggestionObserverStub"));
    return new SuggestionObserverStub.fromEndpoint(endpoint);
  }


  void onSuggestionsUpdated(List<Suggestion> suggestions) {
    return impl.onSuggestionsUpdated(suggestions);
  }
}

const int _suggestionServiceMethodAddObserverName = 0;
const int _suggestionServiceMethodSelectSuggestionName = 1;

class _SuggestionServiceServiceDescription implements service_describer.ServiceDescription {
  void getTopLevelInterface(Function responder) {
    responder(null);
  }

  void getTypeDefinition(String typeKey, Function responder) {
    responder(null);
  }

  void getAllTypeDefinitions(Function responder) {
    responder(null);
  }
}

abstract class SuggestionService {
  static const String serviceName = "suggestinator::SuggestionService";

  static service_describer.ServiceDescription _cachedServiceDescription;
  static service_describer.ServiceDescription get serviceDescription {
    if (_cachedServiceDescription == null) {
      _cachedServiceDescription = new _SuggestionServiceServiceDescription();
    }
    return _cachedServiceDescription;
  }

  static SuggestionServiceProxy connectToService(
      bindings.ServiceConnector s, String url, [String serviceName]) {
    SuggestionServiceProxy p = new SuggestionServiceProxy.unbound();
    String name = serviceName ?? SuggestionService.serviceName;
    if ((name == null) || name.isEmpty) {
      throw new core.MojoApiError(
          "If an interface has no ServiceName, then one must be provided.");
    }
    s.connectToService(url, p, name);
    return p;
  }
  void addObserver(SuggestionObserverInterface observer);
  void selectSuggestion(uuid_mojom.Uuid suggestionId,void callback(String sessionId));
}

abstract class SuggestionServiceInterface
    implements bindings.MojoInterface<SuggestionService>,
               SuggestionService {
  factory SuggestionServiceInterface([SuggestionService impl]) =>
      new SuggestionServiceStub.unbound(impl);

  factory SuggestionServiceInterface.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint,
      [SuggestionService impl]) =>
      new SuggestionServiceStub.fromEndpoint(endpoint, impl);

  factory SuggestionServiceInterface.fromMock(
      SuggestionService mock) =>
      new SuggestionServiceProxy.fromMock(mock);
}

abstract class SuggestionServiceInterfaceRequest
    implements bindings.MojoInterface<SuggestionService>,
               SuggestionService {
  factory SuggestionServiceInterfaceRequest() =>
      new SuggestionServiceProxy.unbound();
}

class _SuggestionServiceProxyControl
    extends bindings.ProxyMessageHandler
    implements bindings.ProxyControl<SuggestionService> {
  SuggestionService impl;

  _SuggestionServiceProxyControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) : super.fromEndpoint(endpoint);

  _SuggestionServiceProxyControl.fromHandle(
      core.MojoHandle handle) : super.fromHandle(handle);

  _SuggestionServiceProxyControl.unbound() : super.unbound();

  String get serviceName => SuggestionService.serviceName;

  void handleResponse(bindings.ServiceMessage message) {
    switch (message.header.type) {
      case _suggestionServiceMethodSelectSuggestionName:
        var r = SuggestionServiceSelectSuggestionResponseParams.deserialize(
            message.payload);
        if (!message.header.hasRequestId) {
          proxyError("Expected a message with a valid request Id.");
          return;
        }
        Function callback = callbackMap[message.header.requestId];
        if (callback == null) {
          proxyError(
              "Message had unknown request Id: ${message.header.requestId}");
          return;
        }
        callbackMap.remove(message.header.requestId);
        callback(r.sessionId );
        break;
      default:
        proxyError("Unexpected message type: ${message.header.type}");
        close(immediate: true);
        break;
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_SuggestionServiceProxyControl($superString)";
  }
}

class SuggestionServiceProxy
    extends bindings.Proxy<SuggestionService>
    implements SuggestionService,
               SuggestionServiceInterface,
               SuggestionServiceInterfaceRequest {
  SuggestionServiceProxy.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint)
      : super(new _SuggestionServiceProxyControl.fromEndpoint(endpoint));

  SuggestionServiceProxy.fromHandle(core.MojoHandle handle)
      : super(new _SuggestionServiceProxyControl.fromHandle(handle));

  SuggestionServiceProxy.unbound()
      : super(new _SuggestionServiceProxyControl.unbound());

  factory SuggestionServiceProxy.fromMock(SuggestionService mock) {
    SuggestionServiceProxy newMockedProxy =
        new SuggestionServiceProxy.unbound();
    newMockedProxy.impl = mock;
    return newMockedProxy;
  }

  static SuggestionServiceProxy newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For SuggestionServiceProxy"));
    return new SuggestionServiceProxy.fromEndpoint(endpoint);
  }


  void addObserver(SuggestionObserverInterface observer) {
    if (impl != null) {
      impl.addObserver(observer);
      return;
    }
    if (!ctrl.isBound) {
      ctrl.proxyError("The Proxy is closed.");
      return;
    }
    var params = new _SuggestionServiceAddObserverParams();
    params.observer = observer;
    ctrl.sendMessage(params,
        _suggestionServiceMethodAddObserverName);
  }
  void selectSuggestion(uuid_mojom.Uuid suggestionId,void callback(String sessionId)) {
    if (impl != null) {
      impl.selectSuggestion(suggestionId,callback);
      return;
    }
    var params = new _SuggestionServiceSelectSuggestionParams();
    params.suggestionId = suggestionId;
    Function zonedCallback;
    if (identical(Zone.current, Zone.ROOT)) {
      zonedCallback = callback;
    } else {
      Zone z = Zone.current;
      zonedCallback = ((String sessionId) {
        z.bindCallback(() {
          callback(sessionId);
        })();
      });
    }
    ctrl.sendMessageWithRequestId(
        params,
        _suggestionServiceMethodSelectSuggestionName,
        -1,
        bindings.MessageHeader.kMessageExpectsResponse,
        zonedCallback);
  }
}

class _SuggestionServiceStubControl
    extends bindings.StubMessageHandler
    implements bindings.StubControl<SuggestionService> {
  SuggestionService _impl;

  _SuggestionServiceStubControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [SuggestionService impl])
      : super.fromEndpoint(endpoint, autoBegin: impl != null) {
    _impl = impl;
  }

  _SuggestionServiceStubControl.fromHandle(
      core.MojoHandle handle, [SuggestionService impl])
      : super.fromHandle(handle, autoBegin: impl != null) {
    _impl = impl;
  }

  _SuggestionServiceStubControl.unbound([this._impl]) : super.unbound();

  String get serviceName => SuggestionService.serviceName;


  Function _suggestionServiceSelectSuggestionResponseParamsResponder(
      int requestId) {
  return (String sessionId) {
      var result = new SuggestionServiceSelectSuggestionResponseParams();
      result.sessionId = sessionId;
      sendResponse(buildResponseWithId(
          result,
          _suggestionServiceMethodSelectSuggestionName,
          requestId,
          bindings.MessageHeader.kMessageIsResponse));
    };
  }

  void handleMessage(bindings.ServiceMessage message) {
    if (bindings.ControlMessageHandler.isControlMessage(message)) {
      bindings.ControlMessageHandler.handleMessage(
          this, 0, message);
      return;
    }
    if (_impl == null) {
      throw new core.MojoApiError("$this has no implementation set");
    }
    switch (message.header.type) {
      case _suggestionServiceMethodAddObserverName:
        var params = _SuggestionServiceAddObserverParams.deserialize(
            message.payload);
        _impl.addObserver(params.observer);
        break;
      case _suggestionServiceMethodSelectSuggestionName:
        var params = _SuggestionServiceSelectSuggestionParams.deserialize(
            message.payload);
        _impl.selectSuggestion(params.suggestionId, _suggestionServiceSelectSuggestionResponseParamsResponder(message.header.requestId));
        break;
      default:
        throw new bindings.MojoCodecError("Unexpected message name");
        break;
    }
  }

  SuggestionService get impl => _impl;
  set impl(SuggestionService d) {
    if (d == null) {
      throw new core.MojoApiError("$this: Cannot set a null implementation");
    }
    if (isBound && (_impl == null)) {
      beginHandlingEvents();
    }
    _impl = d;
  }

  @override
  void bind(core.MojoMessagePipeEndpoint endpoint) {
    super.bind(endpoint);
    if (!isOpen && (_impl != null)) {
      beginHandlingEvents();
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_SuggestionServiceStubControl($superString)";
  }

  int get version => 0;
}

class SuggestionServiceStub
    extends bindings.Stub<SuggestionService>
    implements SuggestionService,
               SuggestionServiceInterface,
               SuggestionServiceInterfaceRequest {
  SuggestionServiceStub.unbound([SuggestionService impl])
      : super(new _SuggestionServiceStubControl.unbound(impl));

  SuggestionServiceStub.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [SuggestionService impl])
      : super(new _SuggestionServiceStubControl.fromEndpoint(endpoint, impl));

  SuggestionServiceStub.fromHandle(
      core.MojoHandle handle, [SuggestionService impl])
      : super(new _SuggestionServiceStubControl.fromHandle(handle, impl));

  static SuggestionServiceStub newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For SuggestionServiceStub"));
    return new SuggestionServiceStub.fromEndpoint(endpoint);
  }


  void addObserver(SuggestionObserverInterface observer) {
    return impl.addObserver(observer);
  }
  void selectSuggestion(uuid_mojom.Uuid suggestionId,void callback(String sessionId)) {
    return impl.selectSuggestion(suggestionId,callback);
  }
}



