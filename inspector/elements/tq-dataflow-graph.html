<!-- Copyright 2016 The Fuchsia Authors. All rights reserved. -->

<script src="../scripts/dataflow.js"></script>

<script src="../scripts/dataflow.js"></script>

<dom-module id="tq-dataflow-graph">
    <template>
      <style>
      :host {
        font: 10px sans-serif;
      }

      /* Common styles */

      text {
        pointer-events: none;
      }

      .node circle {
        fill: #fff;
        stroke: steelblue;
        stroke-width: 1.5px;
        transition: stroke-width 0.2s;
      }

      .node:hover circle {
        stroke-width: 2.5px;
      }

      .link {
        fill: none;
        stroke-width: 2.5px;
        transition: stroke-width 0.2s;
      }

      .link:hover {
        stroke-width: 4.5px;
      }

      /* Session nodes */

      .node.session circle {
        stroke: var(--paper-blue-grey-400);
        fill: var(--paper-blue-grey-100);
        r: 4.5px;
      }

      /* Session edges */
      #sessionMarker {
        fill: var(--paper-blue-grey-400);
      }
      .link.session {
        stroke: var(--paper-blue-grey-100);
        marker-mid: url(#sessionMarker);
      }
      .link.session:hover {
        stroke: var(--paper-blue-grey-400);
      }

      /* Data flow */

      #ioMarker {
        fill: var(--paper-cyan-400);
      }

      .link.input,
      .link.output {
        stroke: var(--paper-cyan-100);
        marker-mid: url(#ioMarker);
      }
      .link.input:hover,
      .link.output:hover {
        stroke: var(--paper-cyan-400);
      }

      /* Composition flow  */

      #cdMarker {
        fill: var(--paper-amber-400);
      }

      .link.compose,
      .link.display {
        stroke: var(--paper-amber-100);
        marker-mid: url(#cdMarker);
      }
      .compose:hover,
      .display:hover {
        stroke: var(--paper-amber-400);
      }

      /* Instance nodes */

      .node.instance circle {
        stroke: var(--paper-blue-grey-400);
        fill: white;
        r: 10px;
      }
      .node.instance text {
        opacity: 0.5;
        transition: opacity 0.2s;
      }
      .node.instance:hover text {
        opacity: 1;
      }

      /* Floating labels */

      #labels {
        pointer-events: none;
        transition: opacity 0.2s;
        opacity: 0;
      }

      #labels text {
      }

      #above {
        transform: translateY(-10px);
        text-anchor: middle;
      }

      #left {
        transform: translate(-10px, 3px);
        text-anchor: end;
      }

      #right {
        transform: translate(10px, 3px);
        text-anchor: start;
      }

      #below {
        transform: translateY(16px);
        text-anchor: middle;
      }

      </style>
      <tq-graph-utils id="utils" width="[[width]]" height="[[height]]">
      </tq-graph-utils>
      <svg id="svg" xmlns="http://www.w3.org/2000/svg" version="1.1"
          width="[[width]]" height="[[height]]"
          pointer-events="all">
        <defs>
          <symbol id="triangle">
            <path d="M 0 0 L 10 5 L 0 10 z" />
          </symbol>
          <marker id="ioMarker"
                  viewBox="0 0 10 10"
                  refX="5" refY="5"
                  markerWidth="5"
                  markerHeight="5"
                  orient="auto">
            <use xlink:href="#triangle"></use>
          </marker>
          <marker id="cdMarker"
                  viewBox="0 0 10 10"
                  refX="5" refY="5"
                  markerWidth="5"
                  markerHeight="5"
                  orient="auto">
            <use xlink:href="#triangle"></use>
          </marker>
          <marker id="sessionMarker"
                  viewBox="0 0 10 10"
                  refX="5" refY="5"
                  markerWidth="5"
                  markerHeight="5"
                  orient="auto">
            <use xlink:href="#triangle"></use>
          </marker>
        </defs>
        <g id="panzoom">
          <g id="container">
            <g id="links">
            </g>
            <g id="nodes">
            </g>
          </g>
        </g>
        <g id="labels">
          <text id="above"></text>
          <text id="below"></text>
          <text id="left"></text>
          <text id="right"></text>
        </g>
      </svg>
      <div id="controls">
        <paper-checkbox checked="{{wholeSession}}">Whole Session</paper-checkbox>
        <paper-checkbox checked="{{showIO}}">Inputs &amp; Outputs</paper-checkbox>
        <paper-checkbox checked="{{showCD}}">Composes &amp; Displays</paper-checkbox>
      </div>
    </template>
    <script>

    (function() {
      'use strict';

      let abbreviateUrl = (url) =>
          url ? url.replace(/.*\//, '').replace(/\..*/, '') : null;

      function buildInstanceGraph(sessionJSON, config) {
        let modulesJSON = sessionJSON.modules;
        let nodes = sessionJSON.graph.nodes;

        let dfgNodes = new Array();
        let dfgEdges = new Array();
        let dfgSessionNodes = new Map();

        let sessionNode = (id) => {
          if (dfgSessionNodes.has(id)) {
            return dfgSessionNodes.get(id);
          }
          let graphNode = nodes[id];
          let reprType = Object.getOwnPropertyNames(graphNode.values)[0];
          let valueUri = graphNode.values[reprType];
          let value = valueUri?atob(valueUri.substr(13)):'';
          let node = {
            id: id,
            type: 'session',
            value: value,
            labelLeft: abbreviateUrl(reprType),
            labelRight: value,
          };
          dfgNodes.push(node);
          dfgSessionNodes.set(id, node);
          return node;
        }

        let modules = moduleDataflow(sessionJSON);

        modules.forEach((module) => {
          module.instances.forEach((instance) => {
            let dfgInstance = {
              type: 'instance',
              id: `instance:${module.url}:${instance.id}`,
              label: `${module.label}#${instance.id}`,
            };
            dfgNodes.push(dfgInstance);

            function addIOs(ios, type, outward) {
              ios.forEach((nodes, pathExpr) => {
                function ioEdge(node) {
                  let edge = {
                    id: `${type}:${dfgInstance.id}:${pathExpr}:${node.id}`,
                    type: type,
                    labelAbove: pathExpr
                  };
                  if (outward) {
                    edge.source = dfgInstance;
                    edge.target = node;
                  } else {
                    edge.source = node;
                    edge.target = dfgInstance;
                  }
                  dfgEdges.push(edge);
                }
                if (nodes.size) {
                  nodes.forEach((id) => ioEdge(sessionNode(id)));
                } else {
                  let dfgDisconnected = {
                    type: 'disconnected',
                    id: `${type}${dfgInstance.id}:${pathExpr}::disconnected`,
                  };
                  dfgNodes.push(dfgDisconnected);
                  ioEdge(dfgDisconnected);
                }
              });
            }

            if (config.io) {
              addIOs(instance.inputs, 'input', false);
              addIOs(instance.outputs, 'output', true);
            }
            if (config.cd) {
              addIOs(instance.composes, 'compose', false);
              addIOs(instance.displays, 'display', true);
            }
          });
        });

        // Find all nodes in the metadata tree.
        let subtree = new Map();
        let metadataRoot = sessionJSON.metadataNode.id;
        Object.getOwnPropertyNames(sessionJSON.graph.edges).forEach((eId) => {
          let edge = sessionJSON.graph.edges[eId];
          if (edge.target == metadataRoot) {
            // Ignore edges to the metadata node.
            return;
          }
          let set = subtree.get(edge.origin) || new Set([edge.origin]);
          set.add(edge.target);
          (subtree.get(edge.target) || []).forEach((id) => set.add(id));
          subtree.set(edge.origin, set);
          subtree.set(edge.target, set);
        });
        let metadataNodes = subtree.get(metadataRoot);

        // Track labels on session edges to nodes.
        let sessionLabels = new Map();
        // Add session graph edges between session graph nodes that are in the
        // dataflow graph.
        let dataflowSessionNodes = new Set(dfgSessionNodes.keys());
        Object.getOwnPropertyNames(sessionJSON.graph.edges).forEach((eId) => {
          let edge = sessionJSON.graph.edges[eId];

          // Collect labels for session nodes.
          if (!sessionLabels.has(edge.target)) {
            sessionLabels.set(edge.target, new Set());
          }
          edge.labels.forEach((l) => sessionLabels.get(edge.target).add(l));

          // Ignore edges from the root node.
          if (edge.origin == sessionJSON.rootNode.id) {
            return;
          }

          // Ignore edges in the metadata tree.
          if (!metadataNodes || metadataNodes.has(edge.origin)) {
            return;
          }

          if (!config.wholeSession) {
            // Ignore nodes that aren't between data directly referenced by
            // module inputs & outputs.
            if (!dataflowSessionNodes.has(edge.origin) ||
                !dataflowSessionNodes.has(edge.target)) {
                  return;
            }
          }

          // Add a session data edge.
          dfgEdges.push({
            source: sessionNode(edge.origin),
            target: sessionNode(edge.target),
            labelAbove: edge.labels.map(abbreviateUrl).join(' '),
            type: 'session',
          });
        });

        // Give the session nodes a visual label based on their semantic label.
        for (let n of dfgSessionNodes.values()) {
          n.labelAbove =
              Array.from(sessionLabels.get(n.id), abbreviateUrl).join(' ');
        }

        return {
          nodes: dfgNodes,
          links: dfgEdges,
        };
      }

      Polymer({
        is: 'tq-dataflow-graph',
        properties: {
            json: Object,
            width: {
                type: Number,
                value: 800,
                observer: '_jsonChanged',
            },
            height: {
                type: Number,
                value: 600,
            },
            wholeSession: {
              type: Boolean,
              value: false,
            },
            showIO: {
              type: Boolean,
              value: true,
            },
            showCD: {
              type: Boolean,
              value: true,
            },
        },
        observers: [
          'rebuild(json, wholeSession, showIO, showCD)',
        ],
        ready: function() {
          this.$.utils.root = this.$.svg;
          this.$.utils.container = this.$.panzoom;

          this.force = d3.layout.force()
              .charge(-600)
              .linkDistance((link) => {
                if (link.type == 'session') {
                  return 30;
                } else {
                  return 60;
                }
          });


          this.scopeSubtree(this.$.container, true);
        },
        _jsonChanged: function() {
          // If we get rapid-fire updates from the server don't try to rebuild
          // the graph for each one.
          this.debounce('rebuild', () => this.rebuild(), 500);
        },
        rebuild: function() {
          let container = d3.select(this.$.container);
          let element = this; // For callbacks...

          let config = {
            'io': this.showIO,
            'cd': this.showCD,
            'wholeSession': this.wholeSession,
          }
          let graph = buildInstanceGraph(this.json, config);

          let nodes = graph.nodes;
          let links = graph.links;

          // Take the current (x,y) for existing nodes.
          nodes.forEach((node) => {
            let element = document.getElementById(node.id);
            if (element && element.__data__) {
              node.x = element.__data__.x;
              node.y = element.__data__.y;
            }
          });

          this.force.nodes(nodes).links(links).start();

          let displayLabels = (e, d) => {
            if (d) {
              this.$.above.textContent = d.labelAbove || '';
              this.$.below.textContent = d.labelBelow || '';
              this.$.left.textContent = d.labelLeft || '';
              this.$.right.textContent = d.labelRight || '';
              this.$.labels.style.opacity = 1;
            } else {
              this.$.labels.style.opacity = 0;
            }
            if (e != null) {
              let bbox = e.getBBox();
              let matrix = e.getCTM().translate(bbox.x + bbox.width/2,
                bbox.y + bbox.height/2);
              let transform = this.$.svg.createSVGTransformFromMatrix(matrix);
              this.$.labels.transform.baseVal.initialize(transform);
            }
          }

          let link = d3.select(this.$.links).selectAll(".link").data(links, (d) => d.id);
          let linkEnter = link.enter()
              .append('polyline')
              .attr("class", (d) => `link ${d.type}`)
              .on('mouseenter', (d) => displayLabels(d3.event.target, d))
              .on('mouseleave', (d) => displayLabels(d3.event.target, null));
          let linkExit = link.exit();
          linkExit.remove();

          let node = d3.select(this.$.nodes).selectAll(".node").data(nodes, (d) => d.id);

          let nodeEnter = node.enter()
              .append('g')
              .attr('id', (d) => d.id)
              .attr('class', (d) => `node ${d.type}`)
              .on('mouseenter', (d) => displayLabels(d3.event.target, d))
              .on('mouseleave', (d) => displayLabels(d3.event.target, null));
          let nodeExit = node.exit();
          nodeExit.remove();

          nodeEnter.append('circle');

          nodeEnter.append('text')
              .attr('text-anchor', 'middle')
              .attr('dy', '3')
              .attr('class', 'label')
              .text((d) => d.label);

          this.force.on('tick', () => {
            link.attr('points', (d) =>
              `${d.source.x},${d.source.y} ` +
              `${(d.source.x+d.target.x)/2},${(d.source.y+d.target.y)/2} ` +
              `${d.target.x},${d.target.y}`);
            node.attr("transform", (d) => `translate(${d.x}, ${d.y})`);

          });
        }
      });
    })();
    </script>
</dom-module>
