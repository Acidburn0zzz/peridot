// Copyright 2016 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'dart:async';
import 'dart:io';

import 'package:path/path.dart' as path;
import 'package:yaml/yaml.dart';

import 'base/file_system.dart';
import 'configuration.dart';

class StampAndDeps {
  File stamp;
  List<File> deps;
}

Future<StampAndDeps> getStampAndDeps(EnvironmentConfiguration environment,
    ProjectConfiguration project, String token,
    {List<File> extraDeps}) async {
  // When there are no targets, the snapshotter doesn't run and generate a
  // deps file for us. So instead, we pessimistically consider all dart files
  // in the project as well as its packages/ as dependencies.
  if (project.targets == null || project.targets.isEmpty) {
    final String outputName = path.basename(project.projectRoot);
    final List<File> deps = await findFilesAndFilter(
            project.projectRoot, '.dart', const ['/.pub', '/cache'],
            followLinks: true)
        .toList();
    if (extraDeps != null) {
      deps.addAll(extraDeps);
    }
    return new StampAndDeps()
      ..stamp = new File(
          path.join(environment.buildDir, outputName + '.$token.stamp'))
      ..deps = deps;
  }

  // When there are targets, we calculate dependencies as the union of all
  // snapshot dependency file and the stamp file name is based on all the
  // output names.
  String baseStampName = "";
  Set<File> deps = new Set<File>();
  for (YamlMap target in project.targets) {
    final String outputName = target['output_name'];
    baseStampName += outputName + '.';
    deps.addAll(await parseDependenciesFile(
        new File(path.join(environment.buildDir, outputName + '.d')),
        extraDeps));
  }
  return new StampAndDeps()
    ..stamp = new File(
        path.join(environment.buildDir, baseStampName + '$token.stamp'))
    ..deps = deps.toList();
}

// All pub commands touch the .packages and pubspec.lock files, even when
// they're not changed. This would cause requiresRebuild to think that things
// have changed too often. So instead, we parse the first line of the .packages
// file which correctly lists the generation timestamp.
Future<DateTime> _getDotPackagesFileTimestamp(File dotPackagesFile) async {
  final List<String> lines = await dotPackagesFile.readAsLines();
  // Example: `# Generated by pub on 2016-03-28 15:00:01.545081.`
  String firstLine = lines[0];
  firstLine = firstLine.replaceFirst("# Generated by pub on ", "");
  firstLine = firstLine.substring(0, firstLine.length - 1);
  return DateTime.parse(firstLine);
}

/// Parses a dependencies file in the format generated by the dart snapshotter.
Future<List<File>> parseDependenciesFile(File dependenciesFile,
    [List<File> additionalDependencies]) async {
  if (!(await dependenciesFile.exists())) {
    return null;
  }
  final String depsFileContent = await dependenciesFile.readAsString();
  final List<File> dependencies = depsFileContent
      .split(" ")
      .where((String path) => !path.endsWith("/.packages"))
      .map((String path) => new File(path))
      .toList();
  dependencies.removeAt(0);
  if (additionalDependencies != null) {
    dependencies.addAll(additionalDependencies);
  }
  return dependencies;
}

/// Determines whether any of |dependencies| or the |dotPackagesFile| are more
/// recent than the |outputFile|.
Future<bool> requiresRebuild(
    File outputFile, List<File> dependencies, File dotPackagesFile) async {
  if (dependencies == null ||
      !(await outputFile.exists()) ||
      !(await dotPackagesFile.exists())) {
    return true;
  }

  Future<DateTime> outputFileTimestamp = outputFile.lastModified();
  bool missingDep = false;
  final List<DateTime> depsTimeStamps =
      (await Future.wait(dependencies.map((File dependency) async {
    if (!(await dependency.exists())) {
      missingDep = true;
      return null;
    }
    return dependency.lastModified();
  })))
          .toList();
  depsTimeStamps.add(await _getDotPackagesFileTimestamp(dotPackagesFile));

  // We need to re-build if atleast one dependency has been removed.
  if (missingDep) {
    return true;
  }

  // We need to re-build if atleast one dependency has changed after the
  // output was produced.
  final maxDepsTimeStamp = depsTimeStamps.reduce((max, timeStamp) {
    if (max.compareTo(timeStamp) > 0) {
      return max;
    }
    return timeStamp;
  });
  if (maxDepsTimeStamp.compareTo(await outputFileTimestamp) >= 0) {
    return true;
  }
  return false;
}
