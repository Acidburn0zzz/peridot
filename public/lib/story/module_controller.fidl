// Copyright 2016 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

module modular;

// This interface is used by the caller of Story.StartModule() to
// control the started Module instance.
//
// Closing this connection affects neither its ModuleWatchers nor its
// Module instance; it just relinquishes the ability of the caller to
// control the Module instance.
interface ModuleController {
  // Registers a watcher that is notified when the module is done or
  // otherwise stops.
  Watch(ModuleWatcher watcher);

  // Requests the Module instance to stop (see Module.Stop() for how).
  Stop() => ();
};

// This interface is implemented by the client calling
// ModuleController::Watch().
interface ModuleWatcher {
  // Called with the current state right after registration, and
  // subsequently when the state changes.
  OnStateChange(ModuleState new_state);
};

// State used to notify ModuleWatcher about state transitions of a
// Module instance. This is very similar to the StoryState, however
// it's not entirely the same and hence a separate type. The
// ModuleState of the root module mostly drives the StoryState of the
// whole story, but in the future we expect them to diverge more.
// Right now, a module cannot have an INITIAL state, because it's
// started as soon as it is created, and it gets deleted as soon as it
// reaches the STOPPED state, whileas a story can be restarted.
//
// Currently possible state transitions are:
//
//   STARTING -> RUNNING
//   STARTING -> DONE
//   STARTING -> STOPPED
//   STARTING -> ERROR
//   RUNNING  -> DONE
//   RUNNING  -> STOPPED
//   RUNNING  -> ERROR
//   DONE     -> STOPPED
//
enum ModuleState {
  // Module instance was requested from the Story.
  STARTING = 1,
  // Module instance called Ready() on its Story handle.
  RUNNING = 2,
  // Module instance called Done() on its Story handle. The receiver
  // is free to decide whether it's appropriate to Stop() the module.
  // (It might be appropriate for the receiver to call Done() on its
  // own instead.) The module, conversely, is free to continue
  // running, but it should not close it's connection, as that would
  // transition it to ERROR.
  DONE = 3,
  // Module instance is stopped after Module.Stop(). The module can
  // now close its connection without transition to ERROR. No further
  // transitions are to be expected.
  STOPPED = 4,
  // Connection to the Module instance was closed without Stop()
  // request. No further transitions are to be expected.
  ERROR = 5,
};
