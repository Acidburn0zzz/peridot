// Copyright 2016 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// WARNING: DO NOT EDIT. This file was generated by a program.
// See $MOJO_SDK/tools/bindings/mojom_bindings_generator.py.

library handler_mojom;
import 'dart:async';
import 'package:mojo/bindings.dart' as bindings;
import 'package:mojo/core.dart' as core;
import 'package:mojo/mojo/bindings/types/service_describer.mojom.dart' as service_describer;
import 'package:modular/modular/graph.mojom.dart' as graph_mojom;

class HandlerStatus extends bindings.MojoEnum {
  static const HandlerStatus ok = const HandlerStatus._(0);
  static const HandlerStatus invalidArguments = const HandlerStatus._(1);
  static const HandlerStatus invalidJson = const HandlerStatus._(2);
  static const HandlerStatus invalidRecipe = const HandlerStatus._(3);
  static const HandlerStatus invalidSessionId = const HandlerStatus._(4);
  static const HandlerStatus notSupported = const HandlerStatus._(5);

  const HandlerStatus._(int v) : super(v);

  static const Map<String, HandlerStatus> valuesMap = const {
    "ok": ok,
    "invalidArguments": invalidArguments,
    "invalidJson": invalidJson,
    "invalidRecipe": invalidRecipe,
    "invalidSessionId": invalidSessionId,
    "notSupported": notSupported,
  };
  static const List<HandlerStatus> values = const [
    ok,
    invalidArguments,
    invalidJson,
    invalidRecipe,
    invalidSessionId,
    notSupported,
  ];

  static HandlerStatus valueOf(String name) => valuesMap[name];

  factory HandlerStatus(int v) {
    switch (v) {
      case 0:
        return HandlerStatus.ok;
      case 1:
        return HandlerStatus.invalidArguments;
      case 2:
        return HandlerStatus.invalidJson;
      case 3:
        return HandlerStatus.invalidRecipe;
      case 4:
        return HandlerStatus.invalidSessionId;
      case 5:
        return HandlerStatus.notSupported;
      default:
        return null;
    }
  }

  static HandlerStatus decode(bindings.Decoder decoder0, int offset) {
    int v = decoder0.decodeUint32(offset);
    HandlerStatus result = new HandlerStatus(v);
    if (result == null) {
      throw new bindings.MojoCodecError(
          'Bad value $v for enum HandlerStatus.');
    }
    return result;
  }

  String toString() {
    switch(this) {
      case ok:
        return 'HandlerStatus.ok';
      case invalidArguments:
        return 'HandlerStatus.invalidArguments';
      case invalidJson:
        return 'HandlerStatus.invalidJson';
      case invalidRecipe:
        return 'HandlerStatus.invalidRecipe';
      case invalidSessionId:
        return 'HandlerStatus.invalidSessionId';
      case notSupported:
        return 'HandlerStatus.notSupported';
      default:
        return null;
    }
  }

  int toJson() => mojoEnumValue;
}



class _HandlerServiceCreateSessionParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  String recipe = null;

  _HandlerServiceCreateSessionParams() : super(kVersions.last.size);

  _HandlerServiceCreateSessionParams.init(
    String this.recipe
  ) : super(kVersions.last.size);

  static _HandlerServiceCreateSessionParams deserialize(bindings.Message message) {
    var decoder = new bindings.Decoder(message);
    var result = decode(decoder);
    if (decoder.excessHandles != null) {
      decoder.excessHandles.forEach((h) => h.close());
    }
    return result;
  }

  static _HandlerServiceCreateSessionParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _HandlerServiceCreateSessionParams result = new _HandlerServiceCreateSessionParams();

    var mainDataHeader = decoder0.decodeStructDataHeader();
    if (mainDataHeader.version <= kVersions.last.version) {
      // Scan in reverse order to optimize for more recent versions.
      for (int i = kVersions.length - 1; i >= 0; --i) {
        if (mainDataHeader.version >= kVersions[i].version) {
          if (mainDataHeader.size == kVersions[i].size) {
            // Found a match.
            break;
          }
          throw new bindings.MojoCodecError(
              'Header size doesn\'t correspond to known version size.');
        }
      }
    } else if (mainDataHeader.size < kVersions.last.size) {
      throw new bindings.MojoCodecError(
        'Message newer than the last known version cannot be shorter than '
        'required by the last known version.');
    }
    if (mainDataHeader.version >= 0) {
      
      result.recipe = decoder0.decodeString(8, true);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    try {
      encoder0.encodeString(recipe, 8, true);
    } on bindings.MojoCodecError catch(e) {
      e.message = "Error encountered while encoding field "
          "recipe of struct _HandlerServiceCreateSessionParams: $e";
      rethrow;
    }
  }

  String toString() {
    return "_HandlerServiceCreateSessionParams("
           "recipe: $recipe" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["recipe"] = recipe;
    return map;
  }
}


class HandlerServiceCreateSessionResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(24, 0)
  ];
  HandlerStatus status = null;
  String sessionId = null;

  HandlerServiceCreateSessionResponseParams() : super(kVersions.last.size);

  HandlerServiceCreateSessionResponseParams.init(
    HandlerStatus this.status, 
    String this.sessionId
  ) : super(kVersions.last.size);

  static HandlerServiceCreateSessionResponseParams deserialize(bindings.Message message) {
    var decoder = new bindings.Decoder(message);
    var result = decode(decoder);
    if (decoder.excessHandles != null) {
      decoder.excessHandles.forEach((h) => h.close());
    }
    return result;
  }

  static HandlerServiceCreateSessionResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    HandlerServiceCreateSessionResponseParams result = new HandlerServiceCreateSessionResponseParams();

    var mainDataHeader = decoder0.decodeStructDataHeader();
    if (mainDataHeader.version <= kVersions.last.version) {
      // Scan in reverse order to optimize for more recent versions.
      for (int i = kVersions.length - 1; i >= 0; --i) {
        if (mainDataHeader.version >= kVersions[i].version) {
          if (mainDataHeader.size == kVersions[i].size) {
            // Found a match.
            break;
          }
          throw new bindings.MojoCodecError(
              'Header size doesn\'t correspond to known version size.');
        }
      }
    } else if (mainDataHeader.size < kVersions.last.size) {
      throw new bindings.MojoCodecError(
        'Message newer than the last known version cannot be shorter than '
        'required by the last known version.');
    }
    if (mainDataHeader.version >= 0) {
      
        result.status = HandlerStatus.decode(decoder0, 8);
        if (result.status == null) {
          throw new bindings.MojoCodecError(
            'Trying to decode null union for non-nullable HandlerStatus.');
        }
    }
    if (mainDataHeader.version >= 0) {
      
      result.sessionId = decoder0.decodeString(16, true);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    try {
      encoder0.encodeEnum(status, 8);
    } on bindings.MojoCodecError catch(e) {
      e.message = "Error encountered while encoding field "
          "status of struct HandlerServiceCreateSessionResponseParams: $e";
      rethrow;
    }
    try {
      encoder0.encodeString(sessionId, 16, true);
    } on bindings.MojoCodecError catch(e) {
      e.message = "Error encountered while encoding field "
          "sessionId of struct HandlerServiceCreateSessionResponseParams: $e";
      rethrow;
    }
  }

  String toString() {
    return "HandlerServiceCreateSessionResponseParams("
           "status: $status" ", "
           "sessionId: $sessionId" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["status"] = status;
    map["sessionId"] = sessionId;
    return map;
  }
}


class _HandlerServiceRestoreSessionParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  String sessionId = null;

  _HandlerServiceRestoreSessionParams() : super(kVersions.last.size);

  _HandlerServiceRestoreSessionParams.init(
    String this.sessionId
  ) : super(kVersions.last.size);

  static _HandlerServiceRestoreSessionParams deserialize(bindings.Message message) {
    var decoder = new bindings.Decoder(message);
    var result = decode(decoder);
    if (decoder.excessHandles != null) {
      decoder.excessHandles.forEach((h) => h.close());
    }
    return result;
  }

  static _HandlerServiceRestoreSessionParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _HandlerServiceRestoreSessionParams result = new _HandlerServiceRestoreSessionParams();

    var mainDataHeader = decoder0.decodeStructDataHeader();
    if (mainDataHeader.version <= kVersions.last.version) {
      // Scan in reverse order to optimize for more recent versions.
      for (int i = kVersions.length - 1; i >= 0; --i) {
        if (mainDataHeader.version >= kVersions[i].version) {
          if (mainDataHeader.size == kVersions[i].size) {
            // Found a match.
            break;
          }
          throw new bindings.MojoCodecError(
              'Header size doesn\'t correspond to known version size.');
        }
      }
    } else if (mainDataHeader.size < kVersions.last.size) {
      throw new bindings.MojoCodecError(
        'Message newer than the last known version cannot be shorter than '
        'required by the last known version.');
    }
    if (mainDataHeader.version >= 0) {
      
      result.sessionId = decoder0.decodeString(8, false);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    try {
      encoder0.encodeString(sessionId, 8, false);
    } on bindings.MojoCodecError catch(e) {
      e.message = "Error encountered while encoding field "
          "sessionId of struct _HandlerServiceRestoreSessionParams: $e";
      rethrow;
    }
  }

  String toString() {
    return "_HandlerServiceRestoreSessionParams("
           "sessionId: $sessionId" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["sessionId"] = sessionId;
    return map;
  }
}


class HandlerServiceRestoreSessionResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  HandlerStatus status = null;

  HandlerServiceRestoreSessionResponseParams() : super(kVersions.last.size);

  HandlerServiceRestoreSessionResponseParams.init(
    HandlerStatus this.status
  ) : super(kVersions.last.size);

  static HandlerServiceRestoreSessionResponseParams deserialize(bindings.Message message) {
    var decoder = new bindings.Decoder(message);
    var result = decode(decoder);
    if (decoder.excessHandles != null) {
      decoder.excessHandles.forEach((h) => h.close());
    }
    return result;
  }

  static HandlerServiceRestoreSessionResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    HandlerServiceRestoreSessionResponseParams result = new HandlerServiceRestoreSessionResponseParams();

    var mainDataHeader = decoder0.decodeStructDataHeader();
    if (mainDataHeader.version <= kVersions.last.version) {
      // Scan in reverse order to optimize for more recent versions.
      for (int i = kVersions.length - 1; i >= 0; --i) {
        if (mainDataHeader.version >= kVersions[i].version) {
          if (mainDataHeader.size == kVersions[i].size) {
            // Found a match.
            break;
          }
          throw new bindings.MojoCodecError(
              'Header size doesn\'t correspond to known version size.');
        }
      }
    } else if (mainDataHeader.size < kVersions.last.size) {
      throw new bindings.MojoCodecError(
        'Message newer than the last known version cannot be shorter than '
        'required by the last known version.');
    }
    if (mainDataHeader.version >= 0) {
      
        result.status = HandlerStatus.decode(decoder0, 8);
        if (result.status == null) {
          throw new bindings.MojoCodecError(
            'Trying to decode null union for non-nullable HandlerStatus.');
        }
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    try {
      encoder0.encodeEnum(status, 8);
    } on bindings.MojoCodecError catch(e) {
      e.message = "Error encountered while encoding field "
          "status of struct HandlerServiceRestoreSessionResponseParams: $e";
      rethrow;
    }
  }

  String toString() {
    return "HandlerServiceRestoreSessionResponseParams("
           "status: $status" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["status"] = status;
    return map;
  }
}


class _HandlerServiceStopSessionParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  String sessionId = null;

  _HandlerServiceStopSessionParams() : super(kVersions.last.size);

  _HandlerServiceStopSessionParams.init(
    String this.sessionId
  ) : super(kVersions.last.size);

  static _HandlerServiceStopSessionParams deserialize(bindings.Message message) {
    var decoder = new bindings.Decoder(message);
    var result = decode(decoder);
    if (decoder.excessHandles != null) {
      decoder.excessHandles.forEach((h) => h.close());
    }
    return result;
  }

  static _HandlerServiceStopSessionParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _HandlerServiceStopSessionParams result = new _HandlerServiceStopSessionParams();

    var mainDataHeader = decoder0.decodeStructDataHeader();
    if (mainDataHeader.version <= kVersions.last.version) {
      // Scan in reverse order to optimize for more recent versions.
      for (int i = kVersions.length - 1; i >= 0; --i) {
        if (mainDataHeader.version >= kVersions[i].version) {
          if (mainDataHeader.size == kVersions[i].size) {
            // Found a match.
            break;
          }
          throw new bindings.MojoCodecError(
              'Header size doesn\'t correspond to known version size.');
        }
      }
    } else if (mainDataHeader.size < kVersions.last.size) {
      throw new bindings.MojoCodecError(
        'Message newer than the last known version cannot be shorter than '
        'required by the last known version.');
    }
    if (mainDataHeader.version >= 0) {
      
      result.sessionId = decoder0.decodeString(8, false);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    try {
      encoder0.encodeString(sessionId, 8, false);
    } on bindings.MojoCodecError catch(e) {
      e.message = "Error encountered while encoding field "
          "sessionId of struct _HandlerServiceStopSessionParams: $e";
      rethrow;
    }
  }

  String toString() {
    return "_HandlerServiceStopSessionParams("
           "sessionId: $sessionId" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["sessionId"] = sessionId;
    return map;
  }
}


class HandlerServiceStopSessionResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  HandlerStatus status = null;

  HandlerServiceStopSessionResponseParams() : super(kVersions.last.size);

  HandlerServiceStopSessionResponseParams.init(
    HandlerStatus this.status
  ) : super(kVersions.last.size);

  static HandlerServiceStopSessionResponseParams deserialize(bindings.Message message) {
    var decoder = new bindings.Decoder(message);
    var result = decode(decoder);
    if (decoder.excessHandles != null) {
      decoder.excessHandles.forEach((h) => h.close());
    }
    return result;
  }

  static HandlerServiceStopSessionResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    HandlerServiceStopSessionResponseParams result = new HandlerServiceStopSessionResponseParams();

    var mainDataHeader = decoder0.decodeStructDataHeader();
    if (mainDataHeader.version <= kVersions.last.version) {
      // Scan in reverse order to optimize for more recent versions.
      for (int i = kVersions.length - 1; i >= 0; --i) {
        if (mainDataHeader.version >= kVersions[i].version) {
          if (mainDataHeader.size == kVersions[i].size) {
            // Found a match.
            break;
          }
          throw new bindings.MojoCodecError(
              'Header size doesn\'t correspond to known version size.');
        }
      }
    } else if (mainDataHeader.size < kVersions.last.size) {
      throw new bindings.MojoCodecError(
        'Message newer than the last known version cannot be shorter than '
        'required by the last known version.');
    }
    if (mainDataHeader.version >= 0) {
      
        result.status = HandlerStatus.decode(decoder0, 8);
        if (result.status == null) {
          throw new bindings.MojoCodecError(
            'Trying to decode null union for non-nullable HandlerStatus.');
        }
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    try {
      encoder0.encodeEnum(status, 8);
    } on bindings.MojoCodecError catch(e) {
      e.message = "Error encountered while encoding field "
          "status of struct HandlerServiceStopSessionResponseParams: $e";
      rethrow;
    }
  }

  String toString() {
    return "HandlerServiceStopSessionResponseParams("
           "status: $status" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["status"] = status;
    return map;
  }
}


class _HandlerServiceForkSessionParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  String parentSessionId = null;

  _HandlerServiceForkSessionParams() : super(kVersions.last.size);

  _HandlerServiceForkSessionParams.init(
    String this.parentSessionId
  ) : super(kVersions.last.size);

  static _HandlerServiceForkSessionParams deserialize(bindings.Message message) {
    var decoder = new bindings.Decoder(message);
    var result = decode(decoder);
    if (decoder.excessHandles != null) {
      decoder.excessHandles.forEach((h) => h.close());
    }
    return result;
  }

  static _HandlerServiceForkSessionParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _HandlerServiceForkSessionParams result = new _HandlerServiceForkSessionParams();

    var mainDataHeader = decoder0.decodeStructDataHeader();
    if (mainDataHeader.version <= kVersions.last.version) {
      // Scan in reverse order to optimize for more recent versions.
      for (int i = kVersions.length - 1; i >= 0; --i) {
        if (mainDataHeader.version >= kVersions[i].version) {
          if (mainDataHeader.size == kVersions[i].size) {
            // Found a match.
            break;
          }
          throw new bindings.MojoCodecError(
              'Header size doesn\'t correspond to known version size.');
        }
      }
    } else if (mainDataHeader.size < kVersions.last.size) {
      throw new bindings.MojoCodecError(
        'Message newer than the last known version cannot be shorter than '
        'required by the last known version.');
    }
    if (mainDataHeader.version >= 0) {
      
      result.parentSessionId = decoder0.decodeString(8, false);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    try {
      encoder0.encodeString(parentSessionId, 8, false);
    } on bindings.MojoCodecError catch(e) {
      e.message = "Error encountered while encoding field "
          "parentSessionId of struct _HandlerServiceForkSessionParams: $e";
      rethrow;
    }
  }

  String toString() {
    return "_HandlerServiceForkSessionParams("
           "parentSessionId: $parentSessionId" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["parentSessionId"] = parentSessionId;
    return map;
  }
}


class HandlerServiceForkSessionResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(24, 0)
  ];
  HandlerStatus status = null;
  String sessionId = null;

  HandlerServiceForkSessionResponseParams() : super(kVersions.last.size);

  HandlerServiceForkSessionResponseParams.init(
    HandlerStatus this.status, 
    String this.sessionId
  ) : super(kVersions.last.size);

  static HandlerServiceForkSessionResponseParams deserialize(bindings.Message message) {
    var decoder = new bindings.Decoder(message);
    var result = decode(decoder);
    if (decoder.excessHandles != null) {
      decoder.excessHandles.forEach((h) => h.close());
    }
    return result;
  }

  static HandlerServiceForkSessionResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    HandlerServiceForkSessionResponseParams result = new HandlerServiceForkSessionResponseParams();

    var mainDataHeader = decoder0.decodeStructDataHeader();
    if (mainDataHeader.version <= kVersions.last.version) {
      // Scan in reverse order to optimize for more recent versions.
      for (int i = kVersions.length - 1; i >= 0; --i) {
        if (mainDataHeader.version >= kVersions[i].version) {
          if (mainDataHeader.size == kVersions[i].size) {
            // Found a match.
            break;
          }
          throw new bindings.MojoCodecError(
              'Header size doesn\'t correspond to known version size.');
        }
      }
    } else if (mainDataHeader.size < kVersions.last.size) {
      throw new bindings.MojoCodecError(
        'Message newer than the last known version cannot be shorter than '
        'required by the last known version.');
    }
    if (mainDataHeader.version >= 0) {
      
        result.status = HandlerStatus.decode(decoder0, 8);
        if (result.status == null) {
          throw new bindings.MojoCodecError(
            'Trying to decode null union for non-nullable HandlerStatus.');
        }
    }
    if (mainDataHeader.version >= 0) {
      
      result.sessionId = decoder0.decodeString(16, true);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    try {
      encoder0.encodeEnum(status, 8);
    } on bindings.MojoCodecError catch(e) {
      e.message = "Error encountered while encoding field "
          "status of struct HandlerServiceForkSessionResponseParams: $e";
      rethrow;
    }
    try {
      encoder0.encodeString(sessionId, 16, true);
    } on bindings.MojoCodecError catch(e) {
      e.message = "Error encountered while encoding field "
          "sessionId of struct HandlerServiceForkSessionResponseParams: $e";
      rethrow;
    }
  }

  String toString() {
    return "HandlerServiceForkSessionResponseParams("
           "status: $status" ", "
           "sessionId: $sessionId" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["status"] = status;
    map["sessionId"] = sessionId;
    return map;
  }
}


class _HandlerServiceLinkSessionParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  String sessionId = null;

  _HandlerServiceLinkSessionParams() : super(kVersions.last.size);

  _HandlerServiceLinkSessionParams.init(
    String this.sessionId
  ) : super(kVersions.last.size);

  static _HandlerServiceLinkSessionParams deserialize(bindings.Message message) {
    var decoder = new bindings.Decoder(message);
    var result = decode(decoder);
    if (decoder.excessHandles != null) {
      decoder.excessHandles.forEach((h) => h.close());
    }
    return result;
  }

  static _HandlerServiceLinkSessionParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _HandlerServiceLinkSessionParams result = new _HandlerServiceLinkSessionParams();

    var mainDataHeader = decoder0.decodeStructDataHeader();
    if (mainDataHeader.version <= kVersions.last.version) {
      // Scan in reverse order to optimize for more recent versions.
      for (int i = kVersions.length - 1; i >= 0; --i) {
        if (mainDataHeader.version >= kVersions[i].version) {
          if (mainDataHeader.size == kVersions[i].size) {
            // Found a match.
            break;
          }
          throw new bindings.MojoCodecError(
              'Header size doesn\'t correspond to known version size.');
        }
      }
    } else if (mainDataHeader.size < kVersions.last.size) {
      throw new bindings.MojoCodecError(
        'Message newer than the last known version cannot be shorter than '
        'required by the last known version.');
    }
    if (mainDataHeader.version >= 0) {
      
      result.sessionId = decoder0.decodeString(8, false);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    try {
      encoder0.encodeString(sessionId, 8, false);
    } on bindings.MojoCodecError catch(e) {
      e.message = "Error encountered while encoding field "
          "sessionId of struct _HandlerServiceLinkSessionParams: $e";
      rethrow;
    }
  }

  String toString() {
    return "_HandlerServiceLinkSessionParams("
           "sessionId: $sessionId" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["sessionId"] = sessionId;
    return map;
  }
}


class HandlerServiceLinkSessionResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  HandlerStatus status = null;

  HandlerServiceLinkSessionResponseParams() : super(kVersions.last.size);

  HandlerServiceLinkSessionResponseParams.init(
    HandlerStatus this.status
  ) : super(kVersions.last.size);

  static HandlerServiceLinkSessionResponseParams deserialize(bindings.Message message) {
    var decoder = new bindings.Decoder(message);
    var result = decode(decoder);
    if (decoder.excessHandles != null) {
      decoder.excessHandles.forEach((h) => h.close());
    }
    return result;
  }

  static HandlerServiceLinkSessionResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    HandlerServiceLinkSessionResponseParams result = new HandlerServiceLinkSessionResponseParams();

    var mainDataHeader = decoder0.decodeStructDataHeader();
    if (mainDataHeader.version <= kVersions.last.version) {
      // Scan in reverse order to optimize for more recent versions.
      for (int i = kVersions.length - 1; i >= 0; --i) {
        if (mainDataHeader.version >= kVersions[i].version) {
          if (mainDataHeader.size == kVersions[i].size) {
            // Found a match.
            break;
          }
          throw new bindings.MojoCodecError(
              'Header size doesn\'t correspond to known version size.');
        }
      }
    } else if (mainDataHeader.size < kVersions.last.size) {
      throw new bindings.MojoCodecError(
        'Message newer than the last known version cannot be shorter than '
        'required by the last known version.');
    }
    if (mainDataHeader.version >= 0) {
      
        result.status = HandlerStatus.decode(decoder0, 8);
        if (result.status == null) {
          throw new bindings.MojoCodecError(
            'Trying to decode null union for non-nullable HandlerStatus.');
        }
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    try {
      encoder0.encodeEnum(status, 8);
    } on bindings.MojoCodecError catch(e) {
      e.message = "Error encountered while encoding field "
          "status of struct HandlerServiceLinkSessionResponseParams: $e";
      rethrow;
    }
  }

  String toString() {
    return "HandlerServiceLinkSessionResponseParams("
           "status: $status" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["status"] = status;
    return map;
  }
}


class _HandlerServiceUpdateSessionParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(32, 0)
  ];
  String sessionId = null;
  List<String> jsonAddSteps = null;
  List<String> jsonRemoveSteps = null;

  _HandlerServiceUpdateSessionParams() : super(kVersions.last.size);

  _HandlerServiceUpdateSessionParams.init(
    String this.sessionId, 
    List<String> this.jsonAddSteps, 
    List<String> this.jsonRemoveSteps
  ) : super(kVersions.last.size);

  static _HandlerServiceUpdateSessionParams deserialize(bindings.Message message) {
    var decoder = new bindings.Decoder(message);
    var result = decode(decoder);
    if (decoder.excessHandles != null) {
      decoder.excessHandles.forEach((h) => h.close());
    }
    return result;
  }

  static _HandlerServiceUpdateSessionParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _HandlerServiceUpdateSessionParams result = new _HandlerServiceUpdateSessionParams();

    var mainDataHeader = decoder0.decodeStructDataHeader();
    if (mainDataHeader.version <= kVersions.last.version) {
      // Scan in reverse order to optimize for more recent versions.
      for (int i = kVersions.length - 1; i >= 0; --i) {
        if (mainDataHeader.version >= kVersions[i].version) {
          if (mainDataHeader.size == kVersions[i].size) {
            // Found a match.
            break;
          }
          throw new bindings.MojoCodecError(
              'Header size doesn\'t correspond to known version size.');
        }
      }
    } else if (mainDataHeader.size < kVersions.last.size) {
      throw new bindings.MojoCodecError(
        'Message newer than the last known version cannot be shorter than '
        'required by the last known version.');
    }
    if (mainDataHeader.version >= 0) {
      
      result.sessionId = decoder0.decodeString(8, false);
    }
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(16, true);
      if (decoder1 == null) {
        result.jsonAddSteps = null;
      } else {
        var si1 = decoder1.decodeDataHeaderForPointerArray(bindings.kUnspecifiedArrayLength);
        result.jsonAddSteps = new List<String>(si1.numElements);
        for (int i1 = 0; i1 < si1.numElements; ++i1) {
          
          result.jsonAddSteps[i1] = decoder1.decodeString(bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize * i1, false);
        }
      }
    }
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(24, true);
      if (decoder1 == null) {
        result.jsonRemoveSteps = null;
      } else {
        var si1 = decoder1.decodeDataHeaderForPointerArray(bindings.kUnspecifiedArrayLength);
        result.jsonRemoveSteps = new List<String>(si1.numElements);
        for (int i1 = 0; i1 < si1.numElements; ++i1) {
          
          result.jsonRemoveSteps[i1] = decoder1.decodeString(bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize * i1, false);
        }
      }
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    try {
      encoder0.encodeString(sessionId, 8, false);
    } on bindings.MojoCodecError catch(e) {
      e.message = "Error encountered while encoding field "
          "sessionId of struct _HandlerServiceUpdateSessionParams: $e";
      rethrow;
    }
    try {
      if (jsonAddSteps == null) {
        encoder0.encodeNullPointer(16, true);
      } else {
        var encoder1 = encoder0.encodePointerArray(jsonAddSteps.length, 16, bindings.kUnspecifiedArrayLength);
        for (int i0 = 0; i0 < jsonAddSteps.length; ++i0) {
          encoder1.encodeString(jsonAddSteps[i0], bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize * i0, false);
        }
      }
    } on bindings.MojoCodecError catch(e) {
      e.message = "Error encountered while encoding field "
          "jsonAddSteps of struct _HandlerServiceUpdateSessionParams: $e";
      rethrow;
    }
    try {
      if (jsonRemoveSteps == null) {
        encoder0.encodeNullPointer(24, true);
      } else {
        var encoder1 = encoder0.encodePointerArray(jsonRemoveSteps.length, 24, bindings.kUnspecifiedArrayLength);
        for (int i0 = 0; i0 < jsonRemoveSteps.length; ++i0) {
          encoder1.encodeString(jsonRemoveSteps[i0], bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize * i0, false);
        }
      }
    } on bindings.MojoCodecError catch(e) {
      e.message = "Error encountered while encoding field "
          "jsonRemoveSteps of struct _HandlerServiceUpdateSessionParams: $e";
      rethrow;
    }
  }

  String toString() {
    return "_HandlerServiceUpdateSessionParams("
           "sessionId: $sessionId" ", "
           "jsonAddSteps: $jsonAddSteps" ", "
           "jsonRemoveSteps: $jsonRemoveSteps" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["sessionId"] = sessionId;
    map["jsonAddSteps"] = jsonAddSteps;
    map["jsonRemoveSteps"] = jsonRemoveSteps;
    return map;
  }
}


class HandlerServiceUpdateSessionResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  HandlerStatus status = null;

  HandlerServiceUpdateSessionResponseParams() : super(kVersions.last.size);

  HandlerServiceUpdateSessionResponseParams.init(
    HandlerStatus this.status
  ) : super(kVersions.last.size);

  static HandlerServiceUpdateSessionResponseParams deserialize(bindings.Message message) {
    var decoder = new bindings.Decoder(message);
    var result = decode(decoder);
    if (decoder.excessHandles != null) {
      decoder.excessHandles.forEach((h) => h.close());
    }
    return result;
  }

  static HandlerServiceUpdateSessionResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    HandlerServiceUpdateSessionResponseParams result = new HandlerServiceUpdateSessionResponseParams();

    var mainDataHeader = decoder0.decodeStructDataHeader();
    if (mainDataHeader.version <= kVersions.last.version) {
      // Scan in reverse order to optimize for more recent versions.
      for (int i = kVersions.length - 1; i >= 0; --i) {
        if (mainDataHeader.version >= kVersions[i].version) {
          if (mainDataHeader.size == kVersions[i].size) {
            // Found a match.
            break;
          }
          throw new bindings.MojoCodecError(
              'Header size doesn\'t correspond to known version size.');
        }
      }
    } else if (mainDataHeader.size < kVersions.last.size) {
      throw new bindings.MojoCodecError(
        'Message newer than the last known version cannot be shorter than '
        'required by the last known version.');
    }
    if (mainDataHeader.version >= 0) {
      
        result.status = HandlerStatus.decode(decoder0, 8);
        if (result.status == null) {
          throw new bindings.MojoCodecError(
            'Trying to decode null union for non-nullable HandlerStatus.');
        }
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    try {
      encoder0.encodeEnum(status, 8);
    } on bindings.MojoCodecError catch(e) {
      e.message = "Error encountered while encoding field "
          "status of struct HandlerServiceUpdateSessionResponseParams: $e";
      rethrow;
    }
  }

  String toString() {
    return "HandlerServiceUpdateSessionResponseParams("
           "status: $status" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["status"] = status;
    return map;
  }
}


class _HandlerServiceAddObserverParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  SessionObserverInterface observer = null;

  _HandlerServiceAddObserverParams() : super(kVersions.last.size);

  _HandlerServiceAddObserverParams.init(
    SessionObserverInterface this.observer
  ) : super(kVersions.last.size);

  static _HandlerServiceAddObserverParams deserialize(bindings.Message message) {
    var decoder = new bindings.Decoder(message);
    var result = decode(decoder);
    if (decoder.excessHandles != null) {
      decoder.excessHandles.forEach((h) => h.close());
    }
    return result;
  }

  static _HandlerServiceAddObserverParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _HandlerServiceAddObserverParams result = new _HandlerServiceAddObserverParams();

    var mainDataHeader = decoder0.decodeStructDataHeader();
    if (mainDataHeader.version <= kVersions.last.version) {
      // Scan in reverse order to optimize for more recent versions.
      for (int i = kVersions.length - 1; i >= 0; --i) {
        if (mainDataHeader.version >= kVersions[i].version) {
          if (mainDataHeader.size == kVersions[i].size) {
            // Found a match.
            break;
          }
          throw new bindings.MojoCodecError(
              'Header size doesn\'t correspond to known version size.');
        }
      }
    } else if (mainDataHeader.size < kVersions.last.size) {
      throw new bindings.MojoCodecError(
        'Message newer than the last known version cannot be shorter than '
        'required by the last known version.');
    }
    if (mainDataHeader.version >= 0) {
      
      result.observer = decoder0.decodeServiceInterface(8, false, SessionObserverProxy.newFromEndpoint);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    try {
      encoder0.encodeInterface(observer, 8, false);
    } on bindings.MojoCodecError catch(e) {
      e.message = "Error encountered while encoding field "
          "observer of struct _HandlerServiceAddObserverParams: $e";
      rethrow;
    }
  }

  String toString() {
    return "_HandlerServiceAddObserverParams("
           "observer: $observer" ")";
  }

  Map toJson() {
    throw new bindings.MojoCodecError(
        'Object containing handles cannot be encoded to JSON.');
  }
}


class _SessionObserverOnSessionsStartedParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  List<String> sessionIds = null;

  _SessionObserverOnSessionsStartedParams() : super(kVersions.last.size);

  _SessionObserverOnSessionsStartedParams.init(
    List<String> this.sessionIds
  ) : super(kVersions.last.size);

  static _SessionObserverOnSessionsStartedParams deserialize(bindings.Message message) {
    var decoder = new bindings.Decoder(message);
    var result = decode(decoder);
    if (decoder.excessHandles != null) {
      decoder.excessHandles.forEach((h) => h.close());
    }
    return result;
  }

  static _SessionObserverOnSessionsStartedParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _SessionObserverOnSessionsStartedParams result = new _SessionObserverOnSessionsStartedParams();

    var mainDataHeader = decoder0.decodeStructDataHeader();
    if (mainDataHeader.version <= kVersions.last.version) {
      // Scan in reverse order to optimize for more recent versions.
      for (int i = kVersions.length - 1; i >= 0; --i) {
        if (mainDataHeader.version >= kVersions[i].version) {
          if (mainDataHeader.size == kVersions[i].size) {
            // Found a match.
            break;
          }
          throw new bindings.MojoCodecError(
              'Header size doesn\'t correspond to known version size.');
        }
      }
    } else if (mainDataHeader.size < kVersions.last.size) {
      throw new bindings.MojoCodecError(
        'Message newer than the last known version cannot be shorter than '
        'required by the last known version.');
    }
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(8, false);
      {
        var si1 = decoder1.decodeDataHeaderForPointerArray(bindings.kUnspecifiedArrayLength);
        result.sessionIds = new List<String>(si1.numElements);
        for (int i1 = 0; i1 < si1.numElements; ++i1) {
          
          result.sessionIds[i1] = decoder1.decodeString(bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize * i1, false);
        }
      }
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    try {
      if (sessionIds == null) {
        encoder0.encodeNullPointer(8, false);
      } else {
        var encoder1 = encoder0.encodePointerArray(sessionIds.length, 8, bindings.kUnspecifiedArrayLength);
        for (int i0 = 0; i0 < sessionIds.length; ++i0) {
          encoder1.encodeString(sessionIds[i0], bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize * i0, false);
        }
      }
    } on bindings.MojoCodecError catch(e) {
      e.message = "Error encountered while encoding field "
          "sessionIds of struct _SessionObserverOnSessionsStartedParams: $e";
      rethrow;
    }
  }

  String toString() {
    return "_SessionObserverOnSessionsStartedParams("
           "sessionIds: $sessionIds" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["sessionIds"] = sessionIds;
    return map;
  }
}


class _SessionObserverOnSessionsStoppedParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  List<String> sessionIds = null;

  _SessionObserverOnSessionsStoppedParams() : super(kVersions.last.size);

  _SessionObserverOnSessionsStoppedParams.init(
    List<String> this.sessionIds
  ) : super(kVersions.last.size);

  static _SessionObserverOnSessionsStoppedParams deserialize(bindings.Message message) {
    var decoder = new bindings.Decoder(message);
    var result = decode(decoder);
    if (decoder.excessHandles != null) {
      decoder.excessHandles.forEach((h) => h.close());
    }
    return result;
  }

  static _SessionObserverOnSessionsStoppedParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _SessionObserverOnSessionsStoppedParams result = new _SessionObserverOnSessionsStoppedParams();

    var mainDataHeader = decoder0.decodeStructDataHeader();
    if (mainDataHeader.version <= kVersions.last.version) {
      // Scan in reverse order to optimize for more recent versions.
      for (int i = kVersions.length - 1; i >= 0; --i) {
        if (mainDataHeader.version >= kVersions[i].version) {
          if (mainDataHeader.size == kVersions[i].size) {
            // Found a match.
            break;
          }
          throw new bindings.MojoCodecError(
              'Header size doesn\'t correspond to known version size.');
        }
      }
    } else if (mainDataHeader.size < kVersions.last.size) {
      throw new bindings.MojoCodecError(
        'Message newer than the last known version cannot be shorter than '
        'required by the last known version.');
    }
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(8, false);
      {
        var si1 = decoder1.decodeDataHeaderForPointerArray(bindings.kUnspecifiedArrayLength);
        result.sessionIds = new List<String>(si1.numElements);
        for (int i1 = 0; i1 < si1.numElements; ++i1) {
          
          result.sessionIds[i1] = decoder1.decodeString(bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize * i1, false);
        }
      }
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    try {
      if (sessionIds == null) {
        encoder0.encodeNullPointer(8, false);
      } else {
        var encoder1 = encoder0.encodePointerArray(sessionIds.length, 8, bindings.kUnspecifiedArrayLength);
        for (int i0 = 0; i0 < sessionIds.length; ++i0) {
          encoder1.encodeString(sessionIds[i0], bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize * i0, false);
        }
      }
    } on bindings.MojoCodecError catch(e) {
      e.message = "Error encountered while encoding field "
          "sessionIds of struct _SessionObserverOnSessionsStoppedParams: $e";
      rethrow;
    }
  }

  String toString() {
    return "_SessionObserverOnSessionsStoppedParams("
           "sessionIds: $sessionIds" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["sessionIds"] = sessionIds;
    return map;
  }
}


class _SessionGraphServiceGetGraphParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(24, 0)
  ];
  String sessionId = null;
  graph_mojom.GraphInterfaceRequest graph = null;

  _SessionGraphServiceGetGraphParams() : super(kVersions.last.size);

  _SessionGraphServiceGetGraphParams.init(
    String this.sessionId, 
    graph_mojom.GraphInterfaceRequest this.graph
  ) : super(kVersions.last.size);

  static _SessionGraphServiceGetGraphParams deserialize(bindings.Message message) {
    var decoder = new bindings.Decoder(message);
    var result = decode(decoder);
    if (decoder.excessHandles != null) {
      decoder.excessHandles.forEach((h) => h.close());
    }
    return result;
  }

  static _SessionGraphServiceGetGraphParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _SessionGraphServiceGetGraphParams result = new _SessionGraphServiceGetGraphParams();

    var mainDataHeader = decoder0.decodeStructDataHeader();
    if (mainDataHeader.version <= kVersions.last.version) {
      // Scan in reverse order to optimize for more recent versions.
      for (int i = kVersions.length - 1; i >= 0; --i) {
        if (mainDataHeader.version >= kVersions[i].version) {
          if (mainDataHeader.size == kVersions[i].size) {
            // Found a match.
            break;
          }
          throw new bindings.MojoCodecError(
              'Header size doesn\'t correspond to known version size.');
        }
      }
    } else if (mainDataHeader.size < kVersions.last.size) {
      throw new bindings.MojoCodecError(
        'Message newer than the last known version cannot be shorter than '
        'required by the last known version.');
    }
    if (mainDataHeader.version >= 0) {
      
      result.sessionId = decoder0.decodeString(8, false);
    }
    if (mainDataHeader.version >= 0) {
      
      result.graph = decoder0.decodeInterfaceRequest(16, false, graph_mojom.GraphStub.newFromEndpoint);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    try {
      encoder0.encodeString(sessionId, 8, false);
    } on bindings.MojoCodecError catch(e) {
      e.message = "Error encountered while encoding field "
          "sessionId of struct _SessionGraphServiceGetGraphParams: $e";
      rethrow;
    }
    try {
      encoder0.encodeInterfaceRequest(graph, 16, false);
    } on bindings.MojoCodecError catch(e) {
      e.message = "Error encountered while encoding field "
          "graph of struct _SessionGraphServiceGetGraphParams: $e";
      rethrow;
    }
  }

  String toString() {
    return "_SessionGraphServiceGetGraphParams("
           "sessionId: $sessionId" ", "
           "graph: $graph" ")";
  }

  Map toJson() {
    throw new bindings.MojoCodecError(
        'Object containing handles cannot be encoded to JSON.');
  }
}


class SessionGraphServiceGetGraphResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  HandlerStatus status = null;

  SessionGraphServiceGetGraphResponseParams() : super(kVersions.last.size);

  SessionGraphServiceGetGraphResponseParams.init(
    HandlerStatus this.status
  ) : super(kVersions.last.size);

  static SessionGraphServiceGetGraphResponseParams deserialize(bindings.Message message) {
    var decoder = new bindings.Decoder(message);
    var result = decode(decoder);
    if (decoder.excessHandles != null) {
      decoder.excessHandles.forEach((h) => h.close());
    }
    return result;
  }

  static SessionGraphServiceGetGraphResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    SessionGraphServiceGetGraphResponseParams result = new SessionGraphServiceGetGraphResponseParams();

    var mainDataHeader = decoder0.decodeStructDataHeader();
    if (mainDataHeader.version <= kVersions.last.version) {
      // Scan in reverse order to optimize for more recent versions.
      for (int i = kVersions.length - 1; i >= 0; --i) {
        if (mainDataHeader.version >= kVersions[i].version) {
          if (mainDataHeader.size == kVersions[i].size) {
            // Found a match.
            break;
          }
          throw new bindings.MojoCodecError(
              'Header size doesn\'t correspond to known version size.');
        }
      }
    } else if (mainDataHeader.size < kVersions.last.size) {
      throw new bindings.MojoCodecError(
        'Message newer than the last known version cannot be shorter than '
        'required by the last known version.');
    }
    if (mainDataHeader.version >= 0) {
      
        result.status = HandlerStatus.decode(decoder0, 8);
        if (result.status == null) {
          throw new bindings.MojoCodecError(
            'Trying to decode null union for non-nullable HandlerStatus.');
        }
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    try {
      encoder0.encodeEnum(status, 8);
    } on bindings.MojoCodecError catch(e) {
      e.message = "Error encountered while encoding field "
          "status of struct SessionGraphServiceGetGraphResponseParams: $e";
      rethrow;
    }
  }

  String toString() {
    return "SessionGraphServiceGetGraphResponseParams("
           "status: $status" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["status"] = status;
    return map;
  }
}

const int _handlerServiceMethodCreateSessionName = 0;
const int _handlerServiceMethodRestoreSessionName = 1;
const int _handlerServiceMethodStopSessionName = 2;
const int _handlerServiceMethodForkSessionName = 3;
const int _handlerServiceMethodLinkSessionName = 4;
const int _handlerServiceMethodUpdateSessionName = 5;
const int _handlerServiceMethodAddObserverName = 6;

class _HandlerServiceServiceDescription implements service_describer.ServiceDescription {
  void getTopLevelInterface(Function responder) {
    responder(null);
  }

  void getTypeDefinition(String typeKey, Function responder) {
    responder(null);
  }

  void getAllTypeDefinitions(Function responder) {
    responder(null);
  }
}

abstract class HandlerService {
  static const String serviceName = "modular::HandlerService";

  static service_describer.ServiceDescription _cachedServiceDescription;
  static service_describer.ServiceDescription get serviceDescription {
    if (_cachedServiceDescription == null) {
      _cachedServiceDescription = new _HandlerServiceServiceDescription();
    }
    return _cachedServiceDescription;
  }

  static HandlerServiceProxy connectToService(
      bindings.ServiceConnector s, String url, [String serviceName]) {
    HandlerServiceProxy p = new HandlerServiceProxy.unbound();
    String name = serviceName ?? HandlerService.serviceName;
    if ((name == null) || name.isEmpty) {
      throw new core.MojoApiError(
          "If an interface has no ServiceName, then one must be provided.");
    }
    s.connectToService(url, p, name);
    return p;
  }
  void createSession(String recipe,void callback(HandlerStatus status, String sessionId));
  void restoreSession(String sessionId,void callback(HandlerStatus status));
  void stopSession(String sessionId,void callback(HandlerStatus status));
  void forkSession(String parentSessionId,void callback(HandlerStatus status, String sessionId));
  void linkSession(String sessionId,void callback(HandlerStatus status));
  void updateSession(String sessionId,List<String> jsonAddSteps,List<String> jsonRemoveSteps,void callback(HandlerStatus status));
  void addObserver(SessionObserverInterface observer);
}

abstract class HandlerServiceInterface
    implements bindings.MojoInterface<HandlerService>,
               HandlerService {
  factory HandlerServiceInterface([HandlerService impl]) =>
      new HandlerServiceStub.unbound(impl);

  factory HandlerServiceInterface.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint,
      [HandlerService impl]) =>
      new HandlerServiceStub.fromEndpoint(endpoint, impl);

  factory HandlerServiceInterface.fromMock(
      HandlerService mock) =>
      new HandlerServiceProxy.fromMock(mock);
}

abstract class HandlerServiceInterfaceRequest
    implements bindings.MojoInterface<HandlerService>,
               HandlerService {
  factory HandlerServiceInterfaceRequest() =>
      new HandlerServiceProxy.unbound();
}

class _HandlerServiceProxyControl
    extends bindings.ProxyMessageHandler
    implements bindings.ProxyControl<HandlerService> {
  HandlerService impl;

  _HandlerServiceProxyControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) : super.fromEndpoint(endpoint);

  _HandlerServiceProxyControl.fromHandle(
      core.MojoHandle handle) : super.fromHandle(handle);

  _HandlerServiceProxyControl.unbound() : super.unbound();

  String get serviceName => HandlerService.serviceName;

  void handleResponse(bindings.ServiceMessage message) {
    switch (message.header.type) {
      case _handlerServiceMethodCreateSessionName:
        var r = HandlerServiceCreateSessionResponseParams.deserialize(
            message.payload);
        if (!message.header.hasRequestId) {
          proxyError("Expected a message with a valid request Id.");
          return;
        }
        Function callback = callbackMap[message.header.requestId];
        if (callback == null) {
          proxyError(
              "Message had unknown request Id: ${message.header.requestId}");
          return;
        }
        callbackMap.remove(message.header.requestId);
        callback(r.status , r.sessionId );
        break;
      case _handlerServiceMethodRestoreSessionName:
        var r = HandlerServiceRestoreSessionResponseParams.deserialize(
            message.payload);
        if (!message.header.hasRequestId) {
          proxyError("Expected a message with a valid request Id.");
          return;
        }
        Function callback = callbackMap[message.header.requestId];
        if (callback == null) {
          proxyError(
              "Message had unknown request Id: ${message.header.requestId}");
          return;
        }
        callbackMap.remove(message.header.requestId);
        callback(r.status );
        break;
      case _handlerServiceMethodStopSessionName:
        var r = HandlerServiceStopSessionResponseParams.deserialize(
            message.payload);
        if (!message.header.hasRequestId) {
          proxyError("Expected a message with a valid request Id.");
          return;
        }
        Function callback = callbackMap[message.header.requestId];
        if (callback == null) {
          proxyError(
              "Message had unknown request Id: ${message.header.requestId}");
          return;
        }
        callbackMap.remove(message.header.requestId);
        callback(r.status );
        break;
      case _handlerServiceMethodForkSessionName:
        var r = HandlerServiceForkSessionResponseParams.deserialize(
            message.payload);
        if (!message.header.hasRequestId) {
          proxyError("Expected a message with a valid request Id.");
          return;
        }
        Function callback = callbackMap[message.header.requestId];
        if (callback == null) {
          proxyError(
              "Message had unknown request Id: ${message.header.requestId}");
          return;
        }
        callbackMap.remove(message.header.requestId);
        callback(r.status , r.sessionId );
        break;
      case _handlerServiceMethodLinkSessionName:
        var r = HandlerServiceLinkSessionResponseParams.deserialize(
            message.payload);
        if (!message.header.hasRequestId) {
          proxyError("Expected a message with a valid request Id.");
          return;
        }
        Function callback = callbackMap[message.header.requestId];
        if (callback == null) {
          proxyError(
              "Message had unknown request Id: ${message.header.requestId}");
          return;
        }
        callbackMap.remove(message.header.requestId);
        callback(r.status );
        break;
      case _handlerServiceMethodUpdateSessionName:
        var r = HandlerServiceUpdateSessionResponseParams.deserialize(
            message.payload);
        if (!message.header.hasRequestId) {
          proxyError("Expected a message with a valid request Id.");
          return;
        }
        Function callback = callbackMap[message.header.requestId];
        if (callback == null) {
          proxyError(
              "Message had unknown request Id: ${message.header.requestId}");
          return;
        }
        callbackMap.remove(message.header.requestId);
        callback(r.status );
        break;
      default:
        proxyError("Unexpected message type: ${message.header.type}");
        close(immediate: true);
        break;
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_HandlerServiceProxyControl($superString)";
  }
}

class HandlerServiceProxy
    extends bindings.Proxy<HandlerService>
    implements HandlerService,
               HandlerServiceInterface,
               HandlerServiceInterfaceRequest {
  HandlerServiceProxy.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint)
      : super(new _HandlerServiceProxyControl.fromEndpoint(endpoint));

  HandlerServiceProxy.fromHandle(core.MojoHandle handle)
      : super(new _HandlerServiceProxyControl.fromHandle(handle));

  HandlerServiceProxy.unbound()
      : super(new _HandlerServiceProxyControl.unbound());

  factory HandlerServiceProxy.fromMock(HandlerService mock) {
    HandlerServiceProxy newMockedProxy =
        new HandlerServiceProxy.unbound();
    newMockedProxy.impl = mock;
    return newMockedProxy;
  }

  static HandlerServiceProxy newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For HandlerServiceProxy"));
    return new HandlerServiceProxy.fromEndpoint(endpoint);
  }


  void createSession(String recipe,void callback(HandlerStatus status, String sessionId)) {
    if (impl != null) {
      impl.createSession(recipe,callback);
      return;
    }
    var params = new _HandlerServiceCreateSessionParams();
    params.recipe = recipe;
    Function zonedCallback;
    if (identical(Zone.current, Zone.ROOT)) {
      zonedCallback = callback;
    } else {
      Zone z = Zone.current;
      zonedCallback = ((HandlerStatus status, String sessionId) {
        z.bindCallback(() {
          callback(status, sessionId);
        })();
      });
    }
    ctrl.sendMessageWithRequestId(
        params,
        _handlerServiceMethodCreateSessionName,
        -1,
        bindings.MessageHeader.kMessageExpectsResponse,
        zonedCallback);
  }
  void restoreSession(String sessionId,void callback(HandlerStatus status)) {
    if (impl != null) {
      impl.restoreSession(sessionId,callback);
      return;
    }
    var params = new _HandlerServiceRestoreSessionParams();
    params.sessionId = sessionId;
    Function zonedCallback;
    if (identical(Zone.current, Zone.ROOT)) {
      zonedCallback = callback;
    } else {
      Zone z = Zone.current;
      zonedCallback = ((HandlerStatus status) {
        z.bindCallback(() {
          callback(status);
        })();
      });
    }
    ctrl.sendMessageWithRequestId(
        params,
        _handlerServiceMethodRestoreSessionName,
        -1,
        bindings.MessageHeader.kMessageExpectsResponse,
        zonedCallback);
  }
  void stopSession(String sessionId,void callback(HandlerStatus status)) {
    if (impl != null) {
      impl.stopSession(sessionId,callback);
      return;
    }
    var params = new _HandlerServiceStopSessionParams();
    params.sessionId = sessionId;
    Function zonedCallback;
    if (identical(Zone.current, Zone.ROOT)) {
      zonedCallback = callback;
    } else {
      Zone z = Zone.current;
      zonedCallback = ((HandlerStatus status) {
        z.bindCallback(() {
          callback(status);
        })();
      });
    }
    ctrl.sendMessageWithRequestId(
        params,
        _handlerServiceMethodStopSessionName,
        -1,
        bindings.MessageHeader.kMessageExpectsResponse,
        zonedCallback);
  }
  void forkSession(String parentSessionId,void callback(HandlerStatus status, String sessionId)) {
    if (impl != null) {
      impl.forkSession(parentSessionId,callback);
      return;
    }
    var params = new _HandlerServiceForkSessionParams();
    params.parentSessionId = parentSessionId;
    Function zonedCallback;
    if (identical(Zone.current, Zone.ROOT)) {
      zonedCallback = callback;
    } else {
      Zone z = Zone.current;
      zonedCallback = ((HandlerStatus status, String sessionId) {
        z.bindCallback(() {
          callback(status, sessionId);
        })();
      });
    }
    ctrl.sendMessageWithRequestId(
        params,
        _handlerServiceMethodForkSessionName,
        -1,
        bindings.MessageHeader.kMessageExpectsResponse,
        zonedCallback);
  }
  void linkSession(String sessionId,void callback(HandlerStatus status)) {
    if (impl != null) {
      impl.linkSession(sessionId,callback);
      return;
    }
    var params = new _HandlerServiceLinkSessionParams();
    params.sessionId = sessionId;
    Function zonedCallback;
    if (identical(Zone.current, Zone.ROOT)) {
      zonedCallback = callback;
    } else {
      Zone z = Zone.current;
      zonedCallback = ((HandlerStatus status) {
        z.bindCallback(() {
          callback(status);
        })();
      });
    }
    ctrl.sendMessageWithRequestId(
        params,
        _handlerServiceMethodLinkSessionName,
        -1,
        bindings.MessageHeader.kMessageExpectsResponse,
        zonedCallback);
  }
  void updateSession(String sessionId,List<String> jsonAddSteps,List<String> jsonRemoveSteps,void callback(HandlerStatus status)) {
    if (impl != null) {
      impl.updateSession(sessionId,jsonAddSteps,jsonRemoveSteps,callback);
      return;
    }
    var params = new _HandlerServiceUpdateSessionParams();
    params.sessionId = sessionId;
    params.jsonAddSteps = jsonAddSteps;
    params.jsonRemoveSteps = jsonRemoveSteps;
    Function zonedCallback;
    if (identical(Zone.current, Zone.ROOT)) {
      zonedCallback = callback;
    } else {
      Zone z = Zone.current;
      zonedCallback = ((HandlerStatus status) {
        z.bindCallback(() {
          callback(status);
        })();
      });
    }
    ctrl.sendMessageWithRequestId(
        params,
        _handlerServiceMethodUpdateSessionName,
        -1,
        bindings.MessageHeader.kMessageExpectsResponse,
        zonedCallback);
  }
  void addObserver(SessionObserverInterface observer) {
    if (impl != null) {
      impl.addObserver(observer);
      return;
    }
    if (!ctrl.isBound) {
      ctrl.proxyError("The Proxy is closed.");
      return;
    }
    var params = new _HandlerServiceAddObserverParams();
    params.observer = observer;
    ctrl.sendMessage(params,
        _handlerServiceMethodAddObserverName);
  }
}

class _HandlerServiceStubControl
    extends bindings.StubMessageHandler
    implements bindings.StubControl<HandlerService> {
  HandlerService _impl;

  _HandlerServiceStubControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [HandlerService impl])
      : super.fromEndpoint(endpoint, autoBegin: impl != null) {
    _impl = impl;
  }

  _HandlerServiceStubControl.fromHandle(
      core.MojoHandle handle, [HandlerService impl])
      : super.fromHandle(handle, autoBegin: impl != null) {
    _impl = impl;
  }

  _HandlerServiceStubControl.unbound([this._impl]) : super.unbound();

  String get serviceName => HandlerService.serviceName;


  Function _handlerServiceCreateSessionResponseParamsResponder(
      int requestId) {
  return (HandlerStatus status, String sessionId) {
      var result = new HandlerServiceCreateSessionResponseParams();
      result.status = status;
      result.sessionId = sessionId;
      sendResponse(buildResponseWithId(
          result,
          _handlerServiceMethodCreateSessionName,
          requestId,
          bindings.MessageHeader.kMessageIsResponse));
    };
  }
  Function _handlerServiceRestoreSessionResponseParamsResponder(
      int requestId) {
  return (HandlerStatus status) {
      var result = new HandlerServiceRestoreSessionResponseParams();
      result.status = status;
      sendResponse(buildResponseWithId(
          result,
          _handlerServiceMethodRestoreSessionName,
          requestId,
          bindings.MessageHeader.kMessageIsResponse));
    };
  }
  Function _handlerServiceStopSessionResponseParamsResponder(
      int requestId) {
  return (HandlerStatus status) {
      var result = new HandlerServiceStopSessionResponseParams();
      result.status = status;
      sendResponse(buildResponseWithId(
          result,
          _handlerServiceMethodStopSessionName,
          requestId,
          bindings.MessageHeader.kMessageIsResponse));
    };
  }
  Function _handlerServiceForkSessionResponseParamsResponder(
      int requestId) {
  return (HandlerStatus status, String sessionId) {
      var result = new HandlerServiceForkSessionResponseParams();
      result.status = status;
      result.sessionId = sessionId;
      sendResponse(buildResponseWithId(
          result,
          _handlerServiceMethodForkSessionName,
          requestId,
          bindings.MessageHeader.kMessageIsResponse));
    };
  }
  Function _handlerServiceLinkSessionResponseParamsResponder(
      int requestId) {
  return (HandlerStatus status) {
      var result = new HandlerServiceLinkSessionResponseParams();
      result.status = status;
      sendResponse(buildResponseWithId(
          result,
          _handlerServiceMethodLinkSessionName,
          requestId,
          bindings.MessageHeader.kMessageIsResponse));
    };
  }
  Function _handlerServiceUpdateSessionResponseParamsResponder(
      int requestId) {
  return (HandlerStatus status) {
      var result = new HandlerServiceUpdateSessionResponseParams();
      result.status = status;
      sendResponse(buildResponseWithId(
          result,
          _handlerServiceMethodUpdateSessionName,
          requestId,
          bindings.MessageHeader.kMessageIsResponse));
    };
  }

  void handleMessage(bindings.ServiceMessage message) {
    if (bindings.ControlMessageHandler.isControlMessage(message)) {
      bindings.ControlMessageHandler.handleMessage(
          this, 0, message);
      return;
    }
    if (_impl == null) {
      throw new core.MojoApiError("$this has no implementation set");
    }
    switch (message.header.type) {
      case _handlerServiceMethodCreateSessionName:
        var params = _HandlerServiceCreateSessionParams.deserialize(
            message.payload);
        _impl.createSession(params.recipe, _handlerServiceCreateSessionResponseParamsResponder(message.header.requestId));
        break;
      case _handlerServiceMethodRestoreSessionName:
        var params = _HandlerServiceRestoreSessionParams.deserialize(
            message.payload);
        _impl.restoreSession(params.sessionId, _handlerServiceRestoreSessionResponseParamsResponder(message.header.requestId));
        break;
      case _handlerServiceMethodStopSessionName:
        var params = _HandlerServiceStopSessionParams.deserialize(
            message.payload);
        _impl.stopSession(params.sessionId, _handlerServiceStopSessionResponseParamsResponder(message.header.requestId));
        break;
      case _handlerServiceMethodForkSessionName:
        var params = _HandlerServiceForkSessionParams.deserialize(
            message.payload);
        _impl.forkSession(params.parentSessionId, _handlerServiceForkSessionResponseParamsResponder(message.header.requestId));
        break;
      case _handlerServiceMethodLinkSessionName:
        var params = _HandlerServiceLinkSessionParams.deserialize(
            message.payload);
        _impl.linkSession(params.sessionId, _handlerServiceLinkSessionResponseParamsResponder(message.header.requestId));
        break;
      case _handlerServiceMethodUpdateSessionName:
        var params = _HandlerServiceUpdateSessionParams.deserialize(
            message.payload);
        _impl.updateSession(params.sessionId, params.jsonAddSteps, params.jsonRemoveSteps, _handlerServiceUpdateSessionResponseParamsResponder(message.header.requestId));
        break;
      case _handlerServiceMethodAddObserverName:
        var params = _HandlerServiceAddObserverParams.deserialize(
            message.payload);
        _impl.addObserver(params.observer);
        break;
      default:
        throw new bindings.MojoCodecError("Unexpected message name");
        break;
    }
  }

  HandlerService get impl => _impl;
  set impl(HandlerService d) {
    if (d == null) {
      throw new core.MojoApiError("$this: Cannot set a null implementation");
    }
    if (isBound && (_impl == null)) {
      beginHandlingEvents();
    }
    _impl = d;
  }

  @override
  void bind(core.MojoMessagePipeEndpoint endpoint) {
    super.bind(endpoint);
    if (!isOpen && (_impl != null)) {
      beginHandlingEvents();
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_HandlerServiceStubControl($superString)";
  }

  int get version => 0;
}

class HandlerServiceStub
    extends bindings.Stub<HandlerService>
    implements HandlerService,
               HandlerServiceInterface,
               HandlerServiceInterfaceRequest {
  HandlerServiceStub.unbound([HandlerService impl])
      : super(new _HandlerServiceStubControl.unbound(impl));

  HandlerServiceStub.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [HandlerService impl])
      : super(new _HandlerServiceStubControl.fromEndpoint(endpoint, impl));

  HandlerServiceStub.fromHandle(
      core.MojoHandle handle, [HandlerService impl])
      : super(new _HandlerServiceStubControl.fromHandle(handle, impl));

  static HandlerServiceStub newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For HandlerServiceStub"));
    return new HandlerServiceStub.fromEndpoint(endpoint);
  }


  void createSession(String recipe,void callback(HandlerStatus status, String sessionId)) {
    return impl.createSession(recipe,callback);
  }
  void restoreSession(String sessionId,void callback(HandlerStatus status)) {
    return impl.restoreSession(sessionId,callback);
  }
  void stopSession(String sessionId,void callback(HandlerStatus status)) {
    return impl.stopSession(sessionId,callback);
  }
  void forkSession(String parentSessionId,void callback(HandlerStatus status, String sessionId)) {
    return impl.forkSession(parentSessionId,callback);
  }
  void linkSession(String sessionId,void callback(HandlerStatus status)) {
    return impl.linkSession(sessionId,callback);
  }
  void updateSession(String sessionId,List<String> jsonAddSteps,List<String> jsonRemoveSteps,void callback(HandlerStatus status)) {
    return impl.updateSession(sessionId,jsonAddSteps,jsonRemoveSteps,callback);
  }
  void addObserver(SessionObserverInterface observer) {
    return impl.addObserver(observer);
  }
}

const int _sessionObserverMethodOnSessionsStartedName = 0;
const int _sessionObserverMethodOnSessionsStoppedName = 1;

class _SessionObserverServiceDescription implements service_describer.ServiceDescription {
  void getTopLevelInterface(Function responder) {
    responder(null);
  }

  void getTypeDefinition(String typeKey, Function responder) {
    responder(null);
  }

  void getAllTypeDefinitions(Function responder) {
    responder(null);
  }
}

abstract class SessionObserver {
  static const String serviceName = null;

  static service_describer.ServiceDescription _cachedServiceDescription;
  static service_describer.ServiceDescription get serviceDescription {
    if (_cachedServiceDescription == null) {
      _cachedServiceDescription = new _SessionObserverServiceDescription();
    }
    return _cachedServiceDescription;
  }

  static SessionObserverProxy connectToService(
      bindings.ServiceConnector s, String url, [String serviceName]) {
    SessionObserverProxy p = new SessionObserverProxy.unbound();
    String name = serviceName ?? SessionObserver.serviceName;
    if ((name == null) || name.isEmpty) {
      throw new core.MojoApiError(
          "If an interface has no ServiceName, then one must be provided.");
    }
    s.connectToService(url, p, name);
    return p;
  }
  void onSessionsStarted(List<String> sessionIds);
  void onSessionsStopped(List<String> sessionIds);
}

abstract class SessionObserverInterface
    implements bindings.MojoInterface<SessionObserver>,
               SessionObserver {
  factory SessionObserverInterface([SessionObserver impl]) =>
      new SessionObserverStub.unbound(impl);

  factory SessionObserverInterface.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint,
      [SessionObserver impl]) =>
      new SessionObserverStub.fromEndpoint(endpoint, impl);

  factory SessionObserverInterface.fromMock(
      SessionObserver mock) =>
      new SessionObserverProxy.fromMock(mock);
}

abstract class SessionObserverInterfaceRequest
    implements bindings.MojoInterface<SessionObserver>,
               SessionObserver {
  factory SessionObserverInterfaceRequest() =>
      new SessionObserverProxy.unbound();
}

class _SessionObserverProxyControl
    extends bindings.ProxyMessageHandler
    implements bindings.ProxyControl<SessionObserver> {
  SessionObserver impl;

  _SessionObserverProxyControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) : super.fromEndpoint(endpoint);

  _SessionObserverProxyControl.fromHandle(
      core.MojoHandle handle) : super.fromHandle(handle);

  _SessionObserverProxyControl.unbound() : super.unbound();

  String get serviceName => SessionObserver.serviceName;

  void handleResponse(bindings.ServiceMessage message) {
    switch (message.header.type) {
      default:
        proxyError("Unexpected message type: ${message.header.type}");
        close(immediate: true);
        break;
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_SessionObserverProxyControl($superString)";
  }
}

class SessionObserverProxy
    extends bindings.Proxy<SessionObserver>
    implements SessionObserver,
               SessionObserverInterface,
               SessionObserverInterfaceRequest {
  SessionObserverProxy.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint)
      : super(new _SessionObserverProxyControl.fromEndpoint(endpoint));

  SessionObserverProxy.fromHandle(core.MojoHandle handle)
      : super(new _SessionObserverProxyControl.fromHandle(handle));

  SessionObserverProxy.unbound()
      : super(new _SessionObserverProxyControl.unbound());

  factory SessionObserverProxy.fromMock(SessionObserver mock) {
    SessionObserverProxy newMockedProxy =
        new SessionObserverProxy.unbound();
    newMockedProxy.impl = mock;
    return newMockedProxy;
  }

  static SessionObserverProxy newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For SessionObserverProxy"));
    return new SessionObserverProxy.fromEndpoint(endpoint);
  }


  void onSessionsStarted(List<String> sessionIds) {
    if (impl != null) {
      impl.onSessionsStarted(sessionIds);
      return;
    }
    if (!ctrl.isBound) {
      ctrl.proxyError("The Proxy is closed.");
      return;
    }
    var params = new _SessionObserverOnSessionsStartedParams();
    params.sessionIds = sessionIds;
    ctrl.sendMessage(params,
        _sessionObserverMethodOnSessionsStartedName);
  }
  void onSessionsStopped(List<String> sessionIds) {
    if (impl != null) {
      impl.onSessionsStopped(sessionIds);
      return;
    }
    if (!ctrl.isBound) {
      ctrl.proxyError("The Proxy is closed.");
      return;
    }
    var params = new _SessionObserverOnSessionsStoppedParams();
    params.sessionIds = sessionIds;
    ctrl.sendMessage(params,
        _sessionObserverMethodOnSessionsStoppedName);
  }
}

class _SessionObserverStubControl
    extends bindings.StubMessageHandler
    implements bindings.StubControl<SessionObserver> {
  SessionObserver _impl;

  _SessionObserverStubControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [SessionObserver impl])
      : super.fromEndpoint(endpoint, autoBegin: impl != null) {
    _impl = impl;
  }

  _SessionObserverStubControl.fromHandle(
      core.MojoHandle handle, [SessionObserver impl])
      : super.fromHandle(handle, autoBegin: impl != null) {
    _impl = impl;
  }

  _SessionObserverStubControl.unbound([this._impl]) : super.unbound();

  String get serviceName => SessionObserver.serviceName;



  void handleMessage(bindings.ServiceMessage message) {
    if (bindings.ControlMessageHandler.isControlMessage(message)) {
      bindings.ControlMessageHandler.handleMessage(
          this, 0, message);
      return;
    }
    if (_impl == null) {
      throw new core.MojoApiError("$this has no implementation set");
    }
    switch (message.header.type) {
      case _sessionObserverMethodOnSessionsStartedName:
        var params = _SessionObserverOnSessionsStartedParams.deserialize(
            message.payload);
        _impl.onSessionsStarted(params.sessionIds);
        break;
      case _sessionObserverMethodOnSessionsStoppedName:
        var params = _SessionObserverOnSessionsStoppedParams.deserialize(
            message.payload);
        _impl.onSessionsStopped(params.sessionIds);
        break;
      default:
        throw new bindings.MojoCodecError("Unexpected message name");
        break;
    }
  }

  SessionObserver get impl => _impl;
  set impl(SessionObserver d) {
    if (d == null) {
      throw new core.MojoApiError("$this: Cannot set a null implementation");
    }
    if (isBound && (_impl == null)) {
      beginHandlingEvents();
    }
    _impl = d;
  }

  @override
  void bind(core.MojoMessagePipeEndpoint endpoint) {
    super.bind(endpoint);
    if (!isOpen && (_impl != null)) {
      beginHandlingEvents();
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_SessionObserverStubControl($superString)";
  }

  int get version => 0;
}

class SessionObserverStub
    extends bindings.Stub<SessionObserver>
    implements SessionObserver,
               SessionObserverInterface,
               SessionObserverInterfaceRequest {
  SessionObserverStub.unbound([SessionObserver impl])
      : super(new _SessionObserverStubControl.unbound(impl));

  SessionObserverStub.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [SessionObserver impl])
      : super(new _SessionObserverStubControl.fromEndpoint(endpoint, impl));

  SessionObserverStub.fromHandle(
      core.MojoHandle handle, [SessionObserver impl])
      : super(new _SessionObserverStubControl.fromHandle(handle, impl));

  static SessionObserverStub newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For SessionObserverStub"));
    return new SessionObserverStub.fromEndpoint(endpoint);
  }


  void onSessionsStarted(List<String> sessionIds) {
    return impl.onSessionsStarted(sessionIds);
  }
  void onSessionsStopped(List<String> sessionIds) {
    return impl.onSessionsStopped(sessionIds);
  }
}

const int _sessionGraphServiceMethodGetGraphName = 0;

class _SessionGraphServiceServiceDescription implements service_describer.ServiceDescription {
  void getTopLevelInterface(Function responder) {
    responder(null);
  }

  void getTypeDefinition(String typeKey, Function responder) {
    responder(null);
  }

  void getAllTypeDefinitions(Function responder) {
    responder(null);
  }
}

abstract class SessionGraphService {
  static const String serviceName = "modular::SessionGraphService";

  static service_describer.ServiceDescription _cachedServiceDescription;
  static service_describer.ServiceDescription get serviceDescription {
    if (_cachedServiceDescription == null) {
      _cachedServiceDescription = new _SessionGraphServiceServiceDescription();
    }
    return _cachedServiceDescription;
  }

  static SessionGraphServiceProxy connectToService(
      bindings.ServiceConnector s, String url, [String serviceName]) {
    SessionGraphServiceProxy p = new SessionGraphServiceProxy.unbound();
    String name = serviceName ?? SessionGraphService.serviceName;
    if ((name == null) || name.isEmpty) {
      throw new core.MojoApiError(
          "If an interface has no ServiceName, then one must be provided.");
    }
    s.connectToService(url, p, name);
    return p;
  }
  void getGraph(String sessionId,graph_mojom.GraphInterfaceRequest graph,void callback(HandlerStatus status));
}

abstract class SessionGraphServiceInterface
    implements bindings.MojoInterface<SessionGraphService>,
               SessionGraphService {
  factory SessionGraphServiceInterface([SessionGraphService impl]) =>
      new SessionGraphServiceStub.unbound(impl);

  factory SessionGraphServiceInterface.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint,
      [SessionGraphService impl]) =>
      new SessionGraphServiceStub.fromEndpoint(endpoint, impl);

  factory SessionGraphServiceInterface.fromMock(
      SessionGraphService mock) =>
      new SessionGraphServiceProxy.fromMock(mock);
}

abstract class SessionGraphServiceInterfaceRequest
    implements bindings.MojoInterface<SessionGraphService>,
               SessionGraphService {
  factory SessionGraphServiceInterfaceRequest() =>
      new SessionGraphServiceProxy.unbound();
}

class _SessionGraphServiceProxyControl
    extends bindings.ProxyMessageHandler
    implements bindings.ProxyControl<SessionGraphService> {
  SessionGraphService impl;

  _SessionGraphServiceProxyControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) : super.fromEndpoint(endpoint);

  _SessionGraphServiceProxyControl.fromHandle(
      core.MojoHandle handle) : super.fromHandle(handle);

  _SessionGraphServiceProxyControl.unbound() : super.unbound();

  String get serviceName => SessionGraphService.serviceName;

  void handleResponse(bindings.ServiceMessage message) {
    switch (message.header.type) {
      case _sessionGraphServiceMethodGetGraphName:
        var r = SessionGraphServiceGetGraphResponseParams.deserialize(
            message.payload);
        if (!message.header.hasRequestId) {
          proxyError("Expected a message with a valid request Id.");
          return;
        }
        Function callback = callbackMap[message.header.requestId];
        if (callback == null) {
          proxyError(
              "Message had unknown request Id: ${message.header.requestId}");
          return;
        }
        callbackMap.remove(message.header.requestId);
        callback(r.status );
        break;
      default:
        proxyError("Unexpected message type: ${message.header.type}");
        close(immediate: true);
        break;
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_SessionGraphServiceProxyControl($superString)";
  }
}

class SessionGraphServiceProxy
    extends bindings.Proxy<SessionGraphService>
    implements SessionGraphService,
               SessionGraphServiceInterface,
               SessionGraphServiceInterfaceRequest {
  SessionGraphServiceProxy.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint)
      : super(new _SessionGraphServiceProxyControl.fromEndpoint(endpoint));

  SessionGraphServiceProxy.fromHandle(core.MojoHandle handle)
      : super(new _SessionGraphServiceProxyControl.fromHandle(handle));

  SessionGraphServiceProxy.unbound()
      : super(new _SessionGraphServiceProxyControl.unbound());

  factory SessionGraphServiceProxy.fromMock(SessionGraphService mock) {
    SessionGraphServiceProxy newMockedProxy =
        new SessionGraphServiceProxy.unbound();
    newMockedProxy.impl = mock;
    return newMockedProxy;
  }

  static SessionGraphServiceProxy newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For SessionGraphServiceProxy"));
    return new SessionGraphServiceProxy.fromEndpoint(endpoint);
  }


  void getGraph(String sessionId,graph_mojom.GraphInterfaceRequest graph,void callback(HandlerStatus status)) {
    if (impl != null) {
      impl.getGraph(sessionId,graph,callback);
      return;
    }
    var params = new _SessionGraphServiceGetGraphParams();
    params.sessionId = sessionId;
    params.graph = graph;
    Function zonedCallback;
    if (identical(Zone.current, Zone.ROOT)) {
      zonedCallback = callback;
    } else {
      Zone z = Zone.current;
      zonedCallback = ((HandlerStatus status) {
        z.bindCallback(() {
          callback(status);
        })();
      });
    }
    ctrl.sendMessageWithRequestId(
        params,
        _sessionGraphServiceMethodGetGraphName,
        -1,
        bindings.MessageHeader.kMessageExpectsResponse,
        zonedCallback);
  }
}

class _SessionGraphServiceStubControl
    extends bindings.StubMessageHandler
    implements bindings.StubControl<SessionGraphService> {
  SessionGraphService _impl;

  _SessionGraphServiceStubControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [SessionGraphService impl])
      : super.fromEndpoint(endpoint, autoBegin: impl != null) {
    _impl = impl;
  }

  _SessionGraphServiceStubControl.fromHandle(
      core.MojoHandle handle, [SessionGraphService impl])
      : super.fromHandle(handle, autoBegin: impl != null) {
    _impl = impl;
  }

  _SessionGraphServiceStubControl.unbound([this._impl]) : super.unbound();

  String get serviceName => SessionGraphService.serviceName;


  Function _sessionGraphServiceGetGraphResponseParamsResponder(
      int requestId) {
  return (HandlerStatus status) {
      var result = new SessionGraphServiceGetGraphResponseParams();
      result.status = status;
      sendResponse(buildResponseWithId(
          result,
          _sessionGraphServiceMethodGetGraphName,
          requestId,
          bindings.MessageHeader.kMessageIsResponse));
    };
  }

  void handleMessage(bindings.ServiceMessage message) {
    if (bindings.ControlMessageHandler.isControlMessage(message)) {
      bindings.ControlMessageHandler.handleMessage(
          this, 0, message);
      return;
    }
    if (_impl == null) {
      throw new core.MojoApiError("$this has no implementation set");
    }
    switch (message.header.type) {
      case _sessionGraphServiceMethodGetGraphName:
        var params = _SessionGraphServiceGetGraphParams.deserialize(
            message.payload);
        _impl.getGraph(params.sessionId, params.graph, _sessionGraphServiceGetGraphResponseParamsResponder(message.header.requestId));
        break;
      default:
        throw new bindings.MojoCodecError("Unexpected message name");
        break;
    }
  }

  SessionGraphService get impl => _impl;
  set impl(SessionGraphService d) {
    if (d == null) {
      throw new core.MojoApiError("$this: Cannot set a null implementation");
    }
    if (isBound && (_impl == null)) {
      beginHandlingEvents();
    }
    _impl = d;
  }

  @override
  void bind(core.MojoMessagePipeEndpoint endpoint) {
    super.bind(endpoint);
    if (!isOpen && (_impl != null)) {
      beginHandlingEvents();
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_SessionGraphServiceStubControl($superString)";
  }

  int get version => 0;
}

class SessionGraphServiceStub
    extends bindings.Stub<SessionGraphService>
    implements SessionGraphService,
               SessionGraphServiceInterface,
               SessionGraphServiceInterfaceRequest {
  SessionGraphServiceStub.unbound([SessionGraphService impl])
      : super(new _SessionGraphServiceStubControl.unbound(impl));

  SessionGraphServiceStub.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [SessionGraphService impl])
      : super(new _SessionGraphServiceStubControl.fromEndpoint(endpoint, impl));

  SessionGraphServiceStub.fromHandle(
      core.MojoHandle handle, [SessionGraphService impl])
      : super(new _SessionGraphServiceStubControl.fromHandle(handle, impl));

  static SessionGraphServiceStub newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For SessionGraphServiceStub"));
    return new SessionGraphServiceStub.fromEndpoint(endpoint);
  }


  void getGraph(String sessionId,graph_mojom.GraphInterfaceRequest graph,void callback(HandlerStatus status)) {
    return impl.getGraph(sessionId,graph,callback);
  }
}



