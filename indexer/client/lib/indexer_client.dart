// Copyright 2016 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'dart:async';
import 'dart:collection';
import 'dart:convert';
import 'dart:developer';

import 'package:common/uri_loader.dart';
import 'package:modular_core/log.dart' as log;
import 'package:modular_core/util/timeline_helper.dart';
import 'package:parser/expression.dart';
import 'package:parser/manifest.dart';

const String _indexPath = '/index.json';

/// Performs queries on a module index and does basic resolution of module
/// inputs and outputs.
///
/// The index is generated by the tool at //indexer/pipeline/bin/run.dart.
class IndexerClient {
  static final log.Logger _log = log.log("indexer.IndexerClient");
  final String _auxIndex;
  final Uri _baseUri;
  final UriLoader _uriLoader;
  List<Manifest> _index;
  List<Manifest> get index => _index;

  /// Creates a new indexer client:
  ///  - [this._baseUri]: URI of the directory containing the manifest index
  /// file defined by [_indexPath].
  ///  - [this._uriLoader]: Network data loader
  ///  - [auxIndex]: Optional. Path to an auxiliary manifest index file.
  IndexerClient(this._baseUri, this._uriLoader, {final String auxIndex: null})
      : _auxIndex = auxIndex;

  /// Returns topologically ordered DAGs of Manifests which can be used to
  /// satisfy the inputs of [manifest]. The graphs are constructed from
  /// Manifests found in [_index] and [_auxIndex]. [maxCandidates] is an upper
  /// bound on the number of resolutions spawned at each level in the graph
  /// (where a level consists of the set of Manifests used to resolve the level
  /// before it, e.g. the first level is any group of Manifests that completely
  /// satisfies the inputs of [manifest]). [maxLevels] is an upper bound on the
  /// number of levels in any given resolution. Only resolutions in which every
  /// input has been resolved are returned.
  // TODO(dennischeng): Implement resolveManifestOutputs() and factor out the
  // overlap with resolveManifestInputs().
  List<List<Manifest>> resolveManifestInputs(final Manifest manifest,
      {final int maxCandidates: 3, final int maxLevels: 3}) {
    if (_index == null) {
      _log.severe("The index has not been initialized!");
      return <List<Manifest>>[];
    }
    if (manifest.input.isEmpty || maxCandidates == 0 || maxLevels == 0) {
      return <List<Manifest>>[];
    }

    final List<List<Manifest>> resolutions = <List<Manifest>>[];
    _resolveManifestInputs(manifest.input.toSet(), <Manifest>[],
        new Set<PathExpr>(), resolutions, 1, maxCandidates, maxLevels);

    return resolutions;
  }

  /// Attempts to resolve [inputs] by searching the index for Manifests
  /// containing the necessary outputs. [resolution] contains the Manifests
  /// used in the current attempt and may be unresolvable.
  void _resolveManifestInputs(
      final Set<PathExpr> inputs,
      final List<Manifest> resolution,
      final Set<PathExpr> outputsInResolution,
      final List<List<Manifest>> resolutions,
      final int level,
      final int maxCandidates,
      final int maxLevels) {
    inputs.removeWhere(
        (final PathExpr input) => input.properties[0].cardinality.isOptional);

    // Remove any inputs that can be satisfied by outputs in the current
    // resolution.
    inputs.removeWhere((final PathExpr input) => outputsInResolution.any(
        (final PathExpr output) => input.isContainedIn(output,
            equality: (final Property p1, final Property p2) =>
                p1.equalsIgnoringCardinality(p2))));

    if (inputs.isEmpty) {
      // [inputs] has been resolved completely.
      return;
    }

    if (level > maxLevels) {
      return;
    }

    // TODO(dennischeng): Use a heuristic that incorporates relevance for
    // choosing which Manifest to use as a resolution.
    final List<Manifest> candidates = getRankedMatchingManifests(
        new ManifestQuery(output: inputs),
        maxResults: level == 1 ? null : maxCandidates);

    if (candidates.isEmpty) {
      // No manifests in the index can be used to satisfy [inputs].
      return;
    }

    // Traverse each possible resolving Manifest adding complete resolutions to
    // [allTrees] when they are found.
    for (final Manifest candidate in candidates) {
      final List<Manifest> resolutionCopy = new List<Manifest>.from(resolution);
      if (!resolutionCopy.contains(candidate)) {
        // Only add candidates not already in the resolution.
        resolutionCopy.add(candidate);
      }

      final Set<PathExpr> outputsInResolutionCopy =
          new HashSet.from(outputsInResolution);
      if (candidate.input.isEmpty) {
        // Only add new outputs if we are sure we won't introduce a cycle into
        // the resolution.
        outputsInResolutionCopy.addAll(candidate.output);
      }

      // The subset of [inputs] that wasn't resolved by [candidate].
      final Set<PathExpr> remainingInputs =
          inputs.difference(candidate.output.toSet());
      _resolveManifestInputs(
          remainingInputs,
          resolutionCopy,
          outputsInResolutionCopy,
          resolutions,
          level,
          maxCandidates,
          maxLevels);
      if (remainingInputs.isNotEmpty) {
        continue;
      }

      // The inputs of [candidate] that we have to resolve.
      final Set<PathExpr> candidateInputs = candidate.input.toSet();
      if (candidateInputs.isNotEmpty) {
        _resolveManifestInputs(
            candidateInputs,
            resolutionCopy,
            outputsInResolutionCopy,
            resolutions,
            level + 1,
            maxCandidates,
            maxLevels);
        if (candidateInputs.isNotEmpty) {
          continue;
        }
      }

      // remainingInputs.isEmpty && candidateInputs.isEmpty, i.e. we've reached
      // a resolution that satisfies our initial inputs and in which every
      // input is also satisfied.
      resolutions.add(resolutionCopy);
    }
  }

  /// Returns a list, of at most [maxResults] Manifests, extracted from the
  /// index and in order of similarity (similarity as defined in
  /// _ManifestQueryResult). If [maxResults] is null, the size of the result is
  /// unbounded.
  List<Manifest> getRankedMatchingManifests(final ManifestQuery query,
      {final int maxResults: 10}) {
    if (_index == null) {
      _log.severe("The index has not been initialized!");
      return <Manifest>[];
    }
    List<_ManifestQueryResult> queryResults =
        _getMatchingManifestQueryResults(query);
    queryResults.sort();
    if (maxResults != null && queryResults.length > maxResults) {
      queryResults.removeRange(maxResults, queryResults.length);
    }
    return queryResults
        .map((final _ManifestQueryResult result) => result.manifest)
        .toList();
  }

  /// Returns a list of Manifests extracted from the index where each Manifest
  /// satisfies [query].
  List<Manifest> getMatchingManifests(final ManifestQuery query) {
    if (_index == null) {
      _log.severe("The index has not been initialized!");
      return <Manifest>[];
    }
    return _getMatchingManifestQueryResults(query)
        .map((final _ManifestQueryResult result) => result.manifest)
        .toList();
  }

  List<_ManifestQueryResult> _getMatchingManifestQueryResults(
      final ManifestQuery query) {
    return _index
        .map((final Manifest manifest) =>
            new _ManifestQueryResult(query, manifest))
        .where((final _ManifestQueryResult result) => result.matches)
        .toList();
  }

  /// Loads a list of Manifests from the main index file, and the auxiliary
  /// index file if present.
  Future<Null> initialize() async {
    final TimelineTask timelineTask = new TimelineTask()
      ..start("$runtimeType getModuleManifestIndex");
    final List<List<Manifest>> indexes = await Future
        .wait([_getIndexOrThrow(_indexPath), _getIndexOrThrow(_auxIndex)]);
    _index = indexes.expand((final List<Manifest> i) => i).toList();
    timelineTask.finish();
  }

  /// Same as [initialize()], except also returns the index in a Future.
  Future<List<Manifest>> initializeAndGetIndex() async {
    await initialize();
    return _index;
  }

  Future<List<Manifest>> _fetchManifestIndex(final String path) async {
    return traceAsync('$runtimeType _fetchManifestIndex()', () async {
      final Uri indexUri = _baseUri.resolve(path);
      final String content = await _uriLoader.getString(indexUri);
      if (content == null) {
        _log.severe("No modular index found at $path.");
        return new Future<List<Manifest>>.value(<Manifest>[]);
      }
      return JSON.decode(content).map((i) => new Manifest.fromJson(i)).toList();
    });
  }

  /// Parses the manifest index and returns a list of modules.
  Future<List<Manifest>> _getIndexOrThrow(final String path) async {
    if (path == null) return new Future.value(<Manifest>[]);
    return _fetchManifestIndex(path).catchError((e) {
      throw new Exception("Could not parse index: $e");
    });
  }
}

/// Represents a query to perform against the manifest index.
class ManifestQuery {
  final HashSet<Verb> verb;
  final HashSet<PathExpr> input;
  final HashSet<PathExpr> output;
  final HashSet<PathExpr> display;
  final HashSet<PathExpr> compose;

  /// If true, then a Manifest must contain every component of a
  /// ManifestQuery's PathExpr fields in order to be considered a match. If
  /// false, then at least one component from each PathExpr field must match.
  final bool completeMatch;

  /// Stores fields that correspond to fields in a Manifest object. To generate
  /// a match with a ManifestQuery, each field in the Manifest must contain at
  /// least one of the components in the corresponding ManifestQuery field
  /// (sometimes more). Null ManifestQuery fields represent wildcards.
  /// For instance, a ManifestQuery constructed with no arguments will match
  /// all Manifests in the index. A ManifestQuery constructed with an empty
  /// output list will match all Manifests in the index that produce no output
  /// (note that this is different than using a null output list, which is
  /// equivalent to ignoring output).
  ManifestQuery(
      {final Iterable<Verb> verb,
      final Iterable<PathExpr> input,
      final Iterable<PathExpr> output,
      final Iterable<PathExpr> display,
      final Iterable<PathExpr> compose,
      final bool completeMatch: true})
      : verb = verb == null ? null : (new HashSet<Verb>.from(verb)),
        input = input == null ? null : (new HashSet<PathExpr>.from(input)),
        output = output == null ? null : (new HashSet<PathExpr>.from(output)),
        display =
            display == null ? null : (new HashSet<PathExpr>.from(display)),
        compose =
            compose == null ? null : (new HashSet<PathExpr>.from(compose)),
        completeMatch = completeMatch;
}

/// Represents the result of evaluating a query on a Manifest. Also contains a
/// score, [hitsAndMisses], that encodes the similarity of the Manifest to the
/// query. A Manifest is considered more similar to a query than another if it
/// has more components in common with the Manifest, fewer missing components,
/// and fewer components not in the query (compared in that order).
class _ManifestQueryResult implements Comparable {
  final ManifestQuery query;
  final Manifest manifest;

  /// Whether or not [manifest] is considered similar to [query].
  final bool matches;

  /// Stores the number of query components in the Manifest (hits), number of
  /// query components not in the Manifest (majorMisses), and number of
  /// Manifest components not in the query (minorMisses).
  final _HitsAndMisses hitsAndMisses;

  _ManifestQueryResult._internal(
      this.query, this.manifest, this.matches, this.hitsAndMisses);

  factory _ManifestQueryResult(
      final ManifestQuery query, final Manifest manifest) {
    final List<_HitsAndMisses> hitsAndMissesPerField =
        new List<_HitsAndMisses>();
    // Wildcards don't affect hits and misses.
    if (query.verb != null) {
      if (query.verb.contains(manifest.verb)) {
        hitsAndMissesPerField.add(new _HitsAndMisses(hits: 1));
      } else {
        hitsAndMissesPerField.add(new _HitsAndMisses(majorMisses: 1));
      }
    }
    hitsAndMissesPerField.add(_countHitsAndMisses(query.input, manifest.input));
    hitsAndMissesPerField
        .add(_countHitsAndMisses(query.output, manifest.output));
    hitsAndMissesPerField
        .add(_countHitsAndMisses(query.display, manifest.display));
    hitsAndMissesPerField
        .add(_countHitsAndMisses(query.compose, manifest.compose));

    // If the query has completeMatch set, then every component of the query must be
    // contained in the matching Manifest. Queries without completeMatch set only
    // require that at least one component be contained in a matching Manifest.
    final bool overallMatch = hitsAndMissesPerField.every(
        (final _HitsAndMisses h) =>
            h.majorMisses == 0 || (!query.completeMatch && h.hits > 0));
    final _HitsAndMisses totalHitsAndMisses = new _HitsAndMisses();
    hitsAndMissesPerField
        .forEach((final _HitsAndMisses h) => totalHitsAndMisses.add(h));

    return new _ManifestQueryResult._internal(
        query, manifest, overallMatch, totalHitsAndMisses);
  }

  /// Returns a count for the [hits], [majorMisses], and [minorMisses] between
  /// [queryField] and [manifestField].
  static _HitsAndMisses _countHitsAndMisses(final Iterable<PathExpr> queryField,
      final Iterable<PathExpr> manifestField) {
    // Wildcard in query--doesn't contribute to hits and misses.
    if (queryField == null) {
      return new _HitsAndMisses();
    }
    // If the Manifest also contains an empty field (usually denoted by a null
    // value), then we have a match with the empty query field. Otherwise, the
    // Manifest contains |manifestField.length| "extra" components that aren't
    // in the query.
    if (queryField.isEmpty) {
      return manifestField == null || manifestField.isEmpty
          ? new _HitsAndMisses(hits: 1)
          : new _HitsAndMisses(minorMisses: manifestField.length);
    }
    // The Manifest field is empty but the query field isn't, i.e. all of the
    // query components aren't in the Manifest, and are major misses.
    if (manifestField == null || manifestField.isEmpty) {
      return new _HitsAndMisses(majorMisses: queryField.length);
    }

    int hits = queryField.where(manifestField.contains).length;
    return new _HitsAndMisses(
        hits: hits,
        majorMisses: queryField.length - hits,
        minorMisses: manifestField.length - hits);
  }

  /// Used to order Manifests in terms of their similarity to a query.
  ///
  /// Results are first ordered by their number of hits, then major misses, and
  /// finally minor misses. Results with more hits get ordered before those
  /// with fewer hits and results with fewer misses get ordered before those
  /// with more misses.
  @override
  int compareTo(other) {
    // TODO(dennischeng): This is a very rough/naive means to rank query results
    // based purely on similarity. Refine this to allow for more accurate query
    // rankings, ideally by incoporating some notion of relevance.
    assert(other is _ManifestQueryResult);
    return hitsAndMisses.compareTo(other.hitsAndMisses);
  }

  @override
  bool operator ==(other) =>
      other is _ManifestQueryResult && hitsAndMisses == other.hitsAndMisses;
}

class _HitsAndMisses implements Comparable {
  /// [hits], [majorMisses], and [minorMisses] are used to determine the
  /// similarity of a Manifest to a query. See _ManifestQueryResult.compareTo
  /// for a more precise definition of similarity.
  /// The number of components in a query also in the given Manifest.
  int hits;

  /// The number of components in a query not in the given Manifest.
  int majorMisses;

  /// The number of components in the given Manifest not in a query.
  int minorMisses;

  _HitsAndMisses({this.hits: 0, this.majorMisses: 0, this.minorMisses: 0});

  void add(final _HitsAndMisses other) {
    hits += other.hits;
    majorMisses += other.majorMisses;
    minorMisses += other.minorMisses;
  }

  @override
  int compareTo(other) {
    assert(other is _HitsAndMisses);
    if (hits != other.hits) {
      return hits > other.hits ? -1 : 1;
    }
    if (majorMisses != other.majorMisses) {
      return majorMisses < other.majorMisses ? -1 : 1;
    }
    return minorMisses == other.minorMisses
        ? 0
        : (minorMisses < other.minorMisses ? -1 : 1);
  }

  @override
  bool operator ==(other) =>
      other is _HitsAndMisses &&
      hits == other.hits &&
      majorMisses == other.majorMisses &&
      minorMisses == other.minorMisses;
}
