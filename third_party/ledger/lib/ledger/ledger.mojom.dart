// WARNING: DO NOT EDIT. This file was generated by a program.
// See $MOJO_SDK/tools/bindings/mojom_bindings_generator.py.

library ledger_mojom;
import 'dart:async';
import 'package:mojo/bindings.dart' as bindings;
import 'package:mojo/core.dart' as core;
import 'package:mojo/mojo/bindings/types/service_describer.mojom.dart' as service_describer;

class Status extends bindings.MojoEnum {
  static const Status ok = const Status._(0);
  static const Status authenticationError = const Status._(1);
  static const Status pageNotFound = const Status._(2);
  static const Status keyNotFound = const Status._(3);
  static const Status referenceNotFound = const Status._(4);
  static const Status ioError = const Status._(5);
  static const Status transactionAlreadyInProgress = const Status._(6);
  static const Status noTransactionInProgress = const Status._(7);
  static const Status unknownError = const Status._(-1);

  const Status._(int v) : super(v);

  static const Map<String, Status> valuesMap = const {
    "ok": ok,
    "authenticationError": authenticationError,
    "pageNotFound": pageNotFound,
    "keyNotFound": keyNotFound,
    "referenceNotFound": referenceNotFound,
    "ioError": ioError,
    "transactionAlreadyInProgress": transactionAlreadyInProgress,
    "noTransactionInProgress": noTransactionInProgress,
    "unknownError": unknownError,
  };
  static const List<Status> values = const [
    ok,
    authenticationError,
    pageNotFound,
    keyNotFound,
    referenceNotFound,
    ioError,
    transactionAlreadyInProgress,
    noTransactionInProgress,
    unknownError,
  ];

  static Status valueOf(String name) => valuesMap[name];

  factory Status(int v) {
    switch (v) {
      case 0:
        return Status.ok;
      case 1:
        return Status.authenticationError;
      case 2:
        return Status.pageNotFound;
      case 3:
        return Status.keyNotFound;
      case 4:
        return Status.referenceNotFound;
      case 5:
        return Status.ioError;
      case 6:
        return Status.transactionAlreadyInProgress;
      case 7:
        return Status.noTransactionInProgress;
      case -1:
        return Status.unknownError;
      default:
        return null;
    }
  }

  static Status decode(bindings.Decoder decoder0, int offset) {
    int v = decoder0.decodeUint32(offset);
    Status result = new Status(v);
    if (result == null) {
      throw new bindings.MojoCodecError(
          'Bad value $v for enum Status.');
    }
    return result;
  }

  String toString() {
    switch(this) {
      case ok:
        return 'Status.ok';
      case authenticationError:
        return 'Status.authenticationError';
      case pageNotFound:
        return 'Status.pageNotFound';
      case keyNotFound:
        return 'Status.keyNotFound';
      case referenceNotFound:
        return 'Status.referenceNotFound';
      case ioError:
        return 'Status.ioError';
      case transactionAlreadyInProgress:
        return 'Status.transactionAlreadyInProgress';
      case noTransactionInProgress:
        return 'Status.noTransactionInProgress';
      case unknownError:
        return 'Status.unknownError';
      default:
        return null;
    }
  }

  int toJson() => mojoEnumValue;
}

class ConflictResolutionPolicy extends bindings.MojoEnum {
  static const ConflictResolutionPolicy none = const ConflictResolutionPolicy._(0);
  static const ConflictResolutionPolicy lastOneWins = const ConflictResolutionPolicy._(1);
  static const ConflictResolutionPolicy custom = const ConflictResolutionPolicy._(2);

  const ConflictResolutionPolicy._(int v) : super(v);

  static const Map<String, ConflictResolutionPolicy> valuesMap = const {
    "none": none,
    "lastOneWins": lastOneWins,
    "custom": custom,
  };
  static const List<ConflictResolutionPolicy> values = const [
    none,
    lastOneWins,
    custom,
  ];

  static ConflictResolutionPolicy valueOf(String name) => valuesMap[name];

  factory ConflictResolutionPolicy(int v) {
    switch (v) {
      case 0:
        return ConflictResolutionPolicy.none;
      case 1:
        return ConflictResolutionPolicy.lastOneWins;
      case 2:
        return ConflictResolutionPolicy.custom;
      default:
        return null;
    }
  }

  static ConflictResolutionPolicy decode(bindings.Decoder decoder0, int offset) {
    int v = decoder0.decodeUint32(offset);
    ConflictResolutionPolicy result = new ConflictResolutionPolicy(v);
    if (result == null) {
      throw new bindings.MojoCodecError(
          'Bad value $v for enum ConflictResolutionPolicy.');
    }
    return result;
  }

  String toString() {
    switch(this) {
      case none:
        return 'ConflictResolutionPolicy.none';
      case lastOneWins:
        return 'ConflictResolutionPolicy.lastOneWins';
      case custom:
        return 'ConflictResolutionPolicy.custom';
      default:
        return null;
    }
  }

  int toJson() => mojoEnumValue;
}



class Identity extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  List<int> userId = null;

  Identity() : super(kVersions.last.size);

  Identity.init(
    List<int> this.userId
  ) : super(kVersions.last.size);

  static Identity deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static Identity decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    Identity result = new Identity();
    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.userId = decoder0.decodeUint8Array(8, bindings.kNothingNullable, bindings.kUnspecifiedArrayLength);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "Identity";
    String fieldName;
    try {
      fieldName = "userId";
      encoder0.encodeUint8Array(userId, 8, bindings.kNothingNullable, bindings.kUnspecifiedArrayLength);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "Identity("
           "userId: $userId" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["userId"] = userId;
    return map;
  }
}


class Stream extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(24, 0)
  ];
  int size = 0;
  core.MojoDataPipeConsumer data = null;

  Stream() : super(kVersions.last.size);

  Stream.init(
    int this.size, 
    core.MojoDataPipeConsumer this.data
  ) : super(kVersions.last.size);

  static Stream deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static Stream decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    Stream result = new Stream();
    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.size = decoder0.decodeUint64(8);
    }
    if (mainDataHeader.version >= 0) {
      
      result.data = decoder0.decodeConsumerHandle(16, false);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "Stream";
    String fieldName;
    try {
      fieldName = "size";
      encoder0.encodeUint64(size, 8);
      fieldName = "data";
      encoder0.encodeConsumerHandle(data, 16, false);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "Stream("
           "size: $size" ", "
           "data: $data" ")";
  }

  Map toJson() {
    throw new bindings.MojoCodecError(
        'Object containing handles cannot be encoded to JSON.');
  }
}


class Reference extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  List<int> opaqueId = null;

  Reference() : super(kVersions.last.size);

  Reference.init(
    List<int> this.opaqueId
  ) : super(kVersions.last.size);

  static Reference deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static Reference decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    Reference result = new Reference();
    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.opaqueId = decoder0.decodeUint8Array(8, bindings.kNothingNullable, bindings.kUnspecifiedArrayLength);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "Reference";
    String fieldName;
    try {
      fieldName = "opaqueId";
      encoder0.encodeUint8Array(opaqueId, 8, bindings.kNothingNullable, bindings.kUnspecifiedArrayLength);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "Reference("
           "opaqueId: $opaqueId" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["opaqueId"] = opaqueId;
    return map;
  }
}


class Entry extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(24, 0)
  ];
  List<int> key = null;
  List<int> value = null;

  Entry() : super(kVersions.last.size);

  Entry.init(
    List<int> this.key, 
    List<int> this.value
  ) : super(kVersions.last.size);

  static Entry deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static Entry decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    Entry result = new Entry();
    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.key = decoder0.decodeUint8Array(8, bindings.kNothingNullable, bindings.kUnspecifiedArrayLength);
    }
    if (mainDataHeader.version >= 0) {
      
      result.value = decoder0.decodeUint8Array(16, bindings.kArrayNullable, bindings.kUnspecifiedArrayLength);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "Entry";
    String fieldName;
    try {
      fieldName = "key";
      encoder0.encodeUint8Array(key, 8, bindings.kNothingNullable, bindings.kUnspecifiedArrayLength);
      fieldName = "value";
      encoder0.encodeUint8Array(value, 16, bindings.kArrayNullable, bindings.kUnspecifiedArrayLength);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "Entry("
           "key: $key" ", "
           "value: $value" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["key"] = key;
    map["value"] = value;
    return map;
  }
}


class EntryChange extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(32, 0)
  ];
  List<int> key = null;
  BytesOrReference newValue = null;

  EntryChange() : super(kVersions.last.size);

  EntryChange.init(
    List<int> this.key, 
    BytesOrReference this.newValue
  ) : super(kVersions.last.size);

  static EntryChange deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static EntryChange decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    EntryChange result = new EntryChange();
    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.key = decoder0.decodeUint8Array(8, bindings.kNothingNullable, bindings.kUnspecifiedArrayLength);
    }
    if (mainDataHeader.version >= 0) {
      
        result.newValue = BytesOrReference.decode(decoder0, 16);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "EntryChange";
    String fieldName;
    try {
      fieldName = "key";
      encoder0.encodeUint8Array(key, 8, bindings.kNothingNullable, bindings.kUnspecifiedArrayLength);
      fieldName = "newValue";
      encoder0.encodeUnion(newValue, 16, true);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "EntryChange("
           "key: $key" ", "
           "newValue: $newValue" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["key"] = key;
    map["newValue"] = newValue;
    return map;
  }
}


class PageChange extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(24, 0)
  ];
  int timestamp = 0;
  List<EntryChange> changes = null;

  PageChange() : super(kVersions.last.size);

  PageChange.init(
    int this.timestamp, 
    List<EntryChange> this.changes
  ) : super(kVersions.last.size);

  static PageChange deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static PageChange decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    PageChange result = new PageChange();
    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.timestamp = decoder0.decodeInt64(8);
    }
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(16, false);
      {
        var si1 = decoder1.decodeDataHeaderForPointerArray(bindings.kUnspecifiedArrayLength);
        result.changes = new List<EntryChange>(si1.numElements);
        for (int i1 = 0; i1 < si1.numElements; ++i1) {
          
          var decoder2 = decoder1.decodePointer(bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize * i1, false);
          result.changes[i1] = EntryChange.decode(decoder2);
        }
      }
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "PageChange";
    String fieldName;
    try {
      fieldName = "timestamp";
      encoder0.encodeInt64(timestamp, 8);
      fieldName = "changes";
      if (changes == null) {
        encoder0.encodeNullPointer(16, false);
      } else {
        var encoder1 = encoder0.encodePointerArray(changes.length, 16, bindings.kUnspecifiedArrayLength);
        for (int i0 = 0; i0 < changes.length; ++i0) {
          encoder1.encodeStruct(changes[i0], bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize * i0, false);
        }
      }
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "PageChange("
           "timestamp: $timestamp" ", "
           "changes: $changes" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["timestamp"] = timestamp;
    map["changes"] = changes;
    return map;
  }
}


class _LedgerFactoryGetLedgerParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  Identity identity = null;

  _LedgerFactoryGetLedgerParams() : super(kVersions.last.size);

  _LedgerFactoryGetLedgerParams.init(
    Identity this.identity
  ) : super(kVersions.last.size);

  static _LedgerFactoryGetLedgerParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _LedgerFactoryGetLedgerParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _LedgerFactoryGetLedgerParams result = new _LedgerFactoryGetLedgerParams();
    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(8, false);
      result.identity = Identity.decode(decoder1);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_LedgerFactoryGetLedgerParams";
    String fieldName;
    try {
      fieldName = "identity";
      encoder0.encodeStruct(identity, 8, false);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_LedgerFactoryGetLedgerParams("
           "identity: $identity" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["identity"] = identity;
    return map;
  }
}


class LedgerFactoryGetLedgerResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(24, 0)
  ];
  Status status = null;
  LedgerInterface ledger = null;

  LedgerFactoryGetLedgerResponseParams() : super(kVersions.last.size);

  LedgerFactoryGetLedgerResponseParams.init(
    Status this.status, 
    LedgerInterface this.ledger
  ) : super(kVersions.last.size);

  static LedgerFactoryGetLedgerResponseParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static LedgerFactoryGetLedgerResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    LedgerFactoryGetLedgerResponseParams result = new LedgerFactoryGetLedgerResponseParams();
    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
        result.status = Status.decode(decoder0, 8);
        if (result.status == null) {
          throw new bindings.MojoCodecError(
            'Trying to decode null union for non-nullable Status.');
        }
    }
    if (mainDataHeader.version >= 0) {
      
      result.ledger = decoder0.decodeServiceInterface(12, true, LedgerProxy.newFromEndpoint);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "LedgerFactoryGetLedgerResponseParams";
    String fieldName;
    try {
      fieldName = "status";
      encoder0.encodeEnum(status, 8);
      fieldName = "ledger";
      encoder0.encodeInterface(ledger, 12, true);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "LedgerFactoryGetLedgerResponseParams("
           "status: $status" ", "
           "ledger: $ledger" ")";
  }

  Map toJson() {
    throw new bindings.MojoCodecError(
        'Object containing handles cannot be encoded to JSON.');
  }
}


class _LedgerGetRootPageParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(8, 0)
  ];

  _LedgerGetRootPageParams() : super(kVersions.last.size);

  _LedgerGetRootPageParams.init(
  ) : super(kVersions.last.size);

  static _LedgerGetRootPageParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _LedgerGetRootPageParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _LedgerGetRootPageParams result = new _LedgerGetRootPageParams();
    bindings.Struct.checkVersion(decoder0, kVersions);
    return result;
  }

  void encode(bindings.Encoder encoder) {
    encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_LedgerGetRootPageParams";
    String fieldName;
    try {
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_LedgerGetRootPageParams("")";
  }

  Map toJson() {
    Map map = new Map();
    return map;
  }
}


class LedgerGetRootPageResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(24, 0)
  ];
  Status status = null;
  PageInterface page = null;

  LedgerGetRootPageResponseParams() : super(kVersions.last.size);

  LedgerGetRootPageResponseParams.init(
    Status this.status, 
    PageInterface this.page
  ) : super(kVersions.last.size);

  static LedgerGetRootPageResponseParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static LedgerGetRootPageResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    LedgerGetRootPageResponseParams result = new LedgerGetRootPageResponseParams();
    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
        result.status = Status.decode(decoder0, 8);
        if (result.status == null) {
          throw new bindings.MojoCodecError(
            'Trying to decode null union for non-nullable Status.');
        }
    }
    if (mainDataHeader.version >= 0) {
      
      result.page = decoder0.decodeServiceInterface(12, true, PageProxy.newFromEndpoint);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "LedgerGetRootPageResponseParams";
    String fieldName;
    try {
      fieldName = "status";
      encoder0.encodeEnum(status, 8);
      fieldName = "page";
      encoder0.encodeInterface(page, 12, true);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "LedgerGetRootPageResponseParams("
           "status: $status" ", "
           "page: $page" ")";
  }

  Map toJson() {
    throw new bindings.MojoCodecError(
        'Object containing handles cannot be encoded to JSON.');
  }
}


class _LedgerGetPageParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  List<int> id = null;

  _LedgerGetPageParams() : super(kVersions.last.size);

  _LedgerGetPageParams.init(
    List<int> this.id
  ) : super(kVersions.last.size);

  static _LedgerGetPageParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _LedgerGetPageParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _LedgerGetPageParams result = new _LedgerGetPageParams();
    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.id = decoder0.decodeUint8Array(8, bindings.kNothingNullable, 16);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_LedgerGetPageParams";
    String fieldName;
    try {
      fieldName = "id";
      encoder0.encodeUint8Array(id, 8, bindings.kNothingNullable, 16);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_LedgerGetPageParams("
           "id: $id" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["id"] = id;
    return map;
  }
}


class LedgerGetPageResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(24, 0)
  ];
  Status status = null;
  PageInterface page = null;

  LedgerGetPageResponseParams() : super(kVersions.last.size);

  LedgerGetPageResponseParams.init(
    Status this.status, 
    PageInterface this.page
  ) : super(kVersions.last.size);

  static LedgerGetPageResponseParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static LedgerGetPageResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    LedgerGetPageResponseParams result = new LedgerGetPageResponseParams();
    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
        result.status = Status.decode(decoder0, 8);
        if (result.status == null) {
          throw new bindings.MojoCodecError(
            'Trying to decode null union for non-nullable Status.');
        }
    }
    if (mainDataHeader.version >= 0) {
      
      result.page = decoder0.decodeServiceInterface(12, true, PageProxy.newFromEndpoint);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "LedgerGetPageResponseParams";
    String fieldName;
    try {
      fieldName = "status";
      encoder0.encodeEnum(status, 8);
      fieldName = "page";
      encoder0.encodeInterface(page, 12, true);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "LedgerGetPageResponseParams("
           "status: $status" ", "
           "page: $page" ")";
  }

  Map toJson() {
    throw new bindings.MojoCodecError(
        'Object containing handles cannot be encoded to JSON.');
  }
}


class _LedgerNewPageParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(8, 0)
  ];

  _LedgerNewPageParams() : super(kVersions.last.size);

  _LedgerNewPageParams.init(
  ) : super(kVersions.last.size);

  static _LedgerNewPageParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _LedgerNewPageParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _LedgerNewPageParams result = new _LedgerNewPageParams();
    bindings.Struct.checkVersion(decoder0, kVersions);
    return result;
  }

  void encode(bindings.Encoder encoder) {
    encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_LedgerNewPageParams";
    String fieldName;
    try {
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_LedgerNewPageParams("")";
  }

  Map toJson() {
    Map map = new Map();
    return map;
  }
}


class LedgerNewPageResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(24, 0)
  ];
  Status status = null;
  PageInterface page = null;

  LedgerNewPageResponseParams() : super(kVersions.last.size);

  LedgerNewPageResponseParams.init(
    Status this.status, 
    PageInterface this.page
  ) : super(kVersions.last.size);

  static LedgerNewPageResponseParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static LedgerNewPageResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    LedgerNewPageResponseParams result = new LedgerNewPageResponseParams();
    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
        result.status = Status.decode(decoder0, 8);
        if (result.status == null) {
          throw new bindings.MojoCodecError(
            'Trying to decode null union for non-nullable Status.');
        }
    }
    if (mainDataHeader.version >= 0) {
      
      result.page = decoder0.decodeServiceInterface(12, true, PageProxy.newFromEndpoint);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "LedgerNewPageResponseParams";
    String fieldName;
    try {
      fieldName = "status";
      encoder0.encodeEnum(status, 8);
      fieldName = "page";
      encoder0.encodeInterface(page, 12, true);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "LedgerNewPageResponseParams("
           "status: $status" ", "
           "page: $page" ")";
  }

  Map toJson() {
    throw new bindings.MojoCodecError(
        'Object containing handles cannot be encoded to JSON.');
  }
}


class _LedgerDeletePageParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  List<int> id = null;

  _LedgerDeletePageParams() : super(kVersions.last.size);

  _LedgerDeletePageParams.init(
    List<int> this.id
  ) : super(kVersions.last.size);

  static _LedgerDeletePageParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _LedgerDeletePageParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _LedgerDeletePageParams result = new _LedgerDeletePageParams();
    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.id = decoder0.decodeUint8Array(8, bindings.kNothingNullable, 16);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_LedgerDeletePageParams";
    String fieldName;
    try {
      fieldName = "id";
      encoder0.encodeUint8Array(id, 8, bindings.kNothingNullable, 16);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_LedgerDeletePageParams("
           "id: $id" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["id"] = id;
    return map;
  }
}


class LedgerDeletePageResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  Status status = null;

  LedgerDeletePageResponseParams() : super(kVersions.last.size);

  LedgerDeletePageResponseParams.init(
    Status this.status
  ) : super(kVersions.last.size);

  static LedgerDeletePageResponseParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static LedgerDeletePageResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    LedgerDeletePageResponseParams result = new LedgerDeletePageResponseParams();
    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
        result.status = Status.decode(decoder0, 8);
        if (result.status == null) {
          throw new bindings.MojoCodecError(
            'Trying to decode null union for non-nullable Status.');
        }
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "LedgerDeletePageResponseParams";
    String fieldName;
    try {
      fieldName = "status";
      encoder0.encodeEnum(status, 8);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "LedgerDeletePageResponseParams("
           "status: $status" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["status"] = status;
    return map;
  }
}


class _LedgerSetConflictResolverFactoryParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  ConflictResolverFactoryInterface factory = null;

  _LedgerSetConflictResolverFactoryParams() : super(kVersions.last.size);

  _LedgerSetConflictResolverFactoryParams.init(
    ConflictResolverFactoryInterface this.factory
  ) : super(kVersions.last.size);

  static _LedgerSetConflictResolverFactoryParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _LedgerSetConflictResolverFactoryParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _LedgerSetConflictResolverFactoryParams result = new _LedgerSetConflictResolverFactoryParams();
    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.factory = decoder0.decodeServiceInterface(8, true, ConflictResolverFactoryProxy.newFromEndpoint);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_LedgerSetConflictResolverFactoryParams";
    String fieldName;
    try {
      fieldName = "factory";
      encoder0.encodeInterface(factory, 8, true);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_LedgerSetConflictResolverFactoryParams("
           "factory: $factory" ")";
  }

  Map toJson() {
    throw new bindings.MojoCodecError(
        'Object containing handles cannot be encoded to JSON.');
  }
}


class LedgerSetConflictResolverFactoryResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  Status status = null;

  LedgerSetConflictResolverFactoryResponseParams() : super(kVersions.last.size);

  LedgerSetConflictResolverFactoryResponseParams.init(
    Status this.status
  ) : super(kVersions.last.size);

  static LedgerSetConflictResolverFactoryResponseParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static LedgerSetConflictResolverFactoryResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    LedgerSetConflictResolverFactoryResponseParams result = new LedgerSetConflictResolverFactoryResponseParams();
    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
        result.status = Status.decode(decoder0, 8);
        if (result.status == null) {
          throw new bindings.MojoCodecError(
            'Trying to decode null union for non-nullable Status.');
        }
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "LedgerSetConflictResolverFactoryResponseParams";
    String fieldName;
    try {
      fieldName = "status";
      encoder0.encodeEnum(status, 8);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "LedgerSetConflictResolverFactoryResponseParams("
           "status: $status" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["status"] = status;
    return map;
  }
}


class _PageGetIdParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(8, 0)
  ];

  _PageGetIdParams() : super(kVersions.last.size);

  _PageGetIdParams.init(
  ) : super(kVersions.last.size);

  static _PageGetIdParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _PageGetIdParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _PageGetIdParams result = new _PageGetIdParams();
    bindings.Struct.checkVersion(decoder0, kVersions);
    return result;
  }

  void encode(bindings.Encoder encoder) {
    encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_PageGetIdParams";
    String fieldName;
    try {
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_PageGetIdParams("")";
  }

  Map toJson() {
    Map map = new Map();
    return map;
  }
}


class PageGetIdResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  List<int> id = null;

  PageGetIdResponseParams() : super(kVersions.last.size);

  PageGetIdResponseParams.init(
    List<int> this.id
  ) : super(kVersions.last.size);

  static PageGetIdResponseParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static PageGetIdResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    PageGetIdResponseParams result = new PageGetIdResponseParams();
    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.id = decoder0.decodeUint8Array(8, bindings.kNothingNullable, 16);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "PageGetIdResponseParams";
    String fieldName;
    try {
      fieldName = "id";
      encoder0.encodeUint8Array(id, 8, bindings.kNothingNullable, 16);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "PageGetIdResponseParams("
           "id: $id" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["id"] = id;
    return map;
  }
}


class _PageGetSnapshotParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(8, 0)
  ];

  _PageGetSnapshotParams() : super(kVersions.last.size);

  _PageGetSnapshotParams.init(
  ) : super(kVersions.last.size);

  static _PageGetSnapshotParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _PageGetSnapshotParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _PageGetSnapshotParams result = new _PageGetSnapshotParams();
    bindings.Struct.checkVersion(decoder0, kVersions);
    return result;
  }

  void encode(bindings.Encoder encoder) {
    encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_PageGetSnapshotParams";
    String fieldName;
    try {
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_PageGetSnapshotParams("")";
  }

  Map toJson() {
    Map map = new Map();
    return map;
  }
}


class PageGetSnapshotResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(24, 0)
  ];
  Status status = null;
  PageSnapshotInterface snapshot = null;

  PageGetSnapshotResponseParams() : super(kVersions.last.size);

  PageGetSnapshotResponseParams.init(
    Status this.status, 
    PageSnapshotInterface this.snapshot
  ) : super(kVersions.last.size);

  static PageGetSnapshotResponseParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static PageGetSnapshotResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    PageGetSnapshotResponseParams result = new PageGetSnapshotResponseParams();
    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
        result.status = Status.decode(decoder0, 8);
        if (result.status == null) {
          throw new bindings.MojoCodecError(
            'Trying to decode null union for non-nullable Status.');
        }
    }
    if (mainDataHeader.version >= 0) {
      
      result.snapshot = decoder0.decodeServiceInterface(12, true, PageSnapshotProxy.newFromEndpoint);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "PageGetSnapshotResponseParams";
    String fieldName;
    try {
      fieldName = "status";
      encoder0.encodeEnum(status, 8);
      fieldName = "snapshot";
      encoder0.encodeInterface(snapshot, 12, true);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "PageGetSnapshotResponseParams("
           "status: $status" ", "
           "snapshot: $snapshot" ")";
  }

  Map toJson() {
    throw new bindings.MojoCodecError(
        'Object containing handles cannot be encoded to JSON.');
  }
}


class _PageWatchParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  PageWatcherInterface watcher = null;

  _PageWatchParams() : super(kVersions.last.size);

  _PageWatchParams.init(
    PageWatcherInterface this.watcher
  ) : super(kVersions.last.size);

  static _PageWatchParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _PageWatchParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _PageWatchParams result = new _PageWatchParams();
    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.watcher = decoder0.decodeServiceInterface(8, false, PageWatcherProxy.newFromEndpoint);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_PageWatchParams";
    String fieldName;
    try {
      fieldName = "watcher";
      encoder0.encodeInterface(watcher, 8, false);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_PageWatchParams("
           "watcher: $watcher" ")";
  }

  Map toJson() {
    throw new bindings.MojoCodecError(
        'Object containing handles cannot be encoded to JSON.');
  }
}


class PageWatchResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  Status status = null;

  PageWatchResponseParams() : super(kVersions.last.size);

  PageWatchResponseParams.init(
    Status this.status
  ) : super(kVersions.last.size);

  static PageWatchResponseParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static PageWatchResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    PageWatchResponseParams result = new PageWatchResponseParams();
    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
        result.status = Status.decode(decoder0, 8);
        if (result.status == null) {
          throw new bindings.MojoCodecError(
            'Trying to decode null union for non-nullable Status.');
        }
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "PageWatchResponseParams";
    String fieldName;
    try {
      fieldName = "status";
      encoder0.encodeEnum(status, 8);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "PageWatchResponseParams("
           "status: $status" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["status"] = status;
    return map;
  }
}


class _PagePutParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(24, 0)
  ];
  List<int> key = null;
  List<int> value = null;

  _PagePutParams() : super(kVersions.last.size);

  _PagePutParams.init(
    List<int> this.key, 
    List<int> this.value
  ) : super(kVersions.last.size);

  static _PagePutParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _PagePutParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _PagePutParams result = new _PagePutParams();
    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.key = decoder0.decodeUint8Array(8, bindings.kNothingNullable, bindings.kUnspecifiedArrayLength);
    }
    if (mainDataHeader.version >= 0) {
      
      result.value = decoder0.decodeUint8Array(16, bindings.kNothingNullable, bindings.kUnspecifiedArrayLength);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_PagePutParams";
    String fieldName;
    try {
      fieldName = "key";
      encoder0.encodeUint8Array(key, 8, bindings.kNothingNullable, bindings.kUnspecifiedArrayLength);
      fieldName = "value";
      encoder0.encodeUint8Array(value, 16, bindings.kNothingNullable, bindings.kUnspecifiedArrayLength);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_PagePutParams("
           "key: $key" ", "
           "value: $value" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["key"] = key;
    map["value"] = value;
    return map;
  }
}


class PagePutResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  Status status = null;

  PagePutResponseParams() : super(kVersions.last.size);

  PagePutResponseParams.init(
    Status this.status
  ) : super(kVersions.last.size);

  static PagePutResponseParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static PagePutResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    PagePutResponseParams result = new PagePutResponseParams();
    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
        result.status = Status.decode(decoder0, 8);
        if (result.status == null) {
          throw new bindings.MojoCodecError(
            'Trying to decode null union for non-nullable Status.');
        }
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "PagePutResponseParams";
    String fieldName;
    try {
      fieldName = "status";
      encoder0.encodeEnum(status, 8);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "PagePutResponseParams("
           "status: $status" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["status"] = status;
    return map;
  }
}


class _PagePutReferenceParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(24, 0)
  ];
  List<int> key = null;
  Reference reference = null;

  _PagePutReferenceParams() : super(kVersions.last.size);

  _PagePutReferenceParams.init(
    List<int> this.key, 
    Reference this.reference
  ) : super(kVersions.last.size);

  static _PagePutReferenceParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _PagePutReferenceParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _PagePutReferenceParams result = new _PagePutReferenceParams();
    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.key = decoder0.decodeUint8Array(8, bindings.kNothingNullable, bindings.kUnspecifiedArrayLength);
    }
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(16, false);
      result.reference = Reference.decode(decoder1);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_PagePutReferenceParams";
    String fieldName;
    try {
      fieldName = "key";
      encoder0.encodeUint8Array(key, 8, bindings.kNothingNullable, bindings.kUnspecifiedArrayLength);
      fieldName = "reference";
      encoder0.encodeStruct(reference, 16, false);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_PagePutReferenceParams("
           "key: $key" ", "
           "reference: $reference" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["key"] = key;
    map["reference"] = reference;
    return map;
  }
}


class PagePutReferenceResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  Status status = null;

  PagePutReferenceResponseParams() : super(kVersions.last.size);

  PagePutReferenceResponseParams.init(
    Status this.status
  ) : super(kVersions.last.size);

  static PagePutReferenceResponseParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static PagePutReferenceResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    PagePutReferenceResponseParams result = new PagePutReferenceResponseParams();
    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
        result.status = Status.decode(decoder0, 8);
        if (result.status == null) {
          throw new bindings.MojoCodecError(
            'Trying to decode null union for non-nullable Status.');
        }
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "PagePutReferenceResponseParams";
    String fieldName;
    try {
      fieldName = "status";
      encoder0.encodeEnum(status, 8);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "PagePutReferenceResponseParams("
           "status: $status" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["status"] = status;
    return map;
  }
}


class _PageDeleteParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  List<int> key = null;

  _PageDeleteParams() : super(kVersions.last.size);

  _PageDeleteParams.init(
    List<int> this.key
  ) : super(kVersions.last.size);

  static _PageDeleteParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _PageDeleteParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _PageDeleteParams result = new _PageDeleteParams();
    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.key = decoder0.decodeUint8Array(8, bindings.kNothingNullable, bindings.kUnspecifiedArrayLength);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_PageDeleteParams";
    String fieldName;
    try {
      fieldName = "key";
      encoder0.encodeUint8Array(key, 8, bindings.kNothingNullable, bindings.kUnspecifiedArrayLength);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_PageDeleteParams("
           "key: $key" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["key"] = key;
    return map;
  }
}


class PageDeleteResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  Status status = null;

  PageDeleteResponseParams() : super(kVersions.last.size);

  PageDeleteResponseParams.init(
    Status this.status
  ) : super(kVersions.last.size);

  static PageDeleteResponseParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static PageDeleteResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    PageDeleteResponseParams result = new PageDeleteResponseParams();
    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
        result.status = Status.decode(decoder0, 8);
        if (result.status == null) {
          throw new bindings.MojoCodecError(
            'Trying to decode null union for non-nullable Status.');
        }
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "PageDeleteResponseParams";
    String fieldName;
    try {
      fieldName = "status";
      encoder0.encodeEnum(status, 8);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "PageDeleteResponseParams("
           "status: $status" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["status"] = status;
    return map;
  }
}


class _PageCreateReferenceParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(24, 0)
  ];
  int size = 0;
  core.MojoDataPipeConsumer data = null;

  _PageCreateReferenceParams() : super(kVersions.last.size);

  _PageCreateReferenceParams.init(
    int this.size, 
    core.MojoDataPipeConsumer this.data
  ) : super(kVersions.last.size);

  static _PageCreateReferenceParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _PageCreateReferenceParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _PageCreateReferenceParams result = new _PageCreateReferenceParams();
    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.size = decoder0.decodeInt64(8);
    }
    if (mainDataHeader.version >= 0) {
      
      result.data = decoder0.decodeConsumerHandle(16, false);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_PageCreateReferenceParams";
    String fieldName;
    try {
      fieldName = "size";
      encoder0.encodeInt64(size, 8);
      fieldName = "data";
      encoder0.encodeConsumerHandle(data, 16, false);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_PageCreateReferenceParams("
           "size: $size" ", "
           "data: $data" ")";
  }

  Map toJson() {
    throw new bindings.MojoCodecError(
        'Object containing handles cannot be encoded to JSON.');
  }
}


class PageCreateReferenceResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(24, 0)
  ];
  Status status = null;
  Reference reference = null;

  PageCreateReferenceResponseParams() : super(kVersions.last.size);

  PageCreateReferenceResponseParams.init(
    Status this.status, 
    Reference this.reference
  ) : super(kVersions.last.size);

  static PageCreateReferenceResponseParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static PageCreateReferenceResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    PageCreateReferenceResponseParams result = new PageCreateReferenceResponseParams();
    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
        result.status = Status.decode(decoder0, 8);
        if (result.status == null) {
          throw new bindings.MojoCodecError(
            'Trying to decode null union for non-nullable Status.');
        }
    }
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(16, true);
      result.reference = Reference.decode(decoder1);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "PageCreateReferenceResponseParams";
    String fieldName;
    try {
      fieldName = "status";
      encoder0.encodeEnum(status, 8);
      fieldName = "reference";
      encoder0.encodeStruct(reference, 16, true);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "PageCreateReferenceResponseParams("
           "status: $status" ", "
           "reference: $reference" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["status"] = status;
    map["reference"] = reference;
    return map;
  }
}


class _PageGetReferenceParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  Reference reference = null;

  _PageGetReferenceParams() : super(kVersions.last.size);

  _PageGetReferenceParams.init(
    Reference this.reference
  ) : super(kVersions.last.size);

  static _PageGetReferenceParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _PageGetReferenceParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _PageGetReferenceParams result = new _PageGetReferenceParams();
    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(8, false);
      result.reference = Reference.decode(decoder1);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_PageGetReferenceParams";
    String fieldName;
    try {
      fieldName = "reference";
      encoder0.encodeStruct(reference, 8, false);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_PageGetReferenceParams("
           "reference: $reference" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["reference"] = reference;
    return map;
  }
}


class PageGetReferenceResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(32, 0)
  ];
  Status status = null;
  Value value = null;

  PageGetReferenceResponseParams() : super(kVersions.last.size);

  PageGetReferenceResponseParams.init(
    Status this.status, 
    Value this.value
  ) : super(kVersions.last.size);

  static PageGetReferenceResponseParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static PageGetReferenceResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    PageGetReferenceResponseParams result = new PageGetReferenceResponseParams();
    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
        result.status = Status.decode(decoder0, 8);
        if (result.status == null) {
          throw new bindings.MojoCodecError(
            'Trying to decode null union for non-nullable Status.');
        }
    }
    if (mainDataHeader.version >= 0) {
      
        result.value = Value.decode(decoder0, 16);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "PageGetReferenceResponseParams";
    String fieldName;
    try {
      fieldName = "status";
      encoder0.encodeEnum(status, 8);
      fieldName = "value";
      encoder0.encodeUnion(value, 16, true);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "PageGetReferenceResponseParams("
           "status: $status" ", "
           "value: $value" ")";
  }

  Map toJson() {
    throw new bindings.MojoCodecError(
        'Object containing handles cannot be encoded to JSON.');
  }
}


class _PageGetPartialReferenceParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(32, 0)
  ];
  Reference reference = null;
  int offset = 0;
  int maxSize = 0;

  _PageGetPartialReferenceParams() : super(kVersions.last.size);

  _PageGetPartialReferenceParams.init(
    Reference this.reference, 
    int this.offset, 
    int this.maxSize
  ) : super(kVersions.last.size);

  static _PageGetPartialReferenceParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _PageGetPartialReferenceParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _PageGetPartialReferenceParams result = new _PageGetPartialReferenceParams();
    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(8, false);
      result.reference = Reference.decode(decoder1);
    }
    if (mainDataHeader.version >= 0) {
      
      result.offset = decoder0.decodeInt64(16);
    }
    if (mainDataHeader.version >= 0) {
      
      result.maxSize = decoder0.decodeInt64(24);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_PageGetPartialReferenceParams";
    String fieldName;
    try {
      fieldName = "reference";
      encoder0.encodeStruct(reference, 8, false);
      fieldName = "offset";
      encoder0.encodeInt64(offset, 16);
      fieldName = "maxSize";
      encoder0.encodeInt64(maxSize, 24);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_PageGetPartialReferenceParams("
           "reference: $reference" ", "
           "offset: $offset" ", "
           "maxSize: $maxSize" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["reference"] = reference;
    map["offset"] = offset;
    map["maxSize"] = maxSize;
    return map;
  }
}


class PageGetPartialReferenceResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(24, 0)
  ];
  Status status = null;
  Stream stream = null;

  PageGetPartialReferenceResponseParams() : super(kVersions.last.size);

  PageGetPartialReferenceResponseParams.init(
    Status this.status, 
    Stream this.stream
  ) : super(kVersions.last.size);

  static PageGetPartialReferenceResponseParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static PageGetPartialReferenceResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    PageGetPartialReferenceResponseParams result = new PageGetPartialReferenceResponseParams();
    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
        result.status = Status.decode(decoder0, 8);
        if (result.status == null) {
          throw new bindings.MojoCodecError(
            'Trying to decode null union for non-nullable Status.');
        }
    }
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(16, true);
      result.stream = Stream.decode(decoder1);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "PageGetPartialReferenceResponseParams";
    String fieldName;
    try {
      fieldName = "status";
      encoder0.encodeEnum(status, 8);
      fieldName = "stream";
      encoder0.encodeStruct(stream, 16, true);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "PageGetPartialReferenceResponseParams("
           "status: $status" ", "
           "stream: $stream" ")";
  }

  Map toJson() {
    throw new bindings.MojoCodecError(
        'Object containing handles cannot be encoded to JSON.');
  }
}


class _PageStartTransactionParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(8, 0)
  ];

  _PageStartTransactionParams() : super(kVersions.last.size);

  _PageStartTransactionParams.init(
  ) : super(kVersions.last.size);

  static _PageStartTransactionParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _PageStartTransactionParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _PageStartTransactionParams result = new _PageStartTransactionParams();
    bindings.Struct.checkVersion(decoder0, kVersions);
    return result;
  }

  void encode(bindings.Encoder encoder) {
    encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_PageStartTransactionParams";
    String fieldName;
    try {
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_PageStartTransactionParams("")";
  }

  Map toJson() {
    Map map = new Map();
    return map;
  }
}


class PageStartTransactionResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  Status status = null;

  PageStartTransactionResponseParams() : super(kVersions.last.size);

  PageStartTransactionResponseParams.init(
    Status this.status
  ) : super(kVersions.last.size);

  static PageStartTransactionResponseParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static PageStartTransactionResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    PageStartTransactionResponseParams result = new PageStartTransactionResponseParams();
    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
        result.status = Status.decode(decoder0, 8);
        if (result.status == null) {
          throw new bindings.MojoCodecError(
            'Trying to decode null union for non-nullable Status.');
        }
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "PageStartTransactionResponseParams";
    String fieldName;
    try {
      fieldName = "status";
      encoder0.encodeEnum(status, 8);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "PageStartTransactionResponseParams("
           "status: $status" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["status"] = status;
    return map;
  }
}


class _PageCommitParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(8, 0)
  ];

  _PageCommitParams() : super(kVersions.last.size);

  _PageCommitParams.init(
  ) : super(kVersions.last.size);

  static _PageCommitParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _PageCommitParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _PageCommitParams result = new _PageCommitParams();
    bindings.Struct.checkVersion(decoder0, kVersions);
    return result;
  }

  void encode(bindings.Encoder encoder) {
    encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_PageCommitParams";
    String fieldName;
    try {
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_PageCommitParams("")";
  }

  Map toJson() {
    Map map = new Map();
    return map;
  }
}


class PageCommitResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  Status status = null;

  PageCommitResponseParams() : super(kVersions.last.size);

  PageCommitResponseParams.init(
    Status this.status
  ) : super(kVersions.last.size);

  static PageCommitResponseParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static PageCommitResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    PageCommitResponseParams result = new PageCommitResponseParams();
    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
        result.status = Status.decode(decoder0, 8);
        if (result.status == null) {
          throw new bindings.MojoCodecError(
            'Trying to decode null union for non-nullable Status.');
        }
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "PageCommitResponseParams";
    String fieldName;
    try {
      fieldName = "status";
      encoder0.encodeEnum(status, 8);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "PageCommitResponseParams("
           "status: $status" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["status"] = status;
    return map;
  }
}


class _PageRollbackParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(8, 0)
  ];

  _PageRollbackParams() : super(kVersions.last.size);

  _PageRollbackParams.init(
  ) : super(kVersions.last.size);

  static _PageRollbackParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _PageRollbackParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _PageRollbackParams result = new _PageRollbackParams();
    bindings.Struct.checkVersion(decoder0, kVersions);
    return result;
  }

  void encode(bindings.Encoder encoder) {
    encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_PageRollbackParams";
    String fieldName;
    try {
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_PageRollbackParams("")";
  }

  Map toJson() {
    Map map = new Map();
    return map;
  }
}


class PageRollbackResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  Status status = null;

  PageRollbackResponseParams() : super(kVersions.last.size);

  PageRollbackResponseParams.init(
    Status this.status
  ) : super(kVersions.last.size);

  static PageRollbackResponseParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static PageRollbackResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    PageRollbackResponseParams result = new PageRollbackResponseParams();
    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
        result.status = Status.decode(decoder0, 8);
        if (result.status == null) {
          throw new bindings.MojoCodecError(
            'Trying to decode null union for non-nullable Status.');
        }
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "PageRollbackResponseParams";
    String fieldName;
    try {
      fieldName = "status";
      encoder0.encodeEnum(status, 8);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "PageRollbackResponseParams("
           "status: $status" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["status"] = status;
    return map;
  }
}


class _PageSnapshotGetAllParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  List<int> keyPrefix = null;

  _PageSnapshotGetAllParams() : super(kVersions.last.size);

  _PageSnapshotGetAllParams.init(
    List<int> this.keyPrefix
  ) : super(kVersions.last.size);

  static _PageSnapshotGetAllParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _PageSnapshotGetAllParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _PageSnapshotGetAllParams result = new _PageSnapshotGetAllParams();
    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.keyPrefix = decoder0.decodeUint8Array(8, bindings.kArrayNullable, bindings.kUnspecifiedArrayLength);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_PageSnapshotGetAllParams";
    String fieldName;
    try {
      fieldName = "keyPrefix";
      encoder0.encodeUint8Array(keyPrefix, 8, bindings.kArrayNullable, bindings.kUnspecifiedArrayLength);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_PageSnapshotGetAllParams("
           "keyPrefix: $keyPrefix" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["keyPrefix"] = keyPrefix;
    return map;
  }
}


class PageSnapshotGetAllResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(24, 0)
  ];
  Status status = null;
  List<Entry> entries = null;

  PageSnapshotGetAllResponseParams() : super(kVersions.last.size);

  PageSnapshotGetAllResponseParams.init(
    Status this.status, 
    List<Entry> this.entries
  ) : super(kVersions.last.size);

  static PageSnapshotGetAllResponseParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static PageSnapshotGetAllResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    PageSnapshotGetAllResponseParams result = new PageSnapshotGetAllResponseParams();
    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
        result.status = Status.decode(decoder0, 8);
        if (result.status == null) {
          throw new bindings.MojoCodecError(
            'Trying to decode null union for non-nullable Status.');
        }
    }
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(16, true);
      if (decoder1 == null) {
        result.entries = null;
      } else {
        var si1 = decoder1.decodeDataHeaderForPointerArray(bindings.kUnspecifiedArrayLength);
        result.entries = new List<Entry>(si1.numElements);
        for (int i1 = 0; i1 < si1.numElements; ++i1) {
          
          var decoder2 = decoder1.decodePointer(bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize * i1, false);
          result.entries[i1] = Entry.decode(decoder2);
        }
      }
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "PageSnapshotGetAllResponseParams";
    String fieldName;
    try {
      fieldName = "status";
      encoder0.encodeEnum(status, 8);
      fieldName = "entries";
      if (entries == null) {
        encoder0.encodeNullPointer(16, true);
      } else {
        var encoder1 = encoder0.encodePointerArray(entries.length, 16, bindings.kUnspecifiedArrayLength);
        for (int i0 = 0; i0 < entries.length; ++i0) {
          encoder1.encodeStruct(entries[i0], bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize * i0, false);
        }
      }
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "PageSnapshotGetAllResponseParams("
           "status: $status" ", "
           "entries: $entries" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["status"] = status;
    map["entries"] = entries;
    return map;
  }
}


class _PageSnapshotGetKeysParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  List<int> keyPrefix = null;

  _PageSnapshotGetKeysParams() : super(kVersions.last.size);

  _PageSnapshotGetKeysParams.init(
    List<int> this.keyPrefix
  ) : super(kVersions.last.size);

  static _PageSnapshotGetKeysParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _PageSnapshotGetKeysParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _PageSnapshotGetKeysParams result = new _PageSnapshotGetKeysParams();
    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.keyPrefix = decoder0.decodeUint8Array(8, bindings.kArrayNullable, bindings.kUnspecifiedArrayLength);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_PageSnapshotGetKeysParams";
    String fieldName;
    try {
      fieldName = "keyPrefix";
      encoder0.encodeUint8Array(keyPrefix, 8, bindings.kArrayNullable, bindings.kUnspecifiedArrayLength);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_PageSnapshotGetKeysParams("
           "keyPrefix: $keyPrefix" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["keyPrefix"] = keyPrefix;
    return map;
  }
}


class PageSnapshotGetKeysResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(24, 0)
  ];
  Status status = null;
  List<List<int>> keys = null;

  PageSnapshotGetKeysResponseParams() : super(kVersions.last.size);

  PageSnapshotGetKeysResponseParams.init(
    Status this.status, 
    List<List<int>> this.keys
  ) : super(kVersions.last.size);

  static PageSnapshotGetKeysResponseParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static PageSnapshotGetKeysResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    PageSnapshotGetKeysResponseParams result = new PageSnapshotGetKeysResponseParams();
    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
        result.status = Status.decode(decoder0, 8);
        if (result.status == null) {
          throw new bindings.MojoCodecError(
            'Trying to decode null union for non-nullable Status.');
        }
    }
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(16, true);
      if (decoder1 == null) {
        result.keys = null;
      } else {
        var si1 = decoder1.decodeDataHeaderForPointerArray(bindings.kUnspecifiedArrayLength);
        result.keys = new List<List<int>>(si1.numElements);
        for (int i1 = 0; i1 < si1.numElements; ++i1) {
          
          result.keys[i1] = decoder1.decodeUint8Array(bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize * i1, bindings.kNothingNullable, bindings.kUnspecifiedArrayLength);
        }
      }
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "PageSnapshotGetKeysResponseParams";
    String fieldName;
    try {
      fieldName = "status";
      encoder0.encodeEnum(status, 8);
      fieldName = "keys";
      if (keys == null) {
        encoder0.encodeNullPointer(16, true);
      } else {
        var encoder1 = encoder0.encodePointerArray(keys.length, 16, bindings.kUnspecifiedArrayLength);
        for (int i0 = 0; i0 < keys.length; ++i0) {
          encoder1.encodeUint8Array(keys[i0], bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize * i0, bindings.kNothingNullable, bindings.kUnspecifiedArrayLength);
        }
      }
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "PageSnapshotGetKeysResponseParams("
           "status: $status" ", "
           "keys: $keys" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["status"] = status;
    map["keys"] = keys;
    return map;
  }
}


class _PageSnapshotGetParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  List<int> key = null;

  _PageSnapshotGetParams() : super(kVersions.last.size);

  _PageSnapshotGetParams.init(
    List<int> this.key
  ) : super(kVersions.last.size);

  static _PageSnapshotGetParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _PageSnapshotGetParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _PageSnapshotGetParams result = new _PageSnapshotGetParams();
    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.key = decoder0.decodeUint8Array(8, bindings.kNothingNullable, bindings.kUnspecifiedArrayLength);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_PageSnapshotGetParams";
    String fieldName;
    try {
      fieldName = "key";
      encoder0.encodeUint8Array(key, 8, bindings.kNothingNullable, bindings.kUnspecifiedArrayLength);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_PageSnapshotGetParams("
           "key: $key" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["key"] = key;
    return map;
  }
}


class PageSnapshotGetResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(32, 0)
  ];
  Status status = null;
  Value value = null;

  PageSnapshotGetResponseParams() : super(kVersions.last.size);

  PageSnapshotGetResponseParams.init(
    Status this.status, 
    Value this.value
  ) : super(kVersions.last.size);

  static PageSnapshotGetResponseParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static PageSnapshotGetResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    PageSnapshotGetResponseParams result = new PageSnapshotGetResponseParams();
    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
        result.status = Status.decode(decoder0, 8);
        if (result.status == null) {
          throw new bindings.MojoCodecError(
            'Trying to decode null union for non-nullable Status.');
        }
    }
    if (mainDataHeader.version >= 0) {
      
        result.value = Value.decode(decoder0, 16);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "PageSnapshotGetResponseParams";
    String fieldName;
    try {
      fieldName = "status";
      encoder0.encodeEnum(status, 8);
      fieldName = "value";
      encoder0.encodeUnion(value, 16, true);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "PageSnapshotGetResponseParams("
           "status: $status" ", "
           "value: $value" ")";
  }

  Map toJson() {
    throw new bindings.MojoCodecError(
        'Object containing handles cannot be encoded to JSON.');
  }
}


class _PageSnapshotGetPartialParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(32, 0)
  ];
  List<int> key = null;
  int offset = 0;
  int maxSize = 0;

  _PageSnapshotGetPartialParams() : super(kVersions.last.size);

  _PageSnapshotGetPartialParams.init(
    List<int> this.key, 
    int this.offset, 
    int this.maxSize
  ) : super(kVersions.last.size);

  static _PageSnapshotGetPartialParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _PageSnapshotGetPartialParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _PageSnapshotGetPartialParams result = new _PageSnapshotGetPartialParams();
    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.key = decoder0.decodeUint8Array(8, bindings.kNothingNullable, bindings.kUnspecifiedArrayLength);
    }
    if (mainDataHeader.version >= 0) {
      
      result.offset = decoder0.decodeInt64(16);
    }
    if (mainDataHeader.version >= 0) {
      
      result.maxSize = decoder0.decodeInt64(24);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_PageSnapshotGetPartialParams";
    String fieldName;
    try {
      fieldName = "key";
      encoder0.encodeUint8Array(key, 8, bindings.kNothingNullable, bindings.kUnspecifiedArrayLength);
      fieldName = "offset";
      encoder0.encodeInt64(offset, 16);
      fieldName = "maxSize";
      encoder0.encodeInt64(maxSize, 24);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_PageSnapshotGetPartialParams("
           "key: $key" ", "
           "offset: $offset" ", "
           "maxSize: $maxSize" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["key"] = key;
    map["offset"] = offset;
    map["maxSize"] = maxSize;
    return map;
  }
}


class PageSnapshotGetPartialResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(24, 0)
  ];
  Status status = null;
  Stream stream = null;

  PageSnapshotGetPartialResponseParams() : super(kVersions.last.size);

  PageSnapshotGetPartialResponseParams.init(
    Status this.status, 
    Stream this.stream
  ) : super(kVersions.last.size);

  static PageSnapshotGetPartialResponseParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static PageSnapshotGetPartialResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    PageSnapshotGetPartialResponseParams result = new PageSnapshotGetPartialResponseParams();
    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
        result.status = Status.decode(decoder0, 8);
        if (result.status == null) {
          throw new bindings.MojoCodecError(
            'Trying to decode null union for non-nullable Status.');
        }
    }
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(16, true);
      result.stream = Stream.decode(decoder1);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "PageSnapshotGetPartialResponseParams";
    String fieldName;
    try {
      fieldName = "status";
      encoder0.encodeEnum(status, 8);
      fieldName = "stream";
      encoder0.encodeStruct(stream, 16, true);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "PageSnapshotGetPartialResponseParams("
           "status: $status" ", "
           "stream: $stream" ")";
  }

  Map toJson() {
    throw new bindings.MojoCodecError(
        'Object containing handles cannot be encoded to JSON.');
  }
}


class _PageWatcherOnInitialStateParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  PageSnapshotInterface snapshot = null;

  _PageWatcherOnInitialStateParams() : super(kVersions.last.size);

  _PageWatcherOnInitialStateParams.init(
    PageSnapshotInterface this.snapshot
  ) : super(kVersions.last.size);

  static _PageWatcherOnInitialStateParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _PageWatcherOnInitialStateParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _PageWatcherOnInitialStateParams result = new _PageWatcherOnInitialStateParams();
    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.snapshot = decoder0.decodeServiceInterface(8, false, PageSnapshotProxy.newFromEndpoint);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_PageWatcherOnInitialStateParams";
    String fieldName;
    try {
      fieldName = "snapshot";
      encoder0.encodeInterface(snapshot, 8, false);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_PageWatcherOnInitialStateParams("
           "snapshot: $snapshot" ")";
  }

  Map toJson() {
    throw new bindings.MojoCodecError(
        'Object containing handles cannot be encoded to JSON.');
  }
}


class PageWatcherOnInitialStateResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(8, 0)
  ];

  PageWatcherOnInitialStateResponseParams() : super(kVersions.last.size);

  PageWatcherOnInitialStateResponseParams.init(
  ) : super(kVersions.last.size);

  static PageWatcherOnInitialStateResponseParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static PageWatcherOnInitialStateResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    PageWatcherOnInitialStateResponseParams result = new PageWatcherOnInitialStateResponseParams();
    bindings.Struct.checkVersion(decoder0, kVersions);
    return result;
  }

  void encode(bindings.Encoder encoder) {
    encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "PageWatcherOnInitialStateResponseParams";
    String fieldName;
    try {
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "PageWatcherOnInitialStateResponseParams("")";
  }

  Map toJson() {
    Map map = new Map();
    return map;
  }
}


class _PageWatcherOnChangeParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  PageChange pageChange = null;

  _PageWatcherOnChangeParams() : super(kVersions.last.size);

  _PageWatcherOnChangeParams.init(
    PageChange this.pageChange
  ) : super(kVersions.last.size);

  static _PageWatcherOnChangeParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _PageWatcherOnChangeParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _PageWatcherOnChangeParams result = new _PageWatcherOnChangeParams();
    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(8, false);
      result.pageChange = PageChange.decode(decoder1);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_PageWatcherOnChangeParams";
    String fieldName;
    try {
      fieldName = "pageChange";
      encoder0.encodeStruct(pageChange, 8, false);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_PageWatcherOnChangeParams("
           "pageChange: $pageChange" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["pageChange"] = pageChange;
    return map;
  }
}


class PageWatcherOnChangeResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(8, 0)
  ];

  PageWatcherOnChangeResponseParams() : super(kVersions.last.size);

  PageWatcherOnChangeResponseParams.init(
  ) : super(kVersions.last.size);

  static PageWatcherOnChangeResponseParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static PageWatcherOnChangeResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    PageWatcherOnChangeResponseParams result = new PageWatcherOnChangeResponseParams();
    bindings.Struct.checkVersion(decoder0, kVersions);
    return result;
  }

  void encode(bindings.Encoder encoder) {
    encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "PageWatcherOnChangeResponseParams";
    String fieldName;
    try {
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "PageWatcherOnChangeResponseParams("")";
  }

  Map toJson() {
    Map map = new Map();
    return map;
  }
}


class _ConflictResolverFactoryGetPolicyParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  List<int> pageId = null;

  _ConflictResolverFactoryGetPolicyParams() : super(kVersions.last.size);

  _ConflictResolverFactoryGetPolicyParams.init(
    List<int> this.pageId
  ) : super(kVersions.last.size);

  static _ConflictResolverFactoryGetPolicyParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _ConflictResolverFactoryGetPolicyParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _ConflictResolverFactoryGetPolicyParams result = new _ConflictResolverFactoryGetPolicyParams();
    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.pageId = decoder0.decodeUint8Array(8, bindings.kNothingNullable, bindings.kUnspecifiedArrayLength);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_ConflictResolverFactoryGetPolicyParams";
    String fieldName;
    try {
      fieldName = "pageId";
      encoder0.encodeUint8Array(pageId, 8, bindings.kNothingNullable, bindings.kUnspecifiedArrayLength);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_ConflictResolverFactoryGetPolicyParams("
           "pageId: $pageId" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["pageId"] = pageId;
    return map;
  }
}


class ConflictResolverFactoryGetPolicyResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  ConflictResolutionPolicy policy = null;

  ConflictResolverFactoryGetPolicyResponseParams() : super(kVersions.last.size);

  ConflictResolverFactoryGetPolicyResponseParams.init(
    ConflictResolutionPolicy this.policy
  ) : super(kVersions.last.size);

  static ConflictResolverFactoryGetPolicyResponseParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static ConflictResolverFactoryGetPolicyResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    ConflictResolverFactoryGetPolicyResponseParams result = new ConflictResolverFactoryGetPolicyResponseParams();
    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
        result.policy = ConflictResolutionPolicy.decode(decoder0, 8);
        if (result.policy == null) {
          throw new bindings.MojoCodecError(
            'Trying to decode null union for non-nullable ConflictResolutionPolicy.');
        }
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "ConflictResolverFactoryGetPolicyResponseParams";
    String fieldName;
    try {
      fieldName = "policy";
      encoder0.encodeEnum(policy, 8);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "ConflictResolverFactoryGetPolicyResponseParams("
           "policy: $policy" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["policy"] = policy;
    return map;
  }
}


class _ConflictResolverFactoryNewConflictResolverParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(24, 0)
  ];
  List<int> pageId = null;
  ConflictResolverInterfaceRequest resolver = null;

  _ConflictResolverFactoryNewConflictResolverParams() : super(kVersions.last.size);

  _ConflictResolverFactoryNewConflictResolverParams.init(
    List<int> this.pageId, 
    ConflictResolverInterfaceRequest this.resolver
  ) : super(kVersions.last.size);

  static _ConflictResolverFactoryNewConflictResolverParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _ConflictResolverFactoryNewConflictResolverParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _ConflictResolverFactoryNewConflictResolverParams result = new _ConflictResolverFactoryNewConflictResolverParams();
    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.pageId = decoder0.decodeUint8Array(8, bindings.kNothingNullable, bindings.kUnspecifiedArrayLength);
    }
    if (mainDataHeader.version >= 0) {
      
      result.resolver = decoder0.decodeInterfaceRequest(16, false, ConflictResolverStub.newFromEndpoint);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_ConflictResolverFactoryNewConflictResolverParams";
    String fieldName;
    try {
      fieldName = "pageId";
      encoder0.encodeUint8Array(pageId, 8, bindings.kNothingNullable, bindings.kUnspecifiedArrayLength);
      fieldName = "resolver";
      encoder0.encodeInterfaceRequest(resolver, 16, false);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_ConflictResolverFactoryNewConflictResolverParams("
           "pageId: $pageId" ", "
           "resolver: $resolver" ")";
  }

  Map toJson() {
    throw new bindings.MojoCodecError(
        'Object containing handles cannot be encoded to JSON.');
  }
}


class _ConflictResolverResolveParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(32, 0)
  ];
  PageChange change1 = null;
  PageChange change2 = null;
  PageSnapshotInterface commonVersion = null;

  _ConflictResolverResolveParams() : super(kVersions.last.size);

  _ConflictResolverResolveParams.init(
    PageChange this.change1, 
    PageChange this.change2, 
    PageSnapshotInterface this.commonVersion
  ) : super(kVersions.last.size);

  static _ConflictResolverResolveParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _ConflictResolverResolveParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _ConflictResolverResolveParams result = new _ConflictResolverResolveParams();
    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(8, false);
      result.change1 = PageChange.decode(decoder1);
    }
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(16, false);
      result.change2 = PageChange.decode(decoder1);
    }
    if (mainDataHeader.version >= 0) {
      
      result.commonVersion = decoder0.decodeServiceInterface(24, true, PageSnapshotProxy.newFromEndpoint);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_ConflictResolverResolveParams";
    String fieldName;
    try {
      fieldName = "change1";
      encoder0.encodeStruct(change1, 8, false);
      fieldName = "change2";
      encoder0.encodeStruct(change2, 16, false);
      fieldName = "commonVersion";
      encoder0.encodeInterface(commonVersion, 24, true);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_ConflictResolverResolveParams("
           "change1: $change1" ", "
           "change2: $change2" ", "
           "commonVersion: $commonVersion" ")";
  }

  Map toJson() {
    throw new bindings.MojoCodecError(
        'Object containing handles cannot be encoded to JSON.');
  }
}


class ConflictResolverResolveResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  List<EntryChange> mergeChanges = null;

  ConflictResolverResolveResponseParams() : super(kVersions.last.size);

  ConflictResolverResolveResponseParams.init(
    List<EntryChange> this.mergeChanges
  ) : super(kVersions.last.size);

  static ConflictResolverResolveResponseParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static ConflictResolverResolveResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    ConflictResolverResolveResponseParams result = new ConflictResolverResolveResponseParams();
    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(8, true);
      if (decoder1 == null) {
        result.mergeChanges = null;
      } else {
        var si1 = decoder1.decodeDataHeaderForPointerArray(bindings.kUnspecifiedArrayLength);
        result.mergeChanges = new List<EntryChange>(si1.numElements);
        for (int i1 = 0; i1 < si1.numElements; ++i1) {
          
          var decoder2 = decoder1.decodePointer(bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize * i1, false);
          result.mergeChanges[i1] = EntryChange.decode(decoder2);
        }
      }
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "ConflictResolverResolveResponseParams";
    String fieldName;
    try {
      fieldName = "mergeChanges";
      if (mergeChanges == null) {
        encoder0.encodeNullPointer(8, true);
      } else {
        var encoder1 = encoder0.encodePointerArray(mergeChanges.length, 8, bindings.kUnspecifiedArrayLength);
        for (int i0 = 0; i0 < mergeChanges.length; ++i0) {
          encoder1.encodeStruct(mergeChanges[i0], bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize * i0, false);
        }
      }
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "ConflictResolverResolveResponseParams("
           "mergeChanges: $mergeChanges" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["mergeChanges"] = mergeChanges;
    return map;
  }
}



enum ValueTag {
  bytes,
  stream,
  unknown
}

class Value extends bindings.Union {
  static final _tagToInt = const {
    ValueTag.bytes: 0,
    ValueTag.stream: 1,
  };

  static final _intToTag = const {
    0: ValueTag.bytes,
    1: ValueTag.stream,
  };

  var _data;
  ValueTag _tag = ValueTag.unknown;

  ValueTag get tag => _tag;
  List<int> get bytes {
    if (_tag != ValueTag.bytes) {
      throw new bindings.UnsetUnionTagError(_tag, ValueTag.bytes);
    }
    return _data;
  }

  set bytes(List<int> value) {
    _tag = ValueTag.bytes;
    _data = value;
  }
  Stream get stream {
    if (_tag != ValueTag.stream) {
      throw new bindings.UnsetUnionTagError(_tag, ValueTag.stream);
    }
    return _data;
  }

  set stream(Stream value) {
    _tag = ValueTag.stream;
    _data = value;
  }

  static Value decode(bindings.Decoder decoder0, int offset) {
    int size = decoder0.decodeUint32(offset);
    if (size == 0) {
      return null;
    }
    Value result = new Value();

    
    ValueTag tag = _intToTag[decoder0.decodeUint32(offset + 4)];
    switch (tag) {
      case ValueTag.bytes:
        
        result.bytes = decoder0.decodeUint8Array(offset + 8, bindings.kNothingNullable, bindings.kUnspecifiedArrayLength);
        break;
      case ValueTag.stream:
        
        var decoder1 = decoder0.decodePointer(offset + 8, false);
        result.stream = Stream.decode(decoder1);
        break;
      default:
        throw new bindings.MojoCodecError("Bad union tag: $tag");
    }

    return result;
  }

  void encode(bindings.Encoder encoder0, int offset) {
    
    encoder0.encodeUint32(16, offset);
    encoder0.encodeUint32(_tagToInt[_tag], offset + 4);
    switch (_tag) {
      case ValueTag.bytes:
        encoder0.encodeUint8Array(bytes, offset + 8, bindings.kNothingNullable, bindings.kUnspecifiedArrayLength);
        break;
      case ValueTag.stream:
        encoder0.encodeStruct(stream, offset + 8, false);
        break;
      default:
        throw new bindings.MojoCodecError("Bad union tag: $_tag");
    }
  }

  String toString() {
    String result = "Value(";
    switch (_tag) {
      case ValueTag.bytes:
        result += "bytes";
        break;
      case ValueTag.stream:
        result += "stream";
        break;
      default:
        result += "unknown";
    }
    result += ": $_data)";
    return result;
  }
}


enum BytesOrReferenceTag {
  bytes,
  reference,
  unknown
}

class BytesOrReference extends bindings.Union {
  static final _tagToInt = const {
    BytesOrReferenceTag.bytes: 0,
    BytesOrReferenceTag.reference: 1,
  };

  static final _intToTag = const {
    0: BytesOrReferenceTag.bytes,
    1: BytesOrReferenceTag.reference,
  };

  var _data;
  BytesOrReferenceTag _tag = BytesOrReferenceTag.unknown;

  BytesOrReferenceTag get tag => _tag;
  List<int> get bytes {
    if (_tag != BytesOrReferenceTag.bytes) {
      throw new bindings.UnsetUnionTagError(_tag, BytesOrReferenceTag.bytes);
    }
    return _data;
  }

  set bytes(List<int> value) {
    _tag = BytesOrReferenceTag.bytes;
    _data = value;
  }
  Reference get reference {
    if (_tag != BytesOrReferenceTag.reference) {
      throw new bindings.UnsetUnionTagError(_tag, BytesOrReferenceTag.reference);
    }
    return _data;
  }

  set reference(Reference value) {
    _tag = BytesOrReferenceTag.reference;
    _data = value;
  }

  static BytesOrReference decode(bindings.Decoder decoder0, int offset) {
    int size = decoder0.decodeUint32(offset);
    if (size == 0) {
      return null;
    }
    BytesOrReference result = new BytesOrReference();

    
    BytesOrReferenceTag tag = _intToTag[decoder0.decodeUint32(offset + 4)];
    switch (tag) {
      case BytesOrReferenceTag.bytes:
        
        result.bytes = decoder0.decodeUint8Array(offset + 8, bindings.kNothingNullable, bindings.kUnspecifiedArrayLength);
        break;
      case BytesOrReferenceTag.reference:
        
        var decoder1 = decoder0.decodePointer(offset + 8, false);
        result.reference = Reference.decode(decoder1);
        break;
      default:
        throw new bindings.MojoCodecError("Bad union tag: $tag");
    }

    return result;
  }

  void encode(bindings.Encoder encoder0, int offset) {
    
    encoder0.encodeUint32(16, offset);
    encoder0.encodeUint32(_tagToInt[_tag], offset + 4);
    switch (_tag) {
      case BytesOrReferenceTag.bytes:
        encoder0.encodeUint8Array(bytes, offset + 8, bindings.kNothingNullable, bindings.kUnspecifiedArrayLength);
        break;
      case BytesOrReferenceTag.reference:
        encoder0.encodeStruct(reference, offset + 8, false);
        break;
      default:
        throw new bindings.MojoCodecError("Bad union tag: $_tag");
    }
  }

  String toString() {
    String result = "BytesOrReference(";
    switch (_tag) {
      case BytesOrReferenceTag.bytes:
        result += "bytes";
        break;
      case BytesOrReferenceTag.reference:
        result += "reference";
        break;
      default:
        result += "unknown";
    }
    result += ": $_data)";
    return result;
  }
}
const int _ledgerFactoryMethodGetLedgerName = 0;

class _LedgerFactoryServiceDescription implements service_describer.ServiceDescription {
  void getTopLevelInterface(Function responder) {
    responder(null);
  }

  void getTypeDefinition(String typeKey, Function responder) {
    responder(null);
  }

  void getAllTypeDefinitions(Function responder) {
    responder(null);
  }
}

abstract class LedgerFactory {
  static const String serviceName = "ledger::LedgerFactory";

  static service_describer.ServiceDescription _cachedServiceDescription;
  static service_describer.ServiceDescription get serviceDescription {
    if (_cachedServiceDescription == null) {
      _cachedServiceDescription = new _LedgerFactoryServiceDescription();
    }
    return _cachedServiceDescription;
  }

  static LedgerFactoryProxy connectToService(
      bindings.ServiceConnector s, String url, [String serviceName]) {
    LedgerFactoryProxy p = new LedgerFactoryProxy.unbound();
    String name = serviceName ?? LedgerFactory.serviceName;
    if ((name == null) || name.isEmpty) {
      throw new core.MojoApiError(
          "If an interface has no ServiceName, then one must be provided.");
    }
    s.connectToService(url, p, name);
    return p;
  }
  void getLedger(Identity identity,void callback(Status status, LedgerInterface ledger));
}

abstract class LedgerFactoryInterface
    implements bindings.MojoInterface<LedgerFactory>,
               LedgerFactory {
  factory LedgerFactoryInterface([LedgerFactory impl]) =>
      new LedgerFactoryStub.unbound(impl);

  factory LedgerFactoryInterface.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint,
      [LedgerFactory impl]) =>
      new LedgerFactoryStub.fromEndpoint(endpoint, impl);

  factory LedgerFactoryInterface.fromMock(
      LedgerFactory mock) =>
      new LedgerFactoryProxy.fromMock(mock);
}

abstract class LedgerFactoryInterfaceRequest
    implements bindings.MojoInterface<LedgerFactory>,
               LedgerFactory {
  factory LedgerFactoryInterfaceRequest() =>
      new LedgerFactoryProxy.unbound();
}

class _LedgerFactoryProxyControl
    extends bindings.ProxyMessageHandler
    implements bindings.ProxyControl<LedgerFactory> {
  LedgerFactory impl;

  _LedgerFactoryProxyControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) : super.fromEndpoint(endpoint);

  _LedgerFactoryProxyControl.fromHandle(
      core.MojoHandle handle) : super.fromHandle(handle);

  _LedgerFactoryProxyControl.unbound() : super.unbound();

  String get serviceName => LedgerFactory.serviceName;

  void handleResponse(bindings.ServiceMessage message) {
    switch (message.header.type) {
      case _ledgerFactoryMethodGetLedgerName:
        Function callback = getCallback(message);
        if (callback != null) {
          var r = LedgerFactoryGetLedgerResponseParams.deserialize(
              message.payload);
          callback(r.status , r.ledger );
        }
        break;
      default:
        proxyError("Unexpected message type: ${message.header.type}");
        close(immediate: true);
        break;
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_LedgerFactoryProxyControl($superString)";
  }
}

class LedgerFactoryProxy
    extends bindings.Proxy<LedgerFactory>
    implements LedgerFactory,
               LedgerFactoryInterface,
               LedgerFactoryInterfaceRequest {
  LedgerFactoryProxy.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint)
      : super(new _LedgerFactoryProxyControl.fromEndpoint(endpoint));

  LedgerFactoryProxy.fromHandle(core.MojoHandle handle)
      : super(new _LedgerFactoryProxyControl.fromHandle(handle));

  LedgerFactoryProxy.unbound()
      : super(new _LedgerFactoryProxyControl.unbound());

  factory LedgerFactoryProxy.fromMock(LedgerFactory mock) {
    LedgerFactoryProxy newMockedProxy =
        new LedgerFactoryProxy.unbound();
    newMockedProxy.impl = mock;
    return newMockedProxy;
  }

  static LedgerFactoryProxy newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For LedgerFactoryProxy"));
    return new LedgerFactoryProxy.fromEndpoint(endpoint);
  }


  void getLedger(Identity identity,void callback(Status status, LedgerInterface ledger)) {
    if (impl != null) {
      impl.getLedger(identity,callback ?? bindings.DoNothingFunction.fn);
      return;
    }
    var params = new _LedgerFactoryGetLedgerParams();
    params.identity = identity;
    Function zonedCallback;
    if ((callback == null) || identical(Zone.current, Zone.ROOT)) {
      zonedCallback = callback;
    } else {
      Zone z = Zone.current;
      zonedCallback = ((Status status, LedgerInterface ledger) {
        z.bindCallback(() {
          callback(status, ledger);
        })();
      });
    }
    ctrl.sendMessageWithRequestId(
        params,
        _ledgerFactoryMethodGetLedgerName,
        -1,
        bindings.MessageHeader.kMessageExpectsResponse,
        zonedCallback);
  }
}

class _LedgerFactoryStubControl
    extends bindings.StubMessageHandler
    implements bindings.StubControl<LedgerFactory> {
  LedgerFactory _impl;

  _LedgerFactoryStubControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [LedgerFactory impl])
      : super.fromEndpoint(endpoint, autoBegin: impl != null) {
    _impl = impl;
  }

  _LedgerFactoryStubControl.fromHandle(
      core.MojoHandle handle, [LedgerFactory impl])
      : super.fromHandle(handle, autoBegin: impl != null) {
    _impl = impl;
  }

  _LedgerFactoryStubControl.unbound([this._impl]) : super.unbound();

  String get serviceName => LedgerFactory.serviceName;


  Function _ledgerFactoryGetLedgerResponseParamsResponder(
      int requestId) {
  return (Status status, LedgerInterface ledger) {
      var result = new LedgerFactoryGetLedgerResponseParams();
      result.status = status;
      result.ledger = ledger;
      sendResponse(buildResponseWithId(
          result,
          _ledgerFactoryMethodGetLedgerName,
          requestId,
          bindings.MessageHeader.kMessageIsResponse));
    };
  }

  void handleMessage(bindings.ServiceMessage message) {
    if (bindings.ControlMessageHandler.isControlMessage(message)) {
      bindings.ControlMessageHandler.handleMessage(
          this, 0, message);
      return;
    }
    if (_impl == null) {
      throw new core.MojoApiError("$this has no implementation set");
    }
    switch (message.header.type) {
      case _ledgerFactoryMethodGetLedgerName:
        var params = _LedgerFactoryGetLedgerParams.deserialize(
            message.payload);
        _impl.getLedger(params.identity, _ledgerFactoryGetLedgerResponseParamsResponder(message.header.requestId));
        break;
      default:
        throw new bindings.MojoCodecError("Unexpected message name");
        break;
    }
  }

  LedgerFactory get impl => _impl;
  set impl(LedgerFactory d) {
    if (d == null) {
      throw new core.MojoApiError("$this: Cannot set a null implementation");
    }
    if (isBound && (_impl == null)) {
      beginHandlingEvents();
    }
    _impl = d;
  }

  @override
  void bind(core.MojoMessagePipeEndpoint endpoint) {
    super.bind(endpoint);
    if (!isOpen && (_impl != null)) {
      beginHandlingEvents();
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_LedgerFactoryStubControl($superString)";
  }

  int get version => 0;
}

class LedgerFactoryStub
    extends bindings.Stub<LedgerFactory>
    implements LedgerFactory,
               LedgerFactoryInterface,
               LedgerFactoryInterfaceRequest {
  LedgerFactoryStub.unbound([LedgerFactory impl])
      : super(new _LedgerFactoryStubControl.unbound(impl));

  LedgerFactoryStub.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [LedgerFactory impl])
      : super(new _LedgerFactoryStubControl.fromEndpoint(endpoint, impl));

  LedgerFactoryStub.fromHandle(
      core.MojoHandle handle, [LedgerFactory impl])
      : super(new _LedgerFactoryStubControl.fromHandle(handle, impl));

  static LedgerFactoryStub newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For LedgerFactoryStub"));
    return new LedgerFactoryStub.fromEndpoint(endpoint);
  }


  void getLedger(Identity identity,void callback(Status status, LedgerInterface ledger)) {
    return impl.getLedger(identity,callback);
  }
}

const int _ledgerMethodGetRootPageName = 0;
const int _ledgerMethodGetPageName = 1;
const int _ledgerMethodNewPageName = 2;
const int _ledgerMethodDeletePageName = 3;
const int _ledgerMethodSetConflictResolverFactoryName = 4;

class _LedgerServiceDescription implements service_describer.ServiceDescription {
  void getTopLevelInterface(Function responder) {
    responder(null);
  }

  void getTypeDefinition(String typeKey, Function responder) {
    responder(null);
  }

  void getAllTypeDefinitions(Function responder) {
    responder(null);
  }
}

abstract class Ledger {
  static const String serviceName = null;

  static service_describer.ServiceDescription _cachedServiceDescription;
  static service_describer.ServiceDescription get serviceDescription {
    if (_cachedServiceDescription == null) {
      _cachedServiceDescription = new _LedgerServiceDescription();
    }
    return _cachedServiceDescription;
  }

  static LedgerProxy connectToService(
      bindings.ServiceConnector s, String url, [String serviceName]) {
    LedgerProxy p = new LedgerProxy.unbound();
    String name = serviceName ?? Ledger.serviceName;
    if ((name == null) || name.isEmpty) {
      throw new core.MojoApiError(
          "If an interface has no ServiceName, then one must be provided.");
    }
    s.connectToService(url, p, name);
    return p;
  }
  void getRootPage(void callback(Status status, PageInterface page));
  void getPage(List<int> id,void callback(Status status, PageInterface page));
  void newPage(void callback(Status status, PageInterface page));
  void deletePage(List<int> id,void callback(Status status));
  void setConflictResolverFactory(ConflictResolverFactoryInterface factory,void callback(Status status));
}

abstract class LedgerInterface
    implements bindings.MojoInterface<Ledger>,
               Ledger {
  factory LedgerInterface([Ledger impl]) =>
      new LedgerStub.unbound(impl);

  factory LedgerInterface.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint,
      [Ledger impl]) =>
      new LedgerStub.fromEndpoint(endpoint, impl);

  factory LedgerInterface.fromMock(
      Ledger mock) =>
      new LedgerProxy.fromMock(mock);
}

abstract class LedgerInterfaceRequest
    implements bindings.MojoInterface<Ledger>,
               Ledger {
  factory LedgerInterfaceRequest() =>
      new LedgerProxy.unbound();
}

class _LedgerProxyControl
    extends bindings.ProxyMessageHandler
    implements bindings.ProxyControl<Ledger> {
  Ledger impl;

  _LedgerProxyControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) : super.fromEndpoint(endpoint);

  _LedgerProxyControl.fromHandle(
      core.MojoHandle handle) : super.fromHandle(handle);

  _LedgerProxyControl.unbound() : super.unbound();

  String get serviceName => Ledger.serviceName;

  void handleResponse(bindings.ServiceMessage message) {
    switch (message.header.type) {
      case _ledgerMethodGetRootPageName:
        Function callback = getCallback(message);
        if (callback != null) {
          var r = LedgerGetRootPageResponseParams.deserialize(
              message.payload);
          callback(r.status , r.page );
        }
        break;
      case _ledgerMethodGetPageName:
        Function callback = getCallback(message);
        if (callback != null) {
          var r = LedgerGetPageResponseParams.deserialize(
              message.payload);
          callback(r.status , r.page );
        }
        break;
      case _ledgerMethodNewPageName:
        Function callback = getCallback(message);
        if (callback != null) {
          var r = LedgerNewPageResponseParams.deserialize(
              message.payload);
          callback(r.status , r.page );
        }
        break;
      case _ledgerMethodDeletePageName:
        Function callback = getCallback(message);
        if (callback != null) {
          var r = LedgerDeletePageResponseParams.deserialize(
              message.payload);
          callback(r.status );
        }
        break;
      case _ledgerMethodSetConflictResolverFactoryName:
        Function callback = getCallback(message);
        if (callback != null) {
          var r = LedgerSetConflictResolverFactoryResponseParams.deserialize(
              message.payload);
          callback(r.status );
        }
        break;
      default:
        proxyError("Unexpected message type: ${message.header.type}");
        close(immediate: true);
        break;
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_LedgerProxyControl($superString)";
  }
}

class LedgerProxy
    extends bindings.Proxy<Ledger>
    implements Ledger,
               LedgerInterface,
               LedgerInterfaceRequest {
  LedgerProxy.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint)
      : super(new _LedgerProxyControl.fromEndpoint(endpoint));

  LedgerProxy.fromHandle(core.MojoHandle handle)
      : super(new _LedgerProxyControl.fromHandle(handle));

  LedgerProxy.unbound()
      : super(new _LedgerProxyControl.unbound());

  factory LedgerProxy.fromMock(Ledger mock) {
    LedgerProxy newMockedProxy =
        new LedgerProxy.unbound();
    newMockedProxy.impl = mock;
    return newMockedProxy;
  }

  static LedgerProxy newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For LedgerProxy"));
    return new LedgerProxy.fromEndpoint(endpoint);
  }


  void getRootPage(void callback(Status status, PageInterface page)) {
    if (impl != null) {
      impl.getRootPage(callback ?? bindings.DoNothingFunction.fn);
      return;
    }
    var params = new _LedgerGetRootPageParams();
    Function zonedCallback;
    if ((callback == null) || identical(Zone.current, Zone.ROOT)) {
      zonedCallback = callback;
    } else {
      Zone z = Zone.current;
      zonedCallback = ((Status status, PageInterface page) {
        z.bindCallback(() {
          callback(status, page);
        })();
      });
    }
    ctrl.sendMessageWithRequestId(
        params,
        _ledgerMethodGetRootPageName,
        -1,
        bindings.MessageHeader.kMessageExpectsResponse,
        zonedCallback);
  }
  void getPage(List<int> id,void callback(Status status, PageInterface page)) {
    if (impl != null) {
      impl.getPage(id,callback ?? bindings.DoNothingFunction.fn);
      return;
    }
    var params = new _LedgerGetPageParams();
    params.id = id;
    Function zonedCallback;
    if ((callback == null) || identical(Zone.current, Zone.ROOT)) {
      zonedCallback = callback;
    } else {
      Zone z = Zone.current;
      zonedCallback = ((Status status, PageInterface page) {
        z.bindCallback(() {
          callback(status, page);
        })();
      });
    }
    ctrl.sendMessageWithRequestId(
        params,
        _ledgerMethodGetPageName,
        -1,
        bindings.MessageHeader.kMessageExpectsResponse,
        zonedCallback);
  }
  void newPage(void callback(Status status, PageInterface page)) {
    if (impl != null) {
      impl.newPage(callback ?? bindings.DoNothingFunction.fn);
      return;
    }
    var params = new _LedgerNewPageParams();
    Function zonedCallback;
    if ((callback == null) || identical(Zone.current, Zone.ROOT)) {
      zonedCallback = callback;
    } else {
      Zone z = Zone.current;
      zonedCallback = ((Status status, PageInterface page) {
        z.bindCallback(() {
          callback(status, page);
        })();
      });
    }
    ctrl.sendMessageWithRequestId(
        params,
        _ledgerMethodNewPageName,
        -1,
        bindings.MessageHeader.kMessageExpectsResponse,
        zonedCallback);
  }
  void deletePage(List<int> id,void callback(Status status)) {
    if (impl != null) {
      impl.deletePage(id,callback ?? bindings.DoNothingFunction.fn);
      return;
    }
    var params = new _LedgerDeletePageParams();
    params.id = id;
    Function zonedCallback;
    if ((callback == null) || identical(Zone.current, Zone.ROOT)) {
      zonedCallback = callback;
    } else {
      Zone z = Zone.current;
      zonedCallback = ((Status status) {
        z.bindCallback(() {
          callback(status);
        })();
      });
    }
    ctrl.sendMessageWithRequestId(
        params,
        _ledgerMethodDeletePageName,
        -1,
        bindings.MessageHeader.kMessageExpectsResponse,
        zonedCallback);
  }
  void setConflictResolverFactory(ConflictResolverFactoryInterface factory,void callback(Status status)) {
    if (impl != null) {
      impl.setConflictResolverFactory(factory,callback ?? bindings.DoNothingFunction.fn);
      return;
    }
    var params = new _LedgerSetConflictResolverFactoryParams();
    params.factory = factory;
    Function zonedCallback;
    if ((callback == null) || identical(Zone.current, Zone.ROOT)) {
      zonedCallback = callback;
    } else {
      Zone z = Zone.current;
      zonedCallback = ((Status status) {
        z.bindCallback(() {
          callback(status);
        })();
      });
    }
    ctrl.sendMessageWithRequestId(
        params,
        _ledgerMethodSetConflictResolverFactoryName,
        -1,
        bindings.MessageHeader.kMessageExpectsResponse,
        zonedCallback);
  }
}

class _LedgerStubControl
    extends bindings.StubMessageHandler
    implements bindings.StubControl<Ledger> {
  Ledger _impl;

  _LedgerStubControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [Ledger impl])
      : super.fromEndpoint(endpoint, autoBegin: impl != null) {
    _impl = impl;
  }

  _LedgerStubControl.fromHandle(
      core.MojoHandle handle, [Ledger impl])
      : super.fromHandle(handle, autoBegin: impl != null) {
    _impl = impl;
  }

  _LedgerStubControl.unbound([this._impl]) : super.unbound();

  String get serviceName => Ledger.serviceName;


  Function _ledgerGetRootPageResponseParamsResponder(
      int requestId) {
  return (Status status, PageInterface page) {
      var result = new LedgerGetRootPageResponseParams();
      result.status = status;
      result.page = page;
      sendResponse(buildResponseWithId(
          result,
          _ledgerMethodGetRootPageName,
          requestId,
          bindings.MessageHeader.kMessageIsResponse));
    };
  }
  Function _ledgerGetPageResponseParamsResponder(
      int requestId) {
  return (Status status, PageInterface page) {
      var result = new LedgerGetPageResponseParams();
      result.status = status;
      result.page = page;
      sendResponse(buildResponseWithId(
          result,
          _ledgerMethodGetPageName,
          requestId,
          bindings.MessageHeader.kMessageIsResponse));
    };
  }
  Function _ledgerNewPageResponseParamsResponder(
      int requestId) {
  return (Status status, PageInterface page) {
      var result = new LedgerNewPageResponseParams();
      result.status = status;
      result.page = page;
      sendResponse(buildResponseWithId(
          result,
          _ledgerMethodNewPageName,
          requestId,
          bindings.MessageHeader.kMessageIsResponse));
    };
  }
  Function _ledgerDeletePageResponseParamsResponder(
      int requestId) {
  return (Status status) {
      var result = new LedgerDeletePageResponseParams();
      result.status = status;
      sendResponse(buildResponseWithId(
          result,
          _ledgerMethodDeletePageName,
          requestId,
          bindings.MessageHeader.kMessageIsResponse));
    };
  }
  Function _ledgerSetConflictResolverFactoryResponseParamsResponder(
      int requestId) {
  return (Status status) {
      var result = new LedgerSetConflictResolverFactoryResponseParams();
      result.status = status;
      sendResponse(buildResponseWithId(
          result,
          _ledgerMethodSetConflictResolverFactoryName,
          requestId,
          bindings.MessageHeader.kMessageIsResponse));
    };
  }

  void handleMessage(bindings.ServiceMessage message) {
    if (bindings.ControlMessageHandler.isControlMessage(message)) {
      bindings.ControlMessageHandler.handleMessage(
          this, 0, message);
      return;
    }
    if (_impl == null) {
      throw new core.MojoApiError("$this has no implementation set");
    }
    switch (message.header.type) {
      case _ledgerMethodGetRootPageName:
        _impl.getRootPage(_ledgerGetRootPageResponseParamsResponder(message.header.requestId));
        break;
      case _ledgerMethodGetPageName:
        var params = _LedgerGetPageParams.deserialize(
            message.payload);
        _impl.getPage(params.id, _ledgerGetPageResponseParamsResponder(message.header.requestId));
        break;
      case _ledgerMethodNewPageName:
        _impl.newPage(_ledgerNewPageResponseParamsResponder(message.header.requestId));
        break;
      case _ledgerMethodDeletePageName:
        var params = _LedgerDeletePageParams.deserialize(
            message.payload);
        _impl.deletePage(params.id, _ledgerDeletePageResponseParamsResponder(message.header.requestId));
        break;
      case _ledgerMethodSetConflictResolverFactoryName:
        var params = _LedgerSetConflictResolverFactoryParams.deserialize(
            message.payload);
        _impl.setConflictResolverFactory(params.factory, _ledgerSetConflictResolverFactoryResponseParamsResponder(message.header.requestId));
        break;
      default:
        throw new bindings.MojoCodecError("Unexpected message name");
        break;
    }
  }

  Ledger get impl => _impl;
  set impl(Ledger d) {
    if (d == null) {
      throw new core.MojoApiError("$this: Cannot set a null implementation");
    }
    if (isBound && (_impl == null)) {
      beginHandlingEvents();
    }
    _impl = d;
  }

  @override
  void bind(core.MojoMessagePipeEndpoint endpoint) {
    super.bind(endpoint);
    if (!isOpen && (_impl != null)) {
      beginHandlingEvents();
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_LedgerStubControl($superString)";
  }

  int get version => 0;
}

class LedgerStub
    extends bindings.Stub<Ledger>
    implements Ledger,
               LedgerInterface,
               LedgerInterfaceRequest {
  LedgerStub.unbound([Ledger impl])
      : super(new _LedgerStubControl.unbound(impl));

  LedgerStub.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [Ledger impl])
      : super(new _LedgerStubControl.fromEndpoint(endpoint, impl));

  LedgerStub.fromHandle(
      core.MojoHandle handle, [Ledger impl])
      : super(new _LedgerStubControl.fromHandle(handle, impl));

  static LedgerStub newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For LedgerStub"));
    return new LedgerStub.fromEndpoint(endpoint);
  }


  void getRootPage(void callback(Status status, PageInterface page)) {
    return impl.getRootPage(callback);
  }
  void getPage(List<int> id,void callback(Status status, PageInterface page)) {
    return impl.getPage(id,callback);
  }
  void newPage(void callback(Status status, PageInterface page)) {
    return impl.newPage(callback);
  }
  void deletePage(List<int> id,void callback(Status status)) {
    return impl.deletePage(id,callback);
  }
  void setConflictResolverFactory(ConflictResolverFactoryInterface factory,void callback(Status status)) {
    return impl.setConflictResolverFactory(factory,callback);
  }
}

const int _pageMethodGetIdName = 0;
const int _pageMethodGetSnapshotName = 1;
const int _pageMethodWatchName = 2;
const int _pageMethodPutName = 3;
const int _pageMethodPutReferenceName = 4;
const int _pageMethodDeleteName = 5;
const int _pageMethodCreateReferenceName = 6;
const int _pageMethodGetReferenceName = 7;
const int _pageMethodGetPartialReferenceName = 8;
const int _pageMethodStartTransactionName = 9;
const int _pageMethodCommitName = 10;
const int _pageMethodRollbackName = 11;

class _PageServiceDescription implements service_describer.ServiceDescription {
  void getTopLevelInterface(Function responder) {
    responder(null);
  }

  void getTypeDefinition(String typeKey, Function responder) {
    responder(null);
  }

  void getAllTypeDefinitions(Function responder) {
    responder(null);
  }
}

abstract class Page {
  static const String serviceName = null;

  static service_describer.ServiceDescription _cachedServiceDescription;
  static service_describer.ServiceDescription get serviceDescription {
    if (_cachedServiceDescription == null) {
      _cachedServiceDescription = new _PageServiceDescription();
    }
    return _cachedServiceDescription;
  }

  static PageProxy connectToService(
      bindings.ServiceConnector s, String url, [String serviceName]) {
    PageProxy p = new PageProxy.unbound();
    String name = serviceName ?? Page.serviceName;
    if ((name == null) || name.isEmpty) {
      throw new core.MojoApiError(
          "If an interface has no ServiceName, then one must be provided.");
    }
    s.connectToService(url, p, name);
    return p;
  }
  void getId(void callback(List<int> id));
  void getSnapshot(void callback(Status status, PageSnapshotInterface snapshot));
  void watch(PageWatcherInterface watcher,void callback(Status status));
  void put(List<int> key,List<int> value,void callback(Status status));
  void putReference(List<int> key,Reference reference,void callback(Status status));
  void delete(List<int> key,void callback(Status status));
  void createReference(int size,core.MojoDataPipeConsumer data,void callback(Status status, Reference reference));
  void getReference(Reference reference,void callback(Status status, Value value));
  void getPartialReference(Reference reference,int offset,int maxSize,void callback(Status status, Stream stream));
  void startTransaction(void callback(Status status));
  void commit(void callback(Status status));
  void rollback(void callback(Status status));
}

abstract class PageInterface
    implements bindings.MojoInterface<Page>,
               Page {
  factory PageInterface([Page impl]) =>
      new PageStub.unbound(impl);

  factory PageInterface.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint,
      [Page impl]) =>
      new PageStub.fromEndpoint(endpoint, impl);

  factory PageInterface.fromMock(
      Page mock) =>
      new PageProxy.fromMock(mock);
}

abstract class PageInterfaceRequest
    implements bindings.MojoInterface<Page>,
               Page {
  factory PageInterfaceRequest() =>
      new PageProxy.unbound();
}

class _PageProxyControl
    extends bindings.ProxyMessageHandler
    implements bindings.ProxyControl<Page> {
  Page impl;

  _PageProxyControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) : super.fromEndpoint(endpoint);

  _PageProxyControl.fromHandle(
      core.MojoHandle handle) : super.fromHandle(handle);

  _PageProxyControl.unbound() : super.unbound();

  String get serviceName => Page.serviceName;

  void handleResponse(bindings.ServiceMessage message) {
    switch (message.header.type) {
      case _pageMethodGetIdName:
        Function callback = getCallback(message);
        if (callback != null) {
          var r = PageGetIdResponseParams.deserialize(
              message.payload);
          callback(r.id );
        }
        break;
      case _pageMethodGetSnapshotName:
        Function callback = getCallback(message);
        if (callback != null) {
          var r = PageGetSnapshotResponseParams.deserialize(
              message.payload);
          callback(r.status , r.snapshot );
        }
        break;
      case _pageMethodWatchName:
        Function callback = getCallback(message);
        if (callback != null) {
          var r = PageWatchResponseParams.deserialize(
              message.payload);
          callback(r.status );
        }
        break;
      case _pageMethodPutName:
        Function callback = getCallback(message);
        if (callback != null) {
          var r = PagePutResponseParams.deserialize(
              message.payload);
          callback(r.status );
        }
        break;
      case _pageMethodPutReferenceName:
        Function callback = getCallback(message);
        if (callback != null) {
          var r = PagePutReferenceResponseParams.deserialize(
              message.payload);
          callback(r.status );
        }
        break;
      case _pageMethodDeleteName:
        Function callback = getCallback(message);
        if (callback != null) {
          var r = PageDeleteResponseParams.deserialize(
              message.payload);
          callback(r.status );
        }
        break;
      case _pageMethodCreateReferenceName:
        Function callback = getCallback(message);
        if (callback != null) {
          var r = PageCreateReferenceResponseParams.deserialize(
              message.payload);
          callback(r.status , r.reference );
        }
        break;
      case _pageMethodGetReferenceName:
        Function callback = getCallback(message);
        if (callback != null) {
          var r = PageGetReferenceResponseParams.deserialize(
              message.payload);
          callback(r.status , r.value );
        }
        break;
      case _pageMethodGetPartialReferenceName:
        Function callback = getCallback(message);
        if (callback != null) {
          var r = PageGetPartialReferenceResponseParams.deserialize(
              message.payload);
          callback(r.status , r.stream );
        }
        break;
      case _pageMethodStartTransactionName:
        Function callback = getCallback(message);
        if (callback != null) {
          var r = PageStartTransactionResponseParams.deserialize(
              message.payload);
          callback(r.status );
        }
        break;
      case _pageMethodCommitName:
        Function callback = getCallback(message);
        if (callback != null) {
          var r = PageCommitResponseParams.deserialize(
              message.payload);
          callback(r.status );
        }
        break;
      case _pageMethodRollbackName:
        Function callback = getCallback(message);
        if (callback != null) {
          var r = PageRollbackResponseParams.deserialize(
              message.payload);
          callback(r.status );
        }
        break;
      default:
        proxyError("Unexpected message type: ${message.header.type}");
        close(immediate: true);
        break;
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_PageProxyControl($superString)";
  }
}

class PageProxy
    extends bindings.Proxy<Page>
    implements Page,
               PageInterface,
               PageInterfaceRequest {
  PageProxy.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint)
      : super(new _PageProxyControl.fromEndpoint(endpoint));

  PageProxy.fromHandle(core.MojoHandle handle)
      : super(new _PageProxyControl.fromHandle(handle));

  PageProxy.unbound()
      : super(new _PageProxyControl.unbound());

  factory PageProxy.fromMock(Page mock) {
    PageProxy newMockedProxy =
        new PageProxy.unbound();
    newMockedProxy.impl = mock;
    return newMockedProxy;
  }

  static PageProxy newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For PageProxy"));
    return new PageProxy.fromEndpoint(endpoint);
  }


  void getId(void callback(List<int> id)) {
    if (impl != null) {
      impl.getId(callback ?? bindings.DoNothingFunction.fn);
      return;
    }
    var params = new _PageGetIdParams();
    Function zonedCallback;
    if ((callback == null) || identical(Zone.current, Zone.ROOT)) {
      zonedCallback = callback;
    } else {
      Zone z = Zone.current;
      zonedCallback = ((List<int> id) {
        z.bindCallback(() {
          callback(id);
        })();
      });
    }
    ctrl.sendMessageWithRequestId(
        params,
        _pageMethodGetIdName,
        -1,
        bindings.MessageHeader.kMessageExpectsResponse,
        zonedCallback);
  }
  void getSnapshot(void callback(Status status, PageSnapshotInterface snapshot)) {
    if (impl != null) {
      impl.getSnapshot(callback ?? bindings.DoNothingFunction.fn);
      return;
    }
    var params = new _PageGetSnapshotParams();
    Function zonedCallback;
    if ((callback == null) || identical(Zone.current, Zone.ROOT)) {
      zonedCallback = callback;
    } else {
      Zone z = Zone.current;
      zonedCallback = ((Status status, PageSnapshotInterface snapshot) {
        z.bindCallback(() {
          callback(status, snapshot);
        })();
      });
    }
    ctrl.sendMessageWithRequestId(
        params,
        _pageMethodGetSnapshotName,
        -1,
        bindings.MessageHeader.kMessageExpectsResponse,
        zonedCallback);
  }
  void watch(PageWatcherInterface watcher,void callback(Status status)) {
    if (impl != null) {
      impl.watch(watcher,callback ?? bindings.DoNothingFunction.fn);
      return;
    }
    var params = new _PageWatchParams();
    params.watcher = watcher;
    Function zonedCallback;
    if ((callback == null) || identical(Zone.current, Zone.ROOT)) {
      zonedCallback = callback;
    } else {
      Zone z = Zone.current;
      zonedCallback = ((Status status) {
        z.bindCallback(() {
          callback(status);
        })();
      });
    }
    ctrl.sendMessageWithRequestId(
        params,
        _pageMethodWatchName,
        -1,
        bindings.MessageHeader.kMessageExpectsResponse,
        zonedCallback);
  }
  void put(List<int> key,List<int> value,void callback(Status status)) {
    if (impl != null) {
      impl.put(key,value,callback ?? bindings.DoNothingFunction.fn);
      return;
    }
    var params = new _PagePutParams();
    params.key = key;
    params.value = value;
    Function zonedCallback;
    if ((callback == null) || identical(Zone.current, Zone.ROOT)) {
      zonedCallback = callback;
    } else {
      Zone z = Zone.current;
      zonedCallback = ((Status status) {
        z.bindCallback(() {
          callback(status);
        })();
      });
    }
    ctrl.sendMessageWithRequestId(
        params,
        _pageMethodPutName,
        -1,
        bindings.MessageHeader.kMessageExpectsResponse,
        zonedCallback);
  }
  void putReference(List<int> key,Reference reference,void callback(Status status)) {
    if (impl != null) {
      impl.putReference(key,reference,callback ?? bindings.DoNothingFunction.fn);
      return;
    }
    var params = new _PagePutReferenceParams();
    params.key = key;
    params.reference = reference;
    Function zonedCallback;
    if ((callback == null) || identical(Zone.current, Zone.ROOT)) {
      zonedCallback = callback;
    } else {
      Zone z = Zone.current;
      zonedCallback = ((Status status) {
        z.bindCallback(() {
          callback(status);
        })();
      });
    }
    ctrl.sendMessageWithRequestId(
        params,
        _pageMethodPutReferenceName,
        -1,
        bindings.MessageHeader.kMessageExpectsResponse,
        zonedCallback);
  }
  void delete(List<int> key,void callback(Status status)) {
    if (impl != null) {
      impl.delete(key,callback ?? bindings.DoNothingFunction.fn);
      return;
    }
    var params = new _PageDeleteParams();
    params.key = key;
    Function zonedCallback;
    if ((callback == null) || identical(Zone.current, Zone.ROOT)) {
      zonedCallback = callback;
    } else {
      Zone z = Zone.current;
      zonedCallback = ((Status status) {
        z.bindCallback(() {
          callback(status);
        })();
      });
    }
    ctrl.sendMessageWithRequestId(
        params,
        _pageMethodDeleteName,
        -1,
        bindings.MessageHeader.kMessageExpectsResponse,
        zonedCallback);
  }
  void createReference(int size,core.MojoDataPipeConsumer data,void callback(Status status, Reference reference)) {
    if (impl != null) {
      impl.createReference(size,data,callback ?? bindings.DoNothingFunction.fn);
      return;
    }
    var params = new _PageCreateReferenceParams();
    params.size = size;
    params.data = data;
    Function zonedCallback;
    if ((callback == null) || identical(Zone.current, Zone.ROOT)) {
      zonedCallback = callback;
    } else {
      Zone z = Zone.current;
      zonedCallback = ((Status status, Reference reference) {
        z.bindCallback(() {
          callback(status, reference);
        })();
      });
    }
    ctrl.sendMessageWithRequestId(
        params,
        _pageMethodCreateReferenceName,
        -1,
        bindings.MessageHeader.kMessageExpectsResponse,
        zonedCallback);
  }
  void getReference(Reference reference,void callback(Status status, Value value)) {
    if (impl != null) {
      impl.getReference(reference,callback ?? bindings.DoNothingFunction.fn);
      return;
    }
    var params = new _PageGetReferenceParams();
    params.reference = reference;
    Function zonedCallback;
    if ((callback == null) || identical(Zone.current, Zone.ROOT)) {
      zonedCallback = callback;
    } else {
      Zone z = Zone.current;
      zonedCallback = ((Status status, Value value) {
        z.bindCallback(() {
          callback(status, value);
        })();
      });
    }
    ctrl.sendMessageWithRequestId(
        params,
        _pageMethodGetReferenceName,
        -1,
        bindings.MessageHeader.kMessageExpectsResponse,
        zonedCallback);
  }
  void getPartialReference(Reference reference,int offset,int maxSize,void callback(Status status, Stream stream)) {
    if (impl != null) {
      impl.getPartialReference(reference,offset,maxSize,callback ?? bindings.DoNothingFunction.fn);
      return;
    }
    var params = new _PageGetPartialReferenceParams();
    params.reference = reference;
    params.offset = offset;
    params.maxSize = maxSize;
    Function zonedCallback;
    if ((callback == null) || identical(Zone.current, Zone.ROOT)) {
      zonedCallback = callback;
    } else {
      Zone z = Zone.current;
      zonedCallback = ((Status status, Stream stream) {
        z.bindCallback(() {
          callback(status, stream);
        })();
      });
    }
    ctrl.sendMessageWithRequestId(
        params,
        _pageMethodGetPartialReferenceName,
        -1,
        bindings.MessageHeader.kMessageExpectsResponse,
        zonedCallback);
  }
  void startTransaction(void callback(Status status)) {
    if (impl != null) {
      impl.startTransaction(callback ?? bindings.DoNothingFunction.fn);
      return;
    }
    var params = new _PageStartTransactionParams();
    Function zonedCallback;
    if ((callback == null) || identical(Zone.current, Zone.ROOT)) {
      zonedCallback = callback;
    } else {
      Zone z = Zone.current;
      zonedCallback = ((Status status) {
        z.bindCallback(() {
          callback(status);
        })();
      });
    }
    ctrl.sendMessageWithRequestId(
        params,
        _pageMethodStartTransactionName,
        -1,
        bindings.MessageHeader.kMessageExpectsResponse,
        zonedCallback);
  }
  void commit(void callback(Status status)) {
    if (impl != null) {
      impl.commit(callback ?? bindings.DoNothingFunction.fn);
      return;
    }
    var params = new _PageCommitParams();
    Function zonedCallback;
    if ((callback == null) || identical(Zone.current, Zone.ROOT)) {
      zonedCallback = callback;
    } else {
      Zone z = Zone.current;
      zonedCallback = ((Status status) {
        z.bindCallback(() {
          callback(status);
        })();
      });
    }
    ctrl.sendMessageWithRequestId(
        params,
        _pageMethodCommitName,
        -1,
        bindings.MessageHeader.kMessageExpectsResponse,
        zonedCallback);
  }
  void rollback(void callback(Status status)) {
    if (impl != null) {
      impl.rollback(callback ?? bindings.DoNothingFunction.fn);
      return;
    }
    var params = new _PageRollbackParams();
    Function zonedCallback;
    if ((callback == null) || identical(Zone.current, Zone.ROOT)) {
      zonedCallback = callback;
    } else {
      Zone z = Zone.current;
      zonedCallback = ((Status status) {
        z.bindCallback(() {
          callback(status);
        })();
      });
    }
    ctrl.sendMessageWithRequestId(
        params,
        _pageMethodRollbackName,
        -1,
        bindings.MessageHeader.kMessageExpectsResponse,
        zonedCallback);
  }
}

class _PageStubControl
    extends bindings.StubMessageHandler
    implements bindings.StubControl<Page> {
  Page _impl;

  _PageStubControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [Page impl])
      : super.fromEndpoint(endpoint, autoBegin: impl != null) {
    _impl = impl;
  }

  _PageStubControl.fromHandle(
      core.MojoHandle handle, [Page impl])
      : super.fromHandle(handle, autoBegin: impl != null) {
    _impl = impl;
  }

  _PageStubControl.unbound([this._impl]) : super.unbound();

  String get serviceName => Page.serviceName;


  Function _pageGetIdResponseParamsResponder(
      int requestId) {
  return (List<int> id) {
      var result = new PageGetIdResponseParams();
      result.id = id;
      sendResponse(buildResponseWithId(
          result,
          _pageMethodGetIdName,
          requestId,
          bindings.MessageHeader.kMessageIsResponse));
    };
  }
  Function _pageGetSnapshotResponseParamsResponder(
      int requestId) {
  return (Status status, PageSnapshotInterface snapshot) {
      var result = new PageGetSnapshotResponseParams();
      result.status = status;
      result.snapshot = snapshot;
      sendResponse(buildResponseWithId(
          result,
          _pageMethodGetSnapshotName,
          requestId,
          bindings.MessageHeader.kMessageIsResponse));
    };
  }
  Function _pageWatchResponseParamsResponder(
      int requestId) {
  return (Status status) {
      var result = new PageWatchResponseParams();
      result.status = status;
      sendResponse(buildResponseWithId(
          result,
          _pageMethodWatchName,
          requestId,
          bindings.MessageHeader.kMessageIsResponse));
    };
  }
  Function _pagePutResponseParamsResponder(
      int requestId) {
  return (Status status) {
      var result = new PagePutResponseParams();
      result.status = status;
      sendResponse(buildResponseWithId(
          result,
          _pageMethodPutName,
          requestId,
          bindings.MessageHeader.kMessageIsResponse));
    };
  }
  Function _pagePutReferenceResponseParamsResponder(
      int requestId) {
  return (Status status) {
      var result = new PagePutReferenceResponseParams();
      result.status = status;
      sendResponse(buildResponseWithId(
          result,
          _pageMethodPutReferenceName,
          requestId,
          bindings.MessageHeader.kMessageIsResponse));
    };
  }
  Function _pageDeleteResponseParamsResponder(
      int requestId) {
  return (Status status) {
      var result = new PageDeleteResponseParams();
      result.status = status;
      sendResponse(buildResponseWithId(
          result,
          _pageMethodDeleteName,
          requestId,
          bindings.MessageHeader.kMessageIsResponse));
    };
  }
  Function _pageCreateReferenceResponseParamsResponder(
      int requestId) {
  return (Status status, Reference reference) {
      var result = new PageCreateReferenceResponseParams();
      result.status = status;
      result.reference = reference;
      sendResponse(buildResponseWithId(
          result,
          _pageMethodCreateReferenceName,
          requestId,
          bindings.MessageHeader.kMessageIsResponse));
    };
  }
  Function _pageGetReferenceResponseParamsResponder(
      int requestId) {
  return (Status status, Value value) {
      var result = new PageGetReferenceResponseParams();
      result.status = status;
      result.value = value;
      sendResponse(buildResponseWithId(
          result,
          _pageMethodGetReferenceName,
          requestId,
          bindings.MessageHeader.kMessageIsResponse));
    };
  }
  Function _pageGetPartialReferenceResponseParamsResponder(
      int requestId) {
  return (Status status, Stream stream) {
      var result = new PageGetPartialReferenceResponseParams();
      result.status = status;
      result.stream = stream;
      sendResponse(buildResponseWithId(
          result,
          _pageMethodGetPartialReferenceName,
          requestId,
          bindings.MessageHeader.kMessageIsResponse));
    };
  }
  Function _pageStartTransactionResponseParamsResponder(
      int requestId) {
  return (Status status) {
      var result = new PageStartTransactionResponseParams();
      result.status = status;
      sendResponse(buildResponseWithId(
          result,
          _pageMethodStartTransactionName,
          requestId,
          bindings.MessageHeader.kMessageIsResponse));
    };
  }
  Function _pageCommitResponseParamsResponder(
      int requestId) {
  return (Status status) {
      var result = new PageCommitResponseParams();
      result.status = status;
      sendResponse(buildResponseWithId(
          result,
          _pageMethodCommitName,
          requestId,
          bindings.MessageHeader.kMessageIsResponse));
    };
  }
  Function _pageRollbackResponseParamsResponder(
      int requestId) {
  return (Status status) {
      var result = new PageRollbackResponseParams();
      result.status = status;
      sendResponse(buildResponseWithId(
          result,
          _pageMethodRollbackName,
          requestId,
          bindings.MessageHeader.kMessageIsResponse));
    };
  }

  void handleMessage(bindings.ServiceMessage message) {
    if (bindings.ControlMessageHandler.isControlMessage(message)) {
      bindings.ControlMessageHandler.handleMessage(
          this, 0, message);
      return;
    }
    if (_impl == null) {
      throw new core.MojoApiError("$this has no implementation set");
    }
    switch (message.header.type) {
      case _pageMethodGetIdName:
        _impl.getId(_pageGetIdResponseParamsResponder(message.header.requestId));
        break;
      case _pageMethodGetSnapshotName:
        _impl.getSnapshot(_pageGetSnapshotResponseParamsResponder(message.header.requestId));
        break;
      case _pageMethodWatchName:
        var params = _PageWatchParams.deserialize(
            message.payload);
        _impl.watch(params.watcher, _pageWatchResponseParamsResponder(message.header.requestId));
        break;
      case _pageMethodPutName:
        var params = _PagePutParams.deserialize(
            message.payload);
        _impl.put(params.key, params.value, _pagePutResponseParamsResponder(message.header.requestId));
        break;
      case _pageMethodPutReferenceName:
        var params = _PagePutReferenceParams.deserialize(
            message.payload);
        _impl.putReference(params.key, params.reference, _pagePutReferenceResponseParamsResponder(message.header.requestId));
        break;
      case _pageMethodDeleteName:
        var params = _PageDeleteParams.deserialize(
            message.payload);
        _impl.delete(params.key, _pageDeleteResponseParamsResponder(message.header.requestId));
        break;
      case _pageMethodCreateReferenceName:
        var params = _PageCreateReferenceParams.deserialize(
            message.payload);
        _impl.createReference(params.size, params.data, _pageCreateReferenceResponseParamsResponder(message.header.requestId));
        break;
      case _pageMethodGetReferenceName:
        var params = _PageGetReferenceParams.deserialize(
            message.payload);
        _impl.getReference(params.reference, _pageGetReferenceResponseParamsResponder(message.header.requestId));
        break;
      case _pageMethodGetPartialReferenceName:
        var params = _PageGetPartialReferenceParams.deserialize(
            message.payload);
        _impl.getPartialReference(params.reference, params.offset, params.maxSize, _pageGetPartialReferenceResponseParamsResponder(message.header.requestId));
        break;
      case _pageMethodStartTransactionName:
        _impl.startTransaction(_pageStartTransactionResponseParamsResponder(message.header.requestId));
        break;
      case _pageMethodCommitName:
        _impl.commit(_pageCommitResponseParamsResponder(message.header.requestId));
        break;
      case _pageMethodRollbackName:
        _impl.rollback(_pageRollbackResponseParamsResponder(message.header.requestId));
        break;
      default:
        throw new bindings.MojoCodecError("Unexpected message name");
        break;
    }
  }

  Page get impl => _impl;
  set impl(Page d) {
    if (d == null) {
      throw new core.MojoApiError("$this: Cannot set a null implementation");
    }
    if (isBound && (_impl == null)) {
      beginHandlingEvents();
    }
    _impl = d;
  }

  @override
  void bind(core.MojoMessagePipeEndpoint endpoint) {
    super.bind(endpoint);
    if (!isOpen && (_impl != null)) {
      beginHandlingEvents();
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_PageStubControl($superString)";
  }

  int get version => 0;
}

class PageStub
    extends bindings.Stub<Page>
    implements Page,
               PageInterface,
               PageInterfaceRequest {
  PageStub.unbound([Page impl])
      : super(new _PageStubControl.unbound(impl));

  PageStub.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [Page impl])
      : super(new _PageStubControl.fromEndpoint(endpoint, impl));

  PageStub.fromHandle(
      core.MojoHandle handle, [Page impl])
      : super(new _PageStubControl.fromHandle(handle, impl));

  static PageStub newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For PageStub"));
    return new PageStub.fromEndpoint(endpoint);
  }


  void getId(void callback(List<int> id)) {
    return impl.getId(callback);
  }
  void getSnapshot(void callback(Status status, PageSnapshotInterface snapshot)) {
    return impl.getSnapshot(callback);
  }
  void watch(PageWatcherInterface watcher,void callback(Status status)) {
    return impl.watch(watcher,callback);
  }
  void put(List<int> key,List<int> value,void callback(Status status)) {
    return impl.put(key,value,callback);
  }
  void putReference(List<int> key,Reference reference,void callback(Status status)) {
    return impl.putReference(key,reference,callback);
  }
  void delete(List<int> key,void callback(Status status)) {
    return impl.delete(key,callback);
  }
  void createReference(int size,core.MojoDataPipeConsumer data,void callback(Status status, Reference reference)) {
    return impl.createReference(size,data,callback);
  }
  void getReference(Reference reference,void callback(Status status, Value value)) {
    return impl.getReference(reference,callback);
  }
  void getPartialReference(Reference reference,int offset,int maxSize,void callback(Status status, Stream stream)) {
    return impl.getPartialReference(reference,offset,maxSize,callback);
  }
  void startTransaction(void callback(Status status)) {
    return impl.startTransaction(callback);
  }
  void commit(void callback(Status status)) {
    return impl.commit(callback);
  }
  void rollback(void callback(Status status)) {
    return impl.rollback(callback);
  }
}

const int _pageSnapshotMethodGetAllName = 0;
const int _pageSnapshotMethodGetKeysName = 1;
const int _pageSnapshotMethodGetName = 2;
const int _pageSnapshotMethodGetPartialName = 3;

class _PageSnapshotServiceDescription implements service_describer.ServiceDescription {
  void getTopLevelInterface(Function responder) {
    responder(null);
  }

  void getTypeDefinition(String typeKey, Function responder) {
    responder(null);
  }

  void getAllTypeDefinitions(Function responder) {
    responder(null);
  }
}

abstract class PageSnapshot {
  static const String serviceName = null;

  static service_describer.ServiceDescription _cachedServiceDescription;
  static service_describer.ServiceDescription get serviceDescription {
    if (_cachedServiceDescription == null) {
      _cachedServiceDescription = new _PageSnapshotServiceDescription();
    }
    return _cachedServiceDescription;
  }

  static PageSnapshotProxy connectToService(
      bindings.ServiceConnector s, String url, [String serviceName]) {
    PageSnapshotProxy p = new PageSnapshotProxy.unbound();
    String name = serviceName ?? PageSnapshot.serviceName;
    if ((name == null) || name.isEmpty) {
      throw new core.MojoApiError(
          "If an interface has no ServiceName, then one must be provided.");
    }
    s.connectToService(url, p, name);
    return p;
  }
  void getAll(List<int> keyPrefix,void callback(Status status, List<Entry> entries));
  void getKeys(List<int> keyPrefix,void callback(Status status, List<List<int>> keys));
  void get(List<int> key,void callback(Status status, Value value));
  void getPartial(List<int> key,int offset,int maxSize,void callback(Status status, Stream stream));
}

abstract class PageSnapshotInterface
    implements bindings.MojoInterface<PageSnapshot>,
               PageSnapshot {
  factory PageSnapshotInterface([PageSnapshot impl]) =>
      new PageSnapshotStub.unbound(impl);

  factory PageSnapshotInterface.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint,
      [PageSnapshot impl]) =>
      new PageSnapshotStub.fromEndpoint(endpoint, impl);

  factory PageSnapshotInterface.fromMock(
      PageSnapshot mock) =>
      new PageSnapshotProxy.fromMock(mock);
}

abstract class PageSnapshotInterfaceRequest
    implements bindings.MojoInterface<PageSnapshot>,
               PageSnapshot {
  factory PageSnapshotInterfaceRequest() =>
      new PageSnapshotProxy.unbound();
}

class _PageSnapshotProxyControl
    extends bindings.ProxyMessageHandler
    implements bindings.ProxyControl<PageSnapshot> {
  PageSnapshot impl;

  _PageSnapshotProxyControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) : super.fromEndpoint(endpoint);

  _PageSnapshotProxyControl.fromHandle(
      core.MojoHandle handle) : super.fromHandle(handle);

  _PageSnapshotProxyControl.unbound() : super.unbound();

  String get serviceName => PageSnapshot.serviceName;

  void handleResponse(bindings.ServiceMessage message) {
    switch (message.header.type) {
      case _pageSnapshotMethodGetAllName:
        Function callback = getCallback(message);
        if (callback != null) {
          var r = PageSnapshotGetAllResponseParams.deserialize(
              message.payload);
          callback(r.status , r.entries );
        }
        break;
      case _pageSnapshotMethodGetKeysName:
        Function callback = getCallback(message);
        if (callback != null) {
          var r = PageSnapshotGetKeysResponseParams.deserialize(
              message.payload);
          callback(r.status , r.keys );
        }
        break;
      case _pageSnapshotMethodGetName:
        Function callback = getCallback(message);
        if (callback != null) {
          var r = PageSnapshotGetResponseParams.deserialize(
              message.payload);
          callback(r.status , r.value );
        }
        break;
      case _pageSnapshotMethodGetPartialName:
        Function callback = getCallback(message);
        if (callback != null) {
          var r = PageSnapshotGetPartialResponseParams.deserialize(
              message.payload);
          callback(r.status , r.stream );
        }
        break;
      default:
        proxyError("Unexpected message type: ${message.header.type}");
        close(immediate: true);
        break;
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_PageSnapshotProxyControl($superString)";
  }
}

class PageSnapshotProxy
    extends bindings.Proxy<PageSnapshot>
    implements PageSnapshot,
               PageSnapshotInterface,
               PageSnapshotInterfaceRequest {
  PageSnapshotProxy.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint)
      : super(new _PageSnapshotProxyControl.fromEndpoint(endpoint));

  PageSnapshotProxy.fromHandle(core.MojoHandle handle)
      : super(new _PageSnapshotProxyControl.fromHandle(handle));

  PageSnapshotProxy.unbound()
      : super(new _PageSnapshotProxyControl.unbound());

  factory PageSnapshotProxy.fromMock(PageSnapshot mock) {
    PageSnapshotProxy newMockedProxy =
        new PageSnapshotProxy.unbound();
    newMockedProxy.impl = mock;
    return newMockedProxy;
  }

  static PageSnapshotProxy newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For PageSnapshotProxy"));
    return new PageSnapshotProxy.fromEndpoint(endpoint);
  }


  void getAll(List<int> keyPrefix,void callback(Status status, List<Entry> entries)) {
    if (impl != null) {
      impl.getAll(keyPrefix,callback ?? bindings.DoNothingFunction.fn);
      return;
    }
    var params = new _PageSnapshotGetAllParams();
    params.keyPrefix = keyPrefix;
    Function zonedCallback;
    if ((callback == null) || identical(Zone.current, Zone.ROOT)) {
      zonedCallback = callback;
    } else {
      Zone z = Zone.current;
      zonedCallback = ((Status status, List<Entry> entries) {
        z.bindCallback(() {
          callback(status, entries);
        })();
      });
    }
    ctrl.sendMessageWithRequestId(
        params,
        _pageSnapshotMethodGetAllName,
        -1,
        bindings.MessageHeader.kMessageExpectsResponse,
        zonedCallback);
  }
  void getKeys(List<int> keyPrefix,void callback(Status status, List<List<int>> keys)) {
    if (impl != null) {
      impl.getKeys(keyPrefix,callback ?? bindings.DoNothingFunction.fn);
      return;
    }
    var params = new _PageSnapshotGetKeysParams();
    params.keyPrefix = keyPrefix;
    Function zonedCallback;
    if ((callback == null) || identical(Zone.current, Zone.ROOT)) {
      zonedCallback = callback;
    } else {
      Zone z = Zone.current;
      zonedCallback = ((Status status, List<List<int>> keys) {
        z.bindCallback(() {
          callback(status, keys);
        })();
      });
    }
    ctrl.sendMessageWithRequestId(
        params,
        _pageSnapshotMethodGetKeysName,
        -1,
        bindings.MessageHeader.kMessageExpectsResponse,
        zonedCallback);
  }
  void get(List<int> key,void callback(Status status, Value value)) {
    if (impl != null) {
      impl.get(key,callback ?? bindings.DoNothingFunction.fn);
      return;
    }
    var params = new _PageSnapshotGetParams();
    params.key = key;
    Function zonedCallback;
    if ((callback == null) || identical(Zone.current, Zone.ROOT)) {
      zonedCallback = callback;
    } else {
      Zone z = Zone.current;
      zonedCallback = ((Status status, Value value) {
        z.bindCallback(() {
          callback(status, value);
        })();
      });
    }
    ctrl.sendMessageWithRequestId(
        params,
        _pageSnapshotMethodGetName,
        -1,
        bindings.MessageHeader.kMessageExpectsResponse,
        zonedCallback);
  }
  void getPartial(List<int> key,int offset,int maxSize,void callback(Status status, Stream stream)) {
    if (impl != null) {
      impl.getPartial(key,offset,maxSize,callback ?? bindings.DoNothingFunction.fn);
      return;
    }
    var params = new _PageSnapshotGetPartialParams();
    params.key = key;
    params.offset = offset;
    params.maxSize = maxSize;
    Function zonedCallback;
    if ((callback == null) || identical(Zone.current, Zone.ROOT)) {
      zonedCallback = callback;
    } else {
      Zone z = Zone.current;
      zonedCallback = ((Status status, Stream stream) {
        z.bindCallback(() {
          callback(status, stream);
        })();
      });
    }
    ctrl.sendMessageWithRequestId(
        params,
        _pageSnapshotMethodGetPartialName,
        -1,
        bindings.MessageHeader.kMessageExpectsResponse,
        zonedCallback);
  }
}

class _PageSnapshotStubControl
    extends bindings.StubMessageHandler
    implements bindings.StubControl<PageSnapshot> {
  PageSnapshot _impl;

  _PageSnapshotStubControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [PageSnapshot impl])
      : super.fromEndpoint(endpoint, autoBegin: impl != null) {
    _impl = impl;
  }

  _PageSnapshotStubControl.fromHandle(
      core.MojoHandle handle, [PageSnapshot impl])
      : super.fromHandle(handle, autoBegin: impl != null) {
    _impl = impl;
  }

  _PageSnapshotStubControl.unbound([this._impl]) : super.unbound();

  String get serviceName => PageSnapshot.serviceName;


  Function _pageSnapshotGetAllResponseParamsResponder(
      int requestId) {
  return (Status status, List<Entry> entries) {
      var result = new PageSnapshotGetAllResponseParams();
      result.status = status;
      result.entries = entries;
      sendResponse(buildResponseWithId(
          result,
          _pageSnapshotMethodGetAllName,
          requestId,
          bindings.MessageHeader.kMessageIsResponse));
    };
  }
  Function _pageSnapshotGetKeysResponseParamsResponder(
      int requestId) {
  return (Status status, List<List<int>> keys) {
      var result = new PageSnapshotGetKeysResponseParams();
      result.status = status;
      result.keys = keys;
      sendResponse(buildResponseWithId(
          result,
          _pageSnapshotMethodGetKeysName,
          requestId,
          bindings.MessageHeader.kMessageIsResponse));
    };
  }
  Function _pageSnapshotGetResponseParamsResponder(
      int requestId) {
  return (Status status, Value value) {
      var result = new PageSnapshotGetResponseParams();
      result.status = status;
      result.value = value;
      sendResponse(buildResponseWithId(
          result,
          _pageSnapshotMethodGetName,
          requestId,
          bindings.MessageHeader.kMessageIsResponse));
    };
  }
  Function _pageSnapshotGetPartialResponseParamsResponder(
      int requestId) {
  return (Status status, Stream stream) {
      var result = new PageSnapshotGetPartialResponseParams();
      result.status = status;
      result.stream = stream;
      sendResponse(buildResponseWithId(
          result,
          _pageSnapshotMethodGetPartialName,
          requestId,
          bindings.MessageHeader.kMessageIsResponse));
    };
  }

  void handleMessage(bindings.ServiceMessage message) {
    if (bindings.ControlMessageHandler.isControlMessage(message)) {
      bindings.ControlMessageHandler.handleMessage(
          this, 0, message);
      return;
    }
    if (_impl == null) {
      throw new core.MojoApiError("$this has no implementation set");
    }
    switch (message.header.type) {
      case _pageSnapshotMethodGetAllName:
        var params = _PageSnapshotGetAllParams.deserialize(
            message.payload);
        _impl.getAll(params.keyPrefix, _pageSnapshotGetAllResponseParamsResponder(message.header.requestId));
        break;
      case _pageSnapshotMethodGetKeysName:
        var params = _PageSnapshotGetKeysParams.deserialize(
            message.payload);
        _impl.getKeys(params.keyPrefix, _pageSnapshotGetKeysResponseParamsResponder(message.header.requestId));
        break;
      case _pageSnapshotMethodGetName:
        var params = _PageSnapshotGetParams.deserialize(
            message.payload);
        _impl.get(params.key, _pageSnapshotGetResponseParamsResponder(message.header.requestId));
        break;
      case _pageSnapshotMethodGetPartialName:
        var params = _PageSnapshotGetPartialParams.deserialize(
            message.payload);
        _impl.getPartial(params.key, params.offset, params.maxSize, _pageSnapshotGetPartialResponseParamsResponder(message.header.requestId));
        break;
      default:
        throw new bindings.MojoCodecError("Unexpected message name");
        break;
    }
  }

  PageSnapshot get impl => _impl;
  set impl(PageSnapshot d) {
    if (d == null) {
      throw new core.MojoApiError("$this: Cannot set a null implementation");
    }
    if (isBound && (_impl == null)) {
      beginHandlingEvents();
    }
    _impl = d;
  }

  @override
  void bind(core.MojoMessagePipeEndpoint endpoint) {
    super.bind(endpoint);
    if (!isOpen && (_impl != null)) {
      beginHandlingEvents();
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_PageSnapshotStubControl($superString)";
  }

  int get version => 0;
}

class PageSnapshotStub
    extends bindings.Stub<PageSnapshot>
    implements PageSnapshot,
               PageSnapshotInterface,
               PageSnapshotInterfaceRequest {
  PageSnapshotStub.unbound([PageSnapshot impl])
      : super(new _PageSnapshotStubControl.unbound(impl));

  PageSnapshotStub.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [PageSnapshot impl])
      : super(new _PageSnapshotStubControl.fromEndpoint(endpoint, impl));

  PageSnapshotStub.fromHandle(
      core.MojoHandle handle, [PageSnapshot impl])
      : super(new _PageSnapshotStubControl.fromHandle(handle, impl));

  static PageSnapshotStub newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For PageSnapshotStub"));
    return new PageSnapshotStub.fromEndpoint(endpoint);
  }


  void getAll(List<int> keyPrefix,void callback(Status status, List<Entry> entries)) {
    return impl.getAll(keyPrefix,callback);
  }
  void getKeys(List<int> keyPrefix,void callback(Status status, List<List<int>> keys)) {
    return impl.getKeys(keyPrefix,callback);
  }
  void get(List<int> key,void callback(Status status, Value value)) {
    return impl.get(key,callback);
  }
  void getPartial(List<int> key,int offset,int maxSize,void callback(Status status, Stream stream)) {
    return impl.getPartial(key,offset,maxSize,callback);
  }
}

const int _pageWatcherMethodOnInitialStateName = 0;
const int _pageWatcherMethodOnChangeName = 1;

class _PageWatcherServiceDescription implements service_describer.ServiceDescription {
  void getTopLevelInterface(Function responder) {
    responder(null);
  }

  void getTypeDefinition(String typeKey, Function responder) {
    responder(null);
  }

  void getAllTypeDefinitions(Function responder) {
    responder(null);
  }
}

abstract class PageWatcher {
  static const String serviceName = null;

  static service_describer.ServiceDescription _cachedServiceDescription;
  static service_describer.ServiceDescription get serviceDescription {
    if (_cachedServiceDescription == null) {
      _cachedServiceDescription = new _PageWatcherServiceDescription();
    }
    return _cachedServiceDescription;
  }

  static PageWatcherProxy connectToService(
      bindings.ServiceConnector s, String url, [String serviceName]) {
    PageWatcherProxy p = new PageWatcherProxy.unbound();
    String name = serviceName ?? PageWatcher.serviceName;
    if ((name == null) || name.isEmpty) {
      throw new core.MojoApiError(
          "If an interface has no ServiceName, then one must be provided.");
    }
    s.connectToService(url, p, name);
    return p;
  }
  void onInitialState(PageSnapshotInterface snapshot,void callback());
  void onChange(PageChange pageChange,void callback());
}

abstract class PageWatcherInterface
    implements bindings.MojoInterface<PageWatcher>,
               PageWatcher {
  factory PageWatcherInterface([PageWatcher impl]) =>
      new PageWatcherStub.unbound(impl);

  factory PageWatcherInterface.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint,
      [PageWatcher impl]) =>
      new PageWatcherStub.fromEndpoint(endpoint, impl);

  factory PageWatcherInterface.fromMock(
      PageWatcher mock) =>
      new PageWatcherProxy.fromMock(mock);
}

abstract class PageWatcherInterfaceRequest
    implements bindings.MojoInterface<PageWatcher>,
               PageWatcher {
  factory PageWatcherInterfaceRequest() =>
      new PageWatcherProxy.unbound();
}

class _PageWatcherProxyControl
    extends bindings.ProxyMessageHandler
    implements bindings.ProxyControl<PageWatcher> {
  PageWatcher impl;

  _PageWatcherProxyControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) : super.fromEndpoint(endpoint);

  _PageWatcherProxyControl.fromHandle(
      core.MojoHandle handle) : super.fromHandle(handle);

  _PageWatcherProxyControl.unbound() : super.unbound();

  String get serviceName => PageWatcher.serviceName;

  void handleResponse(bindings.ServiceMessage message) {
    switch (message.header.type) {
      case _pageWatcherMethodOnInitialStateName:
        Function callback = getCallback(message);
        if (callback != null) {
          var r = PageWatcherOnInitialStateResponseParams.deserialize(
              message.payload);
          callback();
        }
        break;
      case _pageWatcherMethodOnChangeName:
        Function callback = getCallback(message);
        if (callback != null) {
          var r = PageWatcherOnChangeResponseParams.deserialize(
              message.payload);
          callback();
        }
        break;
      default:
        proxyError("Unexpected message type: ${message.header.type}");
        close(immediate: true);
        break;
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_PageWatcherProxyControl($superString)";
  }
}

class PageWatcherProxy
    extends bindings.Proxy<PageWatcher>
    implements PageWatcher,
               PageWatcherInterface,
               PageWatcherInterfaceRequest {
  PageWatcherProxy.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint)
      : super(new _PageWatcherProxyControl.fromEndpoint(endpoint));

  PageWatcherProxy.fromHandle(core.MojoHandle handle)
      : super(new _PageWatcherProxyControl.fromHandle(handle));

  PageWatcherProxy.unbound()
      : super(new _PageWatcherProxyControl.unbound());

  factory PageWatcherProxy.fromMock(PageWatcher mock) {
    PageWatcherProxy newMockedProxy =
        new PageWatcherProxy.unbound();
    newMockedProxy.impl = mock;
    return newMockedProxy;
  }

  static PageWatcherProxy newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For PageWatcherProxy"));
    return new PageWatcherProxy.fromEndpoint(endpoint);
  }


  void onInitialState(PageSnapshotInterface snapshot,void callback()) {
    if (impl != null) {
      impl.onInitialState(snapshot,callback ?? bindings.DoNothingFunction.fn);
      return;
    }
    var params = new _PageWatcherOnInitialStateParams();
    params.snapshot = snapshot;
    Function zonedCallback;
    if ((callback == null) || identical(Zone.current, Zone.ROOT)) {
      zonedCallback = callback;
    } else {
      Zone z = Zone.current;
      zonedCallback = (() {
        z.bindCallback(() {
          callback();
        })();
      });
    }
    ctrl.sendMessageWithRequestId(
        params,
        _pageWatcherMethodOnInitialStateName,
        -1,
        bindings.MessageHeader.kMessageExpectsResponse,
        zonedCallback);
  }
  void onChange(PageChange pageChange,void callback()) {
    if (impl != null) {
      impl.onChange(pageChange,callback ?? bindings.DoNothingFunction.fn);
      return;
    }
    var params = new _PageWatcherOnChangeParams();
    params.pageChange = pageChange;
    Function zonedCallback;
    if ((callback == null) || identical(Zone.current, Zone.ROOT)) {
      zonedCallback = callback;
    } else {
      Zone z = Zone.current;
      zonedCallback = (() {
        z.bindCallback(() {
          callback();
        })();
      });
    }
    ctrl.sendMessageWithRequestId(
        params,
        _pageWatcherMethodOnChangeName,
        -1,
        bindings.MessageHeader.kMessageExpectsResponse,
        zonedCallback);
  }
}

class _PageWatcherStubControl
    extends bindings.StubMessageHandler
    implements bindings.StubControl<PageWatcher> {
  PageWatcher _impl;

  _PageWatcherStubControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [PageWatcher impl])
      : super.fromEndpoint(endpoint, autoBegin: impl != null) {
    _impl = impl;
  }

  _PageWatcherStubControl.fromHandle(
      core.MojoHandle handle, [PageWatcher impl])
      : super.fromHandle(handle, autoBegin: impl != null) {
    _impl = impl;
  }

  _PageWatcherStubControl.unbound([this._impl]) : super.unbound();

  String get serviceName => PageWatcher.serviceName;


  Function _pageWatcherOnInitialStateResponseParamsResponder(
      int requestId) {
  return () {
      var result = new PageWatcherOnInitialStateResponseParams();
      sendResponse(buildResponseWithId(
          result,
          _pageWatcherMethodOnInitialStateName,
          requestId,
          bindings.MessageHeader.kMessageIsResponse));
    };
  }
  Function _pageWatcherOnChangeResponseParamsResponder(
      int requestId) {
  return () {
      var result = new PageWatcherOnChangeResponseParams();
      sendResponse(buildResponseWithId(
          result,
          _pageWatcherMethodOnChangeName,
          requestId,
          bindings.MessageHeader.kMessageIsResponse));
    };
  }

  void handleMessage(bindings.ServiceMessage message) {
    if (bindings.ControlMessageHandler.isControlMessage(message)) {
      bindings.ControlMessageHandler.handleMessage(
          this, 0, message);
      return;
    }
    if (_impl == null) {
      throw new core.MojoApiError("$this has no implementation set");
    }
    switch (message.header.type) {
      case _pageWatcherMethodOnInitialStateName:
        var params = _PageWatcherOnInitialStateParams.deserialize(
            message.payload);
        _impl.onInitialState(params.snapshot, _pageWatcherOnInitialStateResponseParamsResponder(message.header.requestId));
        break;
      case _pageWatcherMethodOnChangeName:
        var params = _PageWatcherOnChangeParams.deserialize(
            message.payload);
        _impl.onChange(params.pageChange, _pageWatcherOnChangeResponseParamsResponder(message.header.requestId));
        break;
      default:
        throw new bindings.MojoCodecError("Unexpected message name");
        break;
    }
  }

  PageWatcher get impl => _impl;
  set impl(PageWatcher d) {
    if (d == null) {
      throw new core.MojoApiError("$this: Cannot set a null implementation");
    }
    if (isBound && (_impl == null)) {
      beginHandlingEvents();
    }
    _impl = d;
  }

  @override
  void bind(core.MojoMessagePipeEndpoint endpoint) {
    super.bind(endpoint);
    if (!isOpen && (_impl != null)) {
      beginHandlingEvents();
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_PageWatcherStubControl($superString)";
  }

  int get version => 0;
}

class PageWatcherStub
    extends bindings.Stub<PageWatcher>
    implements PageWatcher,
               PageWatcherInterface,
               PageWatcherInterfaceRequest {
  PageWatcherStub.unbound([PageWatcher impl])
      : super(new _PageWatcherStubControl.unbound(impl));

  PageWatcherStub.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [PageWatcher impl])
      : super(new _PageWatcherStubControl.fromEndpoint(endpoint, impl));

  PageWatcherStub.fromHandle(
      core.MojoHandle handle, [PageWatcher impl])
      : super(new _PageWatcherStubControl.fromHandle(handle, impl));

  static PageWatcherStub newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For PageWatcherStub"));
    return new PageWatcherStub.fromEndpoint(endpoint);
  }


  void onInitialState(PageSnapshotInterface snapshot,void callback()) {
    return impl.onInitialState(snapshot,callback);
  }
  void onChange(PageChange pageChange,void callback()) {
    return impl.onChange(pageChange,callback);
  }
}

const int _conflictResolverFactoryMethodGetPolicyName = 0;
const int _conflictResolverFactoryMethodNewConflictResolverName = 1;

class _ConflictResolverFactoryServiceDescription implements service_describer.ServiceDescription {
  void getTopLevelInterface(Function responder) {
    responder(null);
  }

  void getTypeDefinition(String typeKey, Function responder) {
    responder(null);
  }

  void getAllTypeDefinitions(Function responder) {
    responder(null);
  }
}

abstract class ConflictResolverFactory {
  static const String serviceName = null;

  static service_describer.ServiceDescription _cachedServiceDescription;
  static service_describer.ServiceDescription get serviceDescription {
    if (_cachedServiceDescription == null) {
      _cachedServiceDescription = new _ConflictResolverFactoryServiceDescription();
    }
    return _cachedServiceDescription;
  }

  static ConflictResolverFactoryProxy connectToService(
      bindings.ServiceConnector s, String url, [String serviceName]) {
    ConflictResolverFactoryProxy p = new ConflictResolverFactoryProxy.unbound();
    String name = serviceName ?? ConflictResolverFactory.serviceName;
    if ((name == null) || name.isEmpty) {
      throw new core.MojoApiError(
          "If an interface has no ServiceName, then one must be provided.");
    }
    s.connectToService(url, p, name);
    return p;
  }
  void getPolicy(List<int> pageId,void callback(ConflictResolutionPolicy policy));
  void newConflictResolver(List<int> pageId, ConflictResolverInterfaceRequest resolver);
}

abstract class ConflictResolverFactoryInterface
    implements bindings.MojoInterface<ConflictResolverFactory>,
               ConflictResolverFactory {
  factory ConflictResolverFactoryInterface([ConflictResolverFactory impl]) =>
      new ConflictResolverFactoryStub.unbound(impl);

  factory ConflictResolverFactoryInterface.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint,
      [ConflictResolverFactory impl]) =>
      new ConflictResolverFactoryStub.fromEndpoint(endpoint, impl);

  factory ConflictResolverFactoryInterface.fromMock(
      ConflictResolverFactory mock) =>
      new ConflictResolverFactoryProxy.fromMock(mock);
}

abstract class ConflictResolverFactoryInterfaceRequest
    implements bindings.MojoInterface<ConflictResolverFactory>,
               ConflictResolverFactory {
  factory ConflictResolverFactoryInterfaceRequest() =>
      new ConflictResolverFactoryProxy.unbound();
}

class _ConflictResolverFactoryProxyControl
    extends bindings.ProxyMessageHandler
    implements bindings.ProxyControl<ConflictResolverFactory> {
  ConflictResolverFactory impl;

  _ConflictResolverFactoryProxyControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) : super.fromEndpoint(endpoint);

  _ConflictResolverFactoryProxyControl.fromHandle(
      core.MojoHandle handle) : super.fromHandle(handle);

  _ConflictResolverFactoryProxyControl.unbound() : super.unbound();

  String get serviceName => ConflictResolverFactory.serviceName;

  void handleResponse(bindings.ServiceMessage message) {
    switch (message.header.type) {
      case _conflictResolverFactoryMethodGetPolicyName:
        Function callback = getCallback(message);
        if (callback != null) {
          var r = ConflictResolverFactoryGetPolicyResponseParams.deserialize(
              message.payload);
          callback(r.policy );
        }
        break;
      default:
        proxyError("Unexpected message type: ${message.header.type}");
        close(immediate: true);
        break;
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_ConflictResolverFactoryProxyControl($superString)";
  }
}

class ConflictResolverFactoryProxy
    extends bindings.Proxy<ConflictResolverFactory>
    implements ConflictResolverFactory,
               ConflictResolverFactoryInterface,
               ConflictResolverFactoryInterfaceRequest {
  ConflictResolverFactoryProxy.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint)
      : super(new _ConflictResolverFactoryProxyControl.fromEndpoint(endpoint));

  ConflictResolverFactoryProxy.fromHandle(core.MojoHandle handle)
      : super(new _ConflictResolverFactoryProxyControl.fromHandle(handle));

  ConflictResolverFactoryProxy.unbound()
      : super(new _ConflictResolverFactoryProxyControl.unbound());

  factory ConflictResolverFactoryProxy.fromMock(ConflictResolverFactory mock) {
    ConflictResolverFactoryProxy newMockedProxy =
        new ConflictResolverFactoryProxy.unbound();
    newMockedProxy.impl = mock;
    return newMockedProxy;
  }

  static ConflictResolverFactoryProxy newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For ConflictResolverFactoryProxy"));
    return new ConflictResolverFactoryProxy.fromEndpoint(endpoint);
  }


  void getPolicy(List<int> pageId,void callback(ConflictResolutionPolicy policy)) {
    if (impl != null) {
      impl.getPolicy(pageId,callback ?? bindings.DoNothingFunction.fn);
      return;
    }
    var params = new _ConflictResolverFactoryGetPolicyParams();
    params.pageId = pageId;
    Function zonedCallback;
    if ((callback == null) || identical(Zone.current, Zone.ROOT)) {
      zonedCallback = callback;
    } else {
      Zone z = Zone.current;
      zonedCallback = ((ConflictResolutionPolicy policy) {
        z.bindCallback(() {
          callback(policy);
        })();
      });
    }
    ctrl.sendMessageWithRequestId(
        params,
        _conflictResolverFactoryMethodGetPolicyName,
        -1,
        bindings.MessageHeader.kMessageExpectsResponse,
        zonedCallback);
  }
  void newConflictResolver(List<int> pageId, ConflictResolverInterfaceRequest resolver) {
    if (impl != null) {
      impl.newConflictResolver(pageId, resolver);
      return;
    }
    if (!ctrl.isBound) {
      ctrl.proxyError("The Proxy is closed.");
      return;
    }
    var params = new _ConflictResolverFactoryNewConflictResolverParams();
    params.pageId = pageId;
    params.resolver = resolver;
    ctrl.sendMessage(params,
        _conflictResolverFactoryMethodNewConflictResolverName);
  }
}

class _ConflictResolverFactoryStubControl
    extends bindings.StubMessageHandler
    implements bindings.StubControl<ConflictResolverFactory> {
  ConflictResolverFactory _impl;

  _ConflictResolverFactoryStubControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [ConflictResolverFactory impl])
      : super.fromEndpoint(endpoint, autoBegin: impl != null) {
    _impl = impl;
  }

  _ConflictResolverFactoryStubControl.fromHandle(
      core.MojoHandle handle, [ConflictResolverFactory impl])
      : super.fromHandle(handle, autoBegin: impl != null) {
    _impl = impl;
  }

  _ConflictResolverFactoryStubControl.unbound([this._impl]) : super.unbound();

  String get serviceName => ConflictResolverFactory.serviceName;


  Function _conflictResolverFactoryGetPolicyResponseParamsResponder(
      int requestId) {
  return (ConflictResolutionPolicy policy) {
      var result = new ConflictResolverFactoryGetPolicyResponseParams();
      result.policy = policy;
      sendResponse(buildResponseWithId(
          result,
          _conflictResolverFactoryMethodGetPolicyName,
          requestId,
          bindings.MessageHeader.kMessageIsResponse));
    };
  }

  void handleMessage(bindings.ServiceMessage message) {
    if (bindings.ControlMessageHandler.isControlMessage(message)) {
      bindings.ControlMessageHandler.handleMessage(
          this, 0, message);
      return;
    }
    if (_impl == null) {
      throw new core.MojoApiError("$this has no implementation set");
    }
    switch (message.header.type) {
      case _conflictResolverFactoryMethodGetPolicyName:
        var params = _ConflictResolverFactoryGetPolicyParams.deserialize(
            message.payload);
        _impl.getPolicy(params.pageId, _conflictResolverFactoryGetPolicyResponseParamsResponder(message.header.requestId));
        break;
      case _conflictResolverFactoryMethodNewConflictResolverName:
        var params = _ConflictResolverFactoryNewConflictResolverParams.deserialize(
            message.payload);
        _impl.newConflictResolver(params.pageId, params.resolver);
        break;
      default:
        throw new bindings.MojoCodecError("Unexpected message name");
        break;
    }
  }

  ConflictResolverFactory get impl => _impl;
  set impl(ConflictResolverFactory d) {
    if (d == null) {
      throw new core.MojoApiError("$this: Cannot set a null implementation");
    }
    if (isBound && (_impl == null)) {
      beginHandlingEvents();
    }
    _impl = d;
  }

  @override
  void bind(core.MojoMessagePipeEndpoint endpoint) {
    super.bind(endpoint);
    if (!isOpen && (_impl != null)) {
      beginHandlingEvents();
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_ConflictResolverFactoryStubControl($superString)";
  }

  int get version => 0;
}

class ConflictResolverFactoryStub
    extends bindings.Stub<ConflictResolverFactory>
    implements ConflictResolverFactory,
               ConflictResolverFactoryInterface,
               ConflictResolverFactoryInterfaceRequest {
  ConflictResolverFactoryStub.unbound([ConflictResolverFactory impl])
      : super(new _ConflictResolverFactoryStubControl.unbound(impl));

  ConflictResolverFactoryStub.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [ConflictResolverFactory impl])
      : super(new _ConflictResolverFactoryStubControl.fromEndpoint(endpoint, impl));

  ConflictResolverFactoryStub.fromHandle(
      core.MojoHandle handle, [ConflictResolverFactory impl])
      : super(new _ConflictResolverFactoryStubControl.fromHandle(handle, impl));

  static ConflictResolverFactoryStub newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For ConflictResolverFactoryStub"));
    return new ConflictResolverFactoryStub.fromEndpoint(endpoint);
  }


  void getPolicy(List<int> pageId,void callback(ConflictResolutionPolicy policy)) {
    return impl.getPolicy(pageId,callback);
  }
  void newConflictResolver(List<int> pageId, ConflictResolverInterfaceRequest resolver) {
    return impl.newConflictResolver(pageId, resolver);
  }
}

const int _conflictResolverMethodResolveName = 0;

class _ConflictResolverServiceDescription implements service_describer.ServiceDescription {
  void getTopLevelInterface(Function responder) {
    responder(null);
  }

  void getTypeDefinition(String typeKey, Function responder) {
    responder(null);
  }

  void getAllTypeDefinitions(Function responder) {
    responder(null);
  }
}

abstract class ConflictResolver {
  static const String serviceName = null;

  static service_describer.ServiceDescription _cachedServiceDescription;
  static service_describer.ServiceDescription get serviceDescription {
    if (_cachedServiceDescription == null) {
      _cachedServiceDescription = new _ConflictResolverServiceDescription();
    }
    return _cachedServiceDescription;
  }

  static ConflictResolverProxy connectToService(
      bindings.ServiceConnector s, String url, [String serviceName]) {
    ConflictResolverProxy p = new ConflictResolverProxy.unbound();
    String name = serviceName ?? ConflictResolver.serviceName;
    if ((name == null) || name.isEmpty) {
      throw new core.MojoApiError(
          "If an interface has no ServiceName, then one must be provided.");
    }
    s.connectToService(url, p, name);
    return p;
  }
  void resolve(PageChange change1,PageChange change2,PageSnapshotInterface commonVersion,void callback(List<EntryChange> mergeChanges));
}

abstract class ConflictResolverInterface
    implements bindings.MojoInterface<ConflictResolver>,
               ConflictResolver {
  factory ConflictResolverInterface([ConflictResolver impl]) =>
      new ConflictResolverStub.unbound(impl);

  factory ConflictResolverInterface.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint,
      [ConflictResolver impl]) =>
      new ConflictResolverStub.fromEndpoint(endpoint, impl);

  factory ConflictResolverInterface.fromMock(
      ConflictResolver mock) =>
      new ConflictResolverProxy.fromMock(mock);
}

abstract class ConflictResolverInterfaceRequest
    implements bindings.MojoInterface<ConflictResolver>,
               ConflictResolver {
  factory ConflictResolverInterfaceRequest() =>
      new ConflictResolverProxy.unbound();
}

class _ConflictResolverProxyControl
    extends bindings.ProxyMessageHandler
    implements bindings.ProxyControl<ConflictResolver> {
  ConflictResolver impl;

  _ConflictResolverProxyControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) : super.fromEndpoint(endpoint);

  _ConflictResolverProxyControl.fromHandle(
      core.MojoHandle handle) : super.fromHandle(handle);

  _ConflictResolverProxyControl.unbound() : super.unbound();

  String get serviceName => ConflictResolver.serviceName;

  void handleResponse(bindings.ServiceMessage message) {
    switch (message.header.type) {
      case _conflictResolverMethodResolveName:
        Function callback = getCallback(message);
        if (callback != null) {
          var r = ConflictResolverResolveResponseParams.deserialize(
              message.payload);
          callback(r.mergeChanges );
        }
        break;
      default:
        proxyError("Unexpected message type: ${message.header.type}");
        close(immediate: true);
        break;
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_ConflictResolverProxyControl($superString)";
  }
}

class ConflictResolverProxy
    extends bindings.Proxy<ConflictResolver>
    implements ConflictResolver,
               ConflictResolverInterface,
               ConflictResolverInterfaceRequest {
  ConflictResolverProxy.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint)
      : super(new _ConflictResolverProxyControl.fromEndpoint(endpoint));

  ConflictResolverProxy.fromHandle(core.MojoHandle handle)
      : super(new _ConflictResolverProxyControl.fromHandle(handle));

  ConflictResolverProxy.unbound()
      : super(new _ConflictResolverProxyControl.unbound());

  factory ConflictResolverProxy.fromMock(ConflictResolver mock) {
    ConflictResolverProxy newMockedProxy =
        new ConflictResolverProxy.unbound();
    newMockedProxy.impl = mock;
    return newMockedProxy;
  }

  static ConflictResolverProxy newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For ConflictResolverProxy"));
    return new ConflictResolverProxy.fromEndpoint(endpoint);
  }


  void resolve(PageChange change1,PageChange change2,PageSnapshotInterface commonVersion,void callback(List<EntryChange> mergeChanges)) {
    if (impl != null) {
      impl.resolve(change1,change2,commonVersion,callback ?? bindings.DoNothingFunction.fn);
      return;
    }
    var params = new _ConflictResolverResolveParams();
    params.change1 = change1;
    params.change2 = change2;
    params.commonVersion = commonVersion;
    Function zonedCallback;
    if ((callback == null) || identical(Zone.current, Zone.ROOT)) {
      zonedCallback = callback;
    } else {
      Zone z = Zone.current;
      zonedCallback = ((List<EntryChange> mergeChanges) {
        z.bindCallback(() {
          callback(mergeChanges);
        })();
      });
    }
    ctrl.sendMessageWithRequestId(
        params,
        _conflictResolverMethodResolveName,
        -1,
        bindings.MessageHeader.kMessageExpectsResponse,
        zonedCallback);
  }
}

class _ConflictResolverStubControl
    extends bindings.StubMessageHandler
    implements bindings.StubControl<ConflictResolver> {
  ConflictResolver _impl;

  _ConflictResolverStubControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [ConflictResolver impl])
      : super.fromEndpoint(endpoint, autoBegin: impl != null) {
    _impl = impl;
  }

  _ConflictResolverStubControl.fromHandle(
      core.MojoHandle handle, [ConflictResolver impl])
      : super.fromHandle(handle, autoBegin: impl != null) {
    _impl = impl;
  }

  _ConflictResolverStubControl.unbound([this._impl]) : super.unbound();

  String get serviceName => ConflictResolver.serviceName;


  Function _conflictResolverResolveResponseParamsResponder(
      int requestId) {
  return (List<EntryChange> mergeChanges) {
      var result = new ConflictResolverResolveResponseParams();
      result.mergeChanges = mergeChanges;
      sendResponse(buildResponseWithId(
          result,
          _conflictResolverMethodResolveName,
          requestId,
          bindings.MessageHeader.kMessageIsResponse));
    };
  }

  void handleMessage(bindings.ServiceMessage message) {
    if (bindings.ControlMessageHandler.isControlMessage(message)) {
      bindings.ControlMessageHandler.handleMessage(
          this, 0, message);
      return;
    }
    if (_impl == null) {
      throw new core.MojoApiError("$this has no implementation set");
    }
    switch (message.header.type) {
      case _conflictResolverMethodResolveName:
        var params = _ConflictResolverResolveParams.deserialize(
            message.payload);
        _impl.resolve(params.change1, params.change2, params.commonVersion, _conflictResolverResolveResponseParamsResponder(message.header.requestId));
        break;
      default:
        throw new bindings.MojoCodecError("Unexpected message name");
        break;
    }
  }

  ConflictResolver get impl => _impl;
  set impl(ConflictResolver d) {
    if (d == null) {
      throw new core.MojoApiError("$this: Cannot set a null implementation");
    }
    if (isBound && (_impl == null)) {
      beginHandlingEvents();
    }
    _impl = d;
  }

  @override
  void bind(core.MojoMessagePipeEndpoint endpoint) {
    super.bind(endpoint);
    if (!isOpen && (_impl != null)) {
      beginHandlingEvents();
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_ConflictResolverStubControl($superString)";
  }

  int get version => 0;
}

class ConflictResolverStub
    extends bindings.Stub<ConflictResolver>
    implements ConflictResolver,
               ConflictResolverInterface,
               ConflictResolverInterfaceRequest {
  ConflictResolverStub.unbound([ConflictResolver impl])
      : super(new _ConflictResolverStubControl.unbound(impl));

  ConflictResolverStub.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [ConflictResolver impl])
      : super(new _ConflictResolverStubControl.fromEndpoint(endpoint, impl));

  ConflictResolverStub.fromHandle(
      core.MojoHandle handle, [ConflictResolver impl])
      : super(new _ConflictResolverStubControl.fromHandle(handle, impl));

  static ConflictResolverStub newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For ConflictResolverStub"));
    return new ConflictResolverStub.fromEndpoint(endpoint);
  }


  void resolve(PageChange change1,PageChange change2,PageSnapshotInterface commonVersion,void callback(List<EntryChange> mergeChanges)) {
    return impl.resolve(change1,change2,commonVersion,callback);
  }
}



