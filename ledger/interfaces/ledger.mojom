// Copyright 2016 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

[DartPackage="modular_services"]
module ledger;

[ServiceName="ledger::Ledger"]

interface Ledger {
  // Authenticates a given user and, if successful, returns a unique user id.
  // TODO(nellv): Define what credentials are necessary to authenticate a user.
  Authenticate(string username) => (UserId? user_id, Status status);

  // Creates an empty session and returns a universally unique |SessionId|.
  CreateSession() => (SessionId? session_id, Status status);

  // Returns the graph representation of the session graph for the given session
  // id. A new session with |session_id| will be created if session doesn't exist
  // and in |options|, field |createIfMissing| is true.
  GetSessionGraph(SessionId session_id, LedgerOptions options)
      => (SessionGraph? session_graph, Status status);

  // Adds the observer which is notified upon changes on the given session graph
  // that match the given path expression. If the query is null, all changes in
  // the given session will be returned.
  AddObserver(SessionId session_id, PathExpression? query,
          LedgerObserver observer)
      => (Status status);

  // Updates the graph by adding or removing the given nodes and edges and
  // by updating the given representation values. The deletion of a node also
  // triggers the deletion of any connected edges.
  UpdateSessionGraph(SessionId session_id, array<NodeRecord>? nodes_to_add,
      array<EdgeRecord>? edges_to_add, array<Representation>? values_to_update,
      array<NodeId>? nodes_to_remove, array<EdgeId>? edges_to_remove)
      => (Status status);

  // TODO(nellyv): add methods for ACLs:
  // // Grants the given user access to an existing session.
  // GrantAccess(SessionId session_id, UserId user_id) => (Status status);
  //
  // // Checks whether a given user has access to an existing session.
  // HasAccess(SessionId session_id, UserId user_id) => (Status status);
  //
  // // Returns the |SessionId|s of all stored sessions.
  // GetUserSessionIds(UserId user_id)
  //     => (array<SessionId> session_ids, Status status);

  enum Status {
    // The call completed successfully.
    OK = 0,
    // The requested session_id was not found.
    NOT_FOUND,
    // There was an authentication problem.
    NOT_AUTHORIZED,
    // An illegal argument was given.
    ILLEGAL_ARGUMENT,
    // The call failed after an internal error.
    INTERNAL_ERROR,
  };
};

interface LedgerObserver {
  // Called upon changes on the session graph. No new |OnChange| calls will
  // be made to this observer until the callback is executed. Changes can be new
  // nodes, new edges or updates in representation values. |changes| array is
  // ordered by the type of update: node updates are first, followed by edge and
  // then, representation value updates. When the value equals null, the
  // previous value is now deleted.
  OnChange(array<GraphUpdate> changes) => ();
};

union GraphUpdate {
  NodeRecord node_added;
  NodeId node_removed;

  EdgeRecord edge_added;
  EdgeId edge_removed;

  Representation value_updated;
};

struct LedgerOptions {
  // When used to fetch a session from ledger, this option creates the session
  // if not found.
  bool createIfMissing;
};

struct SessionGraph {
  array<NodeRecord> nodes;
  array<EdgeRecord> edges;
};

struct NodeRecord {
  //  The id of the node.
  NodeId node_id;

  // The id of the device that created this node. Not needed when creating a
  // node, but always present when receiving it from the ledger.
  DeviceId? creation_device;

  // The id of the user that created this node.Not needed when creating a node,
  // but always present when receiving it from the ledger.
  UserId? creation_user;

  // A mapping from label uris to the representation values of the node. Values
  // are represented here as bytearrays, but might be blob references in
  // syncbase. A value equal to null means that the corresponding label is
  // deleted.
  array<Representation>? representation_values;

  // Whether this node is deleted.
  bool deleted;
};

struct EdgeRecord {
  //  The id of the node.
  EdgeId edge_id;

  // The start and end node IDs.
  NodeId start;
  NodeId end;

  // The semantic labels of the edge.
  array<LabelUri> labels;

  // The id of the device that created this edge. Not needed when creating a
  // edge, but always present when receiving it from the ledger.
  DeviceId? creation_device;

  // The id of the user that created this edge. Not needed when creating a edge,
  // but always present when receiving it from the ledger.
  UserId? creation_user;

  // Whether this edge is deleted or not.
  bool deleted;
};

// The description of a representation value of a node.
struct Representation {
  // The id of the node.
  NodeId nodeId;

  // The label corresponding to the given value.
  LabelUri label;

  // The time when this value was created.
  uint64 timestamp;

  // The representation value. If not present, the representation for this label
  // is deleted..
  array<uint8>? value;
};

struct EdgeId {
  string id;
};

struct NodeId {
  string id;
};

struct DeviceId {
  string id;
};

struct UserId {
  string id;
};

struct StepId {
  string id;
};

struct SessionId {
  string id;
};

struct LabelUri {
  string uri;
};

// The following structs give a recursive definition of a path expression.
// A LabelExpression corresponds to an edge of the path expression's tree and
// a PathExpression to a node.
//
// For example consider the path expression: (A B) { C+, D? <E, F> }. For
// simplicity suppose that A, B, ..., F are all LabelUris.
// The Json representation would be:
// {
//   expressions : [  /* Path expression: "(A B) { C+, D? <E, F> }" */
//     semantic : {
//       labels : [A, B],
//       cardinality : SINGULAR,
//       next : {
//         expressions : [  /* Path expression: "{ C+, D? <E, F> }" */
//           semantic : {
//             labels : [C],
//             cardinality : REPEATED,
//             next: null
//           },
//           semantic : {
//             labels : [D],
//             cardinality : OPTIONAL,
//             next : {
//               expressions : [  /* Path expression: "<E, F>" */
//                 representation : {
//                   labels : [E, F]}]}}]}}]}

// A path expression used to query the session graph.
struct PathExpression {
  array<LabelExpression> expressions;
};

union LabelExpression {
  SemanticExpression semantic;
  RepresentationExpression representation;
};

struct SemanticExpression {
  array<LabelUri> labels;
  Cardinality cardinality;
  PathExpression? next;
};

struct RepresentationExpression {
  array<LabelUri> labels;
};

enum Cardinality {
  SINGULAR,
  OPTIONAL,
  REPEATED,
  OPTIONAL_REPEATED,
};
